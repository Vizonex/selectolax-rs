/* automatically generated by rust-bindgen 0.65.1 */

pub const LEXBOR_FORMAT_Z: &[u8; 4usize] = b"%Iu\0";
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1usize] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const LEXBOR_VERSION_MAJOR: u32 = 1;
pub const LEXBOR_VERSION_MINOR: u32 = 7;
pub const LEXBOR_VERSION_PATCH: u32 = 0;
pub const LXB_DOM_VERSION_MAJOR: u32 = 1;
pub const LXB_DOM_VERSION_MINOR: u32 = 6;
pub const LXB_DOM_VERSION_PATCH: u32 = 0;
pub const LXB_TAG_CONST_VERSION: &[u8; 33usize] = b"A161EC911182C3254E7A972D5C51DF86\0";
pub const LXB_NS_CONST_VERSION: &[u8; 33usize] = b"253D4AFDA959234B48A478B956C3C777\0";
pub const LEXBOR_HASH_SHORT_SIZE: u32 = 16;
pub const LEXBOR_HASH_TABLE_MIN_SIZE: u32 = 32;
pub const LXB_HTML_VERSION_MAJOR: u32 = 2;
pub const LXB_HTML_VERSION_MINOR: u32 = 3;
pub const LXB_HTML_VERSION_PATCH: u32 = 0;
pub const LXB_CSS_VERSION_MAJOR: u32 = 1;
pub const LXB_CSS_VERSION_MINOR: u32 = 1;
pub const LXB_CSS_VERSION_PATCH: u32 = 0;
pub const LXB_CSS_SYNTAX_VERSION_MAJOR: u32 = 1;
pub const LXB_CSS_SYNTAX_VERSION_MINOR: u32 = 1;
pub const LXB_CSS_SYNTAX_VERSION_PATCH: u32 = 0;
pub const LXB_CSS_SELECTORS_VERSION_MAJOR: u32 = 1;
pub const LXB_CSS_SELECTORS_VERSION_MINOR: u32 = 0;
pub const LXB_CSS_SELECTORS_VERSION_PATCH: u32 = 0;
pub const LXB_CSS_SELECTOR_SP_S_MAX: u32 = 268435455;
pub const LXB_CSS_SELECTOR_SP_A_MAX: u32 = 134217727;
pub const LXB_CSS_SELECTOR_SP_B_MAX: u32 = 262143;
pub const LXB_CSS_SELECTOR_SP_C_MAX: u32 = 511;
pub const LXB_SELECTORS_VERSION_MAJOR: u32 = 0;
pub const LXB_SELECTORS_VERSION_MINOR: u32 = 2;
pub const LXB_SELECTORS_VERSION_PATCH: u32 = 0;
pub type va_list = *mut cty::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut cty::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = cty::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = cty::c_schar;
pub type int_least16_t = cty::c_short;
pub type int_least32_t = cty::c_int;
pub type int_least64_t = cty::c_longlong;
pub type uint_least8_t = cty::c_uchar;
pub type uint_least16_t = cty::c_ushort;
pub type uint_least32_t = cty::c_uint;
pub type uint_least64_t = cty::c_ulonglong;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_int;
pub type int_fast32_t = cty::c_int;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_uint;
pub type uint_fast32_t = cty::c_uint;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = cty::c_longlong;
pub type uintmax_t = cty::c_ulonglong;
pub type lxb_codepoint_t = u32;
pub type lxb_char_t = cty::c_uchar;
pub type lxb_status_t = cty::c_uint;
pub type lexbor_callback_f = ::core::option::Option<
    unsafe extern "C" fn(
        buffer: *const lxb_char_t,
        size: usize,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
pub type lexbor_memory_malloc_f =
    ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut cty::c_void>;
pub type lexbor_memory_realloc_f = ::core::option::Option<
    unsafe extern "C" fn(dst: *mut cty::c_void, size: usize) -> *mut cty::c_void,
>;
pub type lexbor_memory_calloc_f =
    ::core::option::Option<unsafe extern "C" fn(num: usize, size: usize) -> *mut cty::c_void>;
pub type lexbor_memory_free_f = ::core::option::Option<unsafe extern "C" fn(dst: *mut cty::c_void)>;
extern "C" {
    pub fn lexbor_malloc(size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_realloc(dst: *mut cty::c_void, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_calloc(num: usize, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_free(dst: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_memory_setup(
        new_malloc: lexbor_memory_malloc_f,
        new_realloc: lexbor_memory_realloc_f,
        new_calloc: lexbor_memory_calloc_f,
        new_free: lexbor_memory_free_f,
    ) -> lxb_status_t;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: cty::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = cty::c_int;
pub type wint_t = cty::c_ushort;
pub type wctype_t = cty::c_ushort;
pub type __time32_t = cty::c_long;
pub type __time64_t = cty::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const cty::c_ushort,
    pub _locale_mb_cur_max: cty::c_int,
    pub _locale_lc_codepage: cty::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::core::mem::MaybeUninit<__crt_locale_data_public> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::core::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::core::mem::MaybeUninit<__crt_locale_pointers> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::core::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _Mbstatet {
    pub _Wchar: cty::c_ulong,
    pub _Byte: cty::c_ushort,
    pub _State: cty::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::core::mem::MaybeUninit<_Mbstatet> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::core::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn calloc(_Count: cty::c_ulonglong, _Size: cty::c_ulonglong) -> *mut cty::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> cty::c_int;
}
extern "C" {
    pub fn _expand(_Block: *mut cty::c_void, _Size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut cty::c_void);
}
extern "C" {
    pub fn free(_Block: *mut cty::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn malloc(_Size: cty::c_ulonglong) -> *mut cty::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut cty::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut cty::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(_Block: *mut cty::c_void, _Size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn realloc(_Block: *mut cty::c_void, _Size: cty::c_ulonglong) -> *mut cty::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut cty::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _recalloc(_Block: *mut cty::c_void, _Count: usize, _Size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut cty::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _aligned_msize(_Block: *mut cty::c_void, _Alignment: usize, _Offset: usize) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut cty::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut cty::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut cty::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut cty::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _errno() -> *mut cty::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: cty::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut cty::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> cty::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: *const cty::c_void,
    ) -> cty::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const cty::c_void,
        _Base: *const cty::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut cty::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut cty::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const cty::c_void,
        _Base: *const cty::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut cty::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const cty::c_void,
        _Base: *const cty::c_void,
        _NumOfElements: *mut cty::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const cty::c_void,
        _Base: *const cty::c_void,
        _NumOfElements: *mut cty::c_uint,
        _SizeOfElements: cty::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const cty::c_void,
        _Base: *mut cty::c_void,
        _NumOfElements: *mut cty::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const cty::c_void,
        _Base: *mut cty::c_void,
        _NumOfElements: *mut cty::c_uint,
        _SizeOfElements: cty::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const cty::c_void,
        _Base: *const cty::c_void,
        _NumOfElements: *mut cty::c_uint,
        _SizeOfElements: cty::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const cty::c_void,
        _Base: *mut cty::c_void,
        _NumOfElements: *mut cty::c_uint,
        _SizeOfElements: cty::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: cty::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(_Value: cty::c_int, _Buffer: *mut wchar_t, _Radix: cty::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: cty::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(_Value: cty::c_long, _Buffer: *mut wchar_t, _Radix: cty::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: cty::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(_Value: cty::c_ulong, _Buffer: *mut wchar_t, _Radix: cty::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> cty::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> cty::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> cty::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> cty::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> cty::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: cty::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: cty::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: cty::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: cty::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: cty::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: cty::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> cty::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> cty::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _swab(_Buf1: *mut cty::c_char, _Buf2: *mut cty::c_char, _SizeInBytes: cty::c_int);
}
extern "C" {
    pub fn exit(_Code: cty::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: cty::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: cty::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: cty::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(_Flags: cty::c_uint, _Mask: cty::c_uint) -> cty::c_uint;
}
pub type _onexit_t = ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>;
extern "C" {
    pub fn atexit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
pub type _purecall_handler = ::core::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: cty::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn __doserrno() -> *mut cty::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: cty::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut cty::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut cty::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut cty::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const cty::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut cty::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut cty::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut cty::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: cty::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut cty::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _div_t {
    pub quot: cty::c_int,
    pub rem: cty::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::core::mem::MaybeUninit<_div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ldiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _lldiv_t {
    pub quot: cty::c_longlong,
    pub rem: cty::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn labs(_Number: cty::c_long) -> cty::c_long;
}
extern "C" {
    pub fn llabs(_Number: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: cty::c_ushort) -> cty::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: cty::c_ulong) -> cty::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: cty::c_ulonglong) -> cty::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: cty::c_int, _Denominator: cty::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: cty::c_long, _Denominator: cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(_Numerator: cty::c_longlong, _Denominator: cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(_Value: cty::c_uint, _Shift: cty::c_int) -> cty::c_uint;
}
extern "C" {
    pub fn _lrotl(_Value: cty::c_ulong, _Shift: cty::c_int) -> cty::c_ulong;
}
extern "C" {
    pub fn _rotl64(_Value: cty::c_ulonglong, _Shift: cty::c_int) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _rotr(_Value: cty::c_uint, _Shift: cty::c_int) -> cty::c_uint;
}
extern "C" {
    pub fn _lrotr(_Value: cty::c_ulong, _Shift: cty::c_int) -> cty::c_ulong;
}
extern "C" {
    pub fn _rotr64(_Value: cty::c_ulonglong, _Shift: cty::c_int) -> cty::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: cty::c_uint);
}
extern "C" {
    pub fn rand() -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LDOUBLE {
    pub ld: [cty::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::core::mem::MaybeUninit<_LDOUBLE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::core::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::core::mem::MaybeUninit<_CRT_DOUBLE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::core::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::core::mem::MaybeUninit<_CRT_FLOAT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::core::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::core::mem::MaybeUninit<_LONGDOUBLE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::core::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LDBL12 {
    pub ld12: [cty::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::core::mem::MaybeUninit<_LDBL12> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::core::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const cty::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn atol(_String: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn atoll(_String: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const cty::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(_String: *const cty::c_char, _Locale: _locale_t) -> cty::c_int;
}
extern "C" {
    pub fn _atol_l(_String: *const cty::c_char, _Locale: _locale_t) -> cty::c_long;
}
extern "C" {
    pub fn _atoll_l(_String: *const cty::c_char, _Locale: _locale_t) -> cty::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(_String: *const cty::c_char, _Locale: _locale_t) -> cty::c_longlong;
}
extern "C" {
    pub fn _atoflt(_Result: *mut _CRT_FLOAT, _String: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _atodbl(_Result: *mut _CRT_DOUBLE, _String: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _atoldbl(_Result: *mut _LDOUBLE, _String: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strtof(_String: *const cty::c_char, _EndPtr: *mut *mut cty::c_char) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(_String: *const cty::c_char, _EndPtr: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(_String: *const cty::c_char, _EndPtr: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const cty::c_char,
        _EndPtr: *mut *mut cty::c_char,
        _Radix: cty::c_int,
        _Locale: _locale_t,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: cty::c_int,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: cty::c_int,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: cty::c_long,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: cty::c_long,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: cty::c_ulong,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: cty::c_ulong,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: cty::c_longlong,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: cty::c_longlong,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: cty::c_ulonglong,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Radix: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: cty::c_ulonglong,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: cty::c_int,
        _PtDec: *mut cty::c_int,
        _PtSign: *mut cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: cty::c_int,
        _PtDec: *mut cty::c_int,
        _PtSign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: cty::c_int,
        _PtDec: *mut cty::c_int,
        _PtSign: *mut cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: cty::c_int,
        _PtDec: *mut cty::c_int,
        _PtSign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: cty::c_int,
        _Buffer: *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> cty::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> cty::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const cty::c_char, _MaxCount: usize) -> cty::c_int;
}
extern "C" {
    pub fn _mblen_l(_Ch: *const cty::c_char, _MaxCount: usize, _Locale: _locale_t) -> cty::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const cty::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const cty::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const cty::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(_String: *const cty::c_char, _MaxCount: usize, _Locale: _locale_t)
        -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const cty::c_char,
        _SrcSizeInBytes: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const cty::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const cty::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(_Dest: *mut wchar_t, _Source: *const cty::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const cty::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const cty::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut cty::c_char, _WCh: wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wctomb_l(_MbCh: *mut cty::c_char, _WCh: wchar_t, _Locale: _locale_t) -> cty::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut cty::c_int,
        _MbCh: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut cty::c_int,
        _MbCh: *mut cty::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut cty::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(_Dest: *mut cty::c_char, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut cty::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut cty::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut cty::c_char,
        _Path: *const cty::c_char,
        _BufferCount: usize,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Drive: *const cty::c_char,
        _Dir: *const cty::c_char,
        _Filename: *const cty::c_char,
        _Ext: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut cty::c_char,
        _Drive: *const cty::c_char,
        _Dir: *const cty::c_char,
        _Filename: *const cty::c_char,
        _Ext: *const cty::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const cty::c_char,
        _Drive: *mut cty::c_char,
        _Dir: *mut cty::c_char,
        _Filename: *mut cty::c_char,
        _Ext: *mut cty::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const cty::c_char,
        _Drive: *mut cty::c_char,
        _DriveCount: usize,
        _Dir: *mut cty::c_char,
        _DirCount: usize,
        _Filename: *mut cty::c_char,
        _FilenameCount: usize,
        _Ext: *mut cty::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut cty::c_char,
        _BufferCount: rsize_t,
        _VarName: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut cty::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut cty::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut cty::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut cty::c_char,
        _BufferCount: *mut usize,
        _VarName: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _putenv_s(_Name: *const cty::c_char, _Value: *const cty::c_char) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const cty::c_char,
        _VarName: *const cty::c_char,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const cty::c_char,
        _VarName: *const cty::c_char,
        _Buffer: *mut cty::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: cty::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: cty::c_uint, _Duration: cty::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: cty::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: cty::c_int,
        _PtDec: *mut cty::c_int,
        _PtSign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: cty::c_int,
        _PtDec: *mut cty::c_int,
        _PtSign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: cty::c_int,
        _DstBuf: *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: cty::c_int,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: cty::c_long,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn swab(_Buf1: *mut cty::c_char, _Buf2: *mut cty::c_char, _SizeInBytes: cty::c_int);
}
extern "C" {
    pub fn ultoa(
        _Value: cty::c_ulong,
        _Buffer: *mut cty::c_char,
        _Radix: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _iobuf {
    pub _Placeholder: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    const UNINIT: ::core::mem::MaybeUninit<_iobuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::core::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._Placeholder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
impl Default for _iobuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: cty::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: cty::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: cty::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: cty::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: cty::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: cty::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: cty::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: cty::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: cty::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
pub type fpos_t = cty::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut cty::c_char,
        _Pointer: *mut *mut *mut cty::c_char,
        _Count: *mut *mut cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const cty::c_char,
        _Mode: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut cty::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const cty::c_char,
        _Mode: *const cty::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(_Buffer: *mut cty::c_char, _Size: rsize_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut cty::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fcloseall() -> cty::c_int;
}
extern "C" {
    pub fn _fdopen(_FileHandle: cty::c_int, _Mode: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetchar() -> cty::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut cty::c_char,
        _MaxCount: cty::c_int,
        _Stream: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _flushall() -> cty::c_int;
}
extern "C" {
    pub fn fopen(_FileName: *const cty::c_char, _Mode: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fputs(_Buffer: *const cty::c_char, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut cty::c_void,
        _ElementSize: cty::c_ulonglong,
        _ElementCount: cty::c_ulonglong,
        _Stream: *mut FILE,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const cty::c_char,
        _Mode: *const cty::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const cty::c_char,
        _Mode: *const cty::c_char,
        _ShFlag: cty::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fseek(_Stream: *mut FILE, _Offset: cty::c_long, _Origin: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: cty::c_longlong,
        _Origin: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> cty::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const cty::c_void,
        _ElementSize: cty::c_ulonglong,
        _ElementCount: cty::c_ulonglong,
        _Stream: *mut FILE,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> cty::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _popen(_Command: *const cty::c_char, _Mode: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(_Character: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _putw(_Word: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(_OldFileName: *const cty::c_char, _NewFileName: *const cty::c_char)
        -> cty::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> cty::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut cty::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut cty::c_char,
        _Mode: cty::c_int,
        _Size: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const cty::c_char,
        _FilePrefix: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ungetc(_Character: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_nolock(_Character: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut cty::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut cty::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: cty::c_long,
        _Origin: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: cty::c_longlong,
        _Origin: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> cty::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const cty::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putc_nolock(_Character: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(_Character: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: cty::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: cty::c_ulonglong,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: cty::c_ulonglong,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: cty::c_ulonglong,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: cty::c_ulonglong,
        _Buffer: *mut cty::c_char,
        _BufferCount: usize,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: cty::c_ulonglong,
        _Buffer: *const cty::c_char,
        _BufferCount: usize,
        _Format: *const cty::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const cty::c_char,
        _FilePrefix: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn fcloseall() -> cty::c_int;
}
extern "C" {
    pub fn fdopen(_FileHandle: cty::c_int, _Format: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> cty::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn flushall() -> cty::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putw(_Ch: cty::c_int, _Stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn rmtmp() -> cty::c_int;
}
extern "C" {
    pub fn memchr(
        _Buf: *const cty::c_void,
        _Val: cty::c_int,
        _MaxCount: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: cty::c_ulonglong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut cty::c_void,
        _Val: cty::c_int,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn strchr(_Str: *const cty::c_char, _Val: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(_Str: *const cty::c_char, _Ch: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strstr(_Str: *const cty::c_char, _SubStr: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const cty::c_ushort, _Ch: cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Val: cty::c_int,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(_String1: *const cty::c_ushort, _String2: *const cty::c_ushort) -> cty::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const cty::c_ushort) -> cty::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const cty::c_ushort,
        _String2: *const cty::c_ushort,
        _MaxCount: cty::c_ulonglong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: cty::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut cty::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut cty::c_char,
        _Delimiter: *const cty::c_char,
        _Context: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Val: cty::c_int,
        _MaxCount: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcat(_Destination: *mut cty::c_char, _Source: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(_Str1: *const cty::c_char, _Str2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _strcmpi(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(_Destination: *mut cty::c_char, _Source: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(_Str: *const cty::c_char, _Control: *const cty::c_char) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut cty::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn _stricmp(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _stricoll(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const cty::c_char) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut cty::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(_String: *mut cty::c_char, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(_String: *mut cty::c_char, _Locale: _locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _Count: cty::c_ulonglong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const cty::c_char,
        _Str2: *const cty::c_char,
        _MaxCount: cty::c_ulonglong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const cty::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _Count: cty::c_ulonglong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const cty::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut cty::c_char,
        _SizeInBytes: usize,
        _Value: cty::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut cty::c_char,
        _Value: cty::c_int,
        _Count: usize,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strpbrk(_Str: *const cty::c_char, _Control: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut cty::c_char,
        _DestinationSize: usize,
        _Value: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(_Destination: *mut cty::c_char, _Value: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(_Str: *const cty::c_char, _Control: *const cty::c_char) -> cty::c_ulonglong;
}
extern "C" {
    pub fn strtok(_String: *mut cty::c_char, _Delimiter: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut cty::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strupr_s_l(_String: *mut cty::c_char, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(_String: *mut cty::c_char, _Locale: _locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _MaxCount: cty::c_ulonglong,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmpi(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn stricmp(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut cty::c_char,
        _Value: cty::c_int,
        _MaxCount: usize,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strset(_String: *mut cty::c_char, _Value: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
pub const lexbor_status_t_LXB_STATUS_OK: lexbor_status_t = 0;
pub const lexbor_status_t_LXB_STATUS_ERROR: lexbor_status_t = 1;
pub const lexbor_status_t_LXB_STATUS_ERROR_MEMORY_ALLOCATION: lexbor_status_t = 2;
pub const lexbor_status_t_LXB_STATUS_ERROR_OBJECT_IS_NULL: lexbor_status_t = 3;
pub const lexbor_status_t_LXB_STATUS_ERROR_SMALL_BUFFER: lexbor_status_t = 4;
pub const lexbor_status_t_LXB_STATUS_ERROR_INCOMPLETE_OBJECT: lexbor_status_t = 5;
pub const lexbor_status_t_LXB_STATUS_ERROR_NO_FREE_SLOT: lexbor_status_t = 6;
pub const lexbor_status_t_LXB_STATUS_ERROR_TOO_SMALL_SIZE: lexbor_status_t = 7;
pub const lexbor_status_t_LXB_STATUS_ERROR_NOT_EXISTS: lexbor_status_t = 8;
pub const lexbor_status_t_LXB_STATUS_ERROR_WRONG_ARGS: lexbor_status_t = 9;
pub const lexbor_status_t_LXB_STATUS_ERROR_WRONG_STAGE: lexbor_status_t = 10;
pub const lexbor_status_t_LXB_STATUS_ERROR_UNEXPECTED_RESULT: lexbor_status_t = 11;
pub const lexbor_status_t_LXB_STATUS_ERROR_UNEXPECTED_DATA: lexbor_status_t = 12;
pub const lexbor_status_t_LXB_STATUS_ERROR_OVERFLOW: lexbor_status_t = 13;
pub const lexbor_status_t_LXB_STATUS_CONTINUE: lexbor_status_t = 14;
pub const lexbor_status_t_LXB_STATUS_SMALL_BUFFER: lexbor_status_t = 15;
pub const lexbor_status_t_LXB_STATUS_ABORTED: lexbor_status_t = 16;
pub const lexbor_status_t_LXB_STATUS_STOPPED: lexbor_status_t = 17;
pub const lexbor_status_t_LXB_STATUS_NEXT: lexbor_status_t = 18;
pub const lexbor_status_t_LXB_STATUS_STOP: lexbor_status_t = 19;
pub const lexbor_status_t_LXB_STATUS_WARNING: lexbor_status_t = 20;
pub type lexbor_status_t = cty::c_int;
pub const lexbor_action_t_LEXBOR_ACTION_OK: lexbor_action_t = 0;
pub const lexbor_action_t_LEXBOR_ACTION_STOP: lexbor_action_t = 1;
pub const lexbor_action_t_LEXBOR_ACTION_NEXT: lexbor_action_t = 2;
pub type lexbor_action_t = cty::c_int;
pub type lexbor_serialize_cb_f = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const lxb_char_t,
        len: usize,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
pub type lexbor_serialize_cb_cp_f = ::core::option::Option<
    unsafe extern "C" fn(
        cps: *const lxb_codepoint_t,
        len: usize,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_serialize_ctx_t {
    pub cb: lexbor_serialize_cb_f,
    pub ctx: *mut cty::c_void,
    pub opt: isize,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_lexbor_serialize_ctx_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_serialize_ctx_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_serialize_ctx_t>(),
        32usize,
        concat!("Size of: ", stringify!(lexbor_serialize_ctx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_serialize_ctx_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_serialize_ctx_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_serialize_ctx_t),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_serialize_ctx_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_serialize_ctx_t),
            "::",
            stringify!(opt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_serialize_ctx_t),
            "::",
            stringify!(count)
        )
    );
}
impl Default for lexbor_serialize_ctx_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_tag_id_t = usize;
pub const lxb_tag_id_enum_t_LXB_TAG__UNDEF: lxb_tag_id_enum_t = 0;
pub const lxb_tag_id_enum_t_LXB_TAG__END_OF_FILE: lxb_tag_id_enum_t = 1;
pub const lxb_tag_id_enum_t_LXB_TAG__TEXT: lxb_tag_id_enum_t = 2;
pub const lxb_tag_id_enum_t_LXB_TAG__DOCUMENT: lxb_tag_id_enum_t = 3;
pub const lxb_tag_id_enum_t_LXB_TAG__EM_COMMENT: lxb_tag_id_enum_t = 4;
pub const lxb_tag_id_enum_t_LXB_TAG__EM_DOCTYPE: lxb_tag_id_enum_t = 5;
pub const lxb_tag_id_enum_t_LXB_TAG_A: lxb_tag_id_enum_t = 6;
pub const lxb_tag_id_enum_t_LXB_TAG_ABBR: lxb_tag_id_enum_t = 7;
pub const lxb_tag_id_enum_t_LXB_TAG_ACRONYM: lxb_tag_id_enum_t = 8;
pub const lxb_tag_id_enum_t_LXB_TAG_ADDRESS: lxb_tag_id_enum_t = 9;
pub const lxb_tag_id_enum_t_LXB_TAG_ALTGLYPH: lxb_tag_id_enum_t = 10;
pub const lxb_tag_id_enum_t_LXB_TAG_ALTGLYPHDEF: lxb_tag_id_enum_t = 11;
pub const lxb_tag_id_enum_t_LXB_TAG_ALTGLYPHITEM: lxb_tag_id_enum_t = 12;
pub const lxb_tag_id_enum_t_LXB_TAG_ANIMATECOLOR: lxb_tag_id_enum_t = 13;
pub const lxb_tag_id_enum_t_LXB_TAG_ANIMATEMOTION: lxb_tag_id_enum_t = 14;
pub const lxb_tag_id_enum_t_LXB_TAG_ANIMATETRANSFORM: lxb_tag_id_enum_t = 15;
pub const lxb_tag_id_enum_t_LXB_TAG_ANNOTATION_XML: lxb_tag_id_enum_t = 16;
pub const lxb_tag_id_enum_t_LXB_TAG_APPLET: lxb_tag_id_enum_t = 17;
pub const lxb_tag_id_enum_t_LXB_TAG_AREA: lxb_tag_id_enum_t = 18;
pub const lxb_tag_id_enum_t_LXB_TAG_ARTICLE: lxb_tag_id_enum_t = 19;
pub const lxb_tag_id_enum_t_LXB_TAG_ASIDE: lxb_tag_id_enum_t = 20;
pub const lxb_tag_id_enum_t_LXB_TAG_AUDIO: lxb_tag_id_enum_t = 21;
pub const lxb_tag_id_enum_t_LXB_TAG_B: lxb_tag_id_enum_t = 22;
pub const lxb_tag_id_enum_t_LXB_TAG_BASE: lxb_tag_id_enum_t = 23;
pub const lxb_tag_id_enum_t_LXB_TAG_BASEFONT: lxb_tag_id_enum_t = 24;
pub const lxb_tag_id_enum_t_LXB_TAG_BDI: lxb_tag_id_enum_t = 25;
pub const lxb_tag_id_enum_t_LXB_TAG_BDO: lxb_tag_id_enum_t = 26;
pub const lxb_tag_id_enum_t_LXB_TAG_BGSOUND: lxb_tag_id_enum_t = 27;
pub const lxb_tag_id_enum_t_LXB_TAG_BIG: lxb_tag_id_enum_t = 28;
pub const lxb_tag_id_enum_t_LXB_TAG_BLINK: lxb_tag_id_enum_t = 29;
pub const lxb_tag_id_enum_t_LXB_TAG_BLOCKQUOTE: lxb_tag_id_enum_t = 30;
pub const lxb_tag_id_enum_t_LXB_TAG_BODY: lxb_tag_id_enum_t = 31;
pub const lxb_tag_id_enum_t_LXB_TAG_BR: lxb_tag_id_enum_t = 32;
pub const lxb_tag_id_enum_t_LXB_TAG_BUTTON: lxb_tag_id_enum_t = 33;
pub const lxb_tag_id_enum_t_LXB_TAG_CANVAS: lxb_tag_id_enum_t = 34;
pub const lxb_tag_id_enum_t_LXB_TAG_CAPTION: lxb_tag_id_enum_t = 35;
pub const lxb_tag_id_enum_t_LXB_TAG_CENTER: lxb_tag_id_enum_t = 36;
pub const lxb_tag_id_enum_t_LXB_TAG_CITE: lxb_tag_id_enum_t = 37;
pub const lxb_tag_id_enum_t_LXB_TAG_CLIPPATH: lxb_tag_id_enum_t = 38;
pub const lxb_tag_id_enum_t_LXB_TAG_CODE: lxb_tag_id_enum_t = 39;
pub const lxb_tag_id_enum_t_LXB_TAG_COL: lxb_tag_id_enum_t = 40;
pub const lxb_tag_id_enum_t_LXB_TAG_COLGROUP: lxb_tag_id_enum_t = 41;
pub const lxb_tag_id_enum_t_LXB_TAG_DATA: lxb_tag_id_enum_t = 42;
pub const lxb_tag_id_enum_t_LXB_TAG_DATALIST: lxb_tag_id_enum_t = 43;
pub const lxb_tag_id_enum_t_LXB_TAG_DD: lxb_tag_id_enum_t = 44;
pub const lxb_tag_id_enum_t_LXB_TAG_DEL: lxb_tag_id_enum_t = 45;
pub const lxb_tag_id_enum_t_LXB_TAG_DESC: lxb_tag_id_enum_t = 46;
pub const lxb_tag_id_enum_t_LXB_TAG_DETAILS: lxb_tag_id_enum_t = 47;
pub const lxb_tag_id_enum_t_LXB_TAG_DFN: lxb_tag_id_enum_t = 48;
pub const lxb_tag_id_enum_t_LXB_TAG_DIALOG: lxb_tag_id_enum_t = 49;
pub const lxb_tag_id_enum_t_LXB_TAG_DIR: lxb_tag_id_enum_t = 50;
pub const lxb_tag_id_enum_t_LXB_TAG_DIV: lxb_tag_id_enum_t = 51;
pub const lxb_tag_id_enum_t_LXB_TAG_DL: lxb_tag_id_enum_t = 52;
pub const lxb_tag_id_enum_t_LXB_TAG_DT: lxb_tag_id_enum_t = 53;
pub const lxb_tag_id_enum_t_LXB_TAG_EM: lxb_tag_id_enum_t = 54;
pub const lxb_tag_id_enum_t_LXB_TAG_EMBED: lxb_tag_id_enum_t = 55;
pub const lxb_tag_id_enum_t_LXB_TAG_FEBLEND: lxb_tag_id_enum_t = 56;
pub const lxb_tag_id_enum_t_LXB_TAG_FECOLORMATRIX: lxb_tag_id_enum_t = 57;
pub const lxb_tag_id_enum_t_LXB_TAG_FECOMPONENTTRANSFER: lxb_tag_id_enum_t = 58;
pub const lxb_tag_id_enum_t_LXB_TAG_FECOMPOSITE: lxb_tag_id_enum_t = 59;
pub const lxb_tag_id_enum_t_LXB_TAG_FECONVOLVEMATRIX: lxb_tag_id_enum_t = 60;
pub const lxb_tag_id_enum_t_LXB_TAG_FEDIFFUSELIGHTING: lxb_tag_id_enum_t = 61;
pub const lxb_tag_id_enum_t_LXB_TAG_FEDISPLACEMENTMAP: lxb_tag_id_enum_t = 62;
pub const lxb_tag_id_enum_t_LXB_TAG_FEDISTANTLIGHT: lxb_tag_id_enum_t = 63;
pub const lxb_tag_id_enum_t_LXB_TAG_FEDROPSHADOW: lxb_tag_id_enum_t = 64;
pub const lxb_tag_id_enum_t_LXB_TAG_FEFLOOD: lxb_tag_id_enum_t = 65;
pub const lxb_tag_id_enum_t_LXB_TAG_FEFUNCA: lxb_tag_id_enum_t = 66;
pub const lxb_tag_id_enum_t_LXB_TAG_FEFUNCB: lxb_tag_id_enum_t = 67;
pub const lxb_tag_id_enum_t_LXB_TAG_FEFUNCG: lxb_tag_id_enum_t = 68;
pub const lxb_tag_id_enum_t_LXB_TAG_FEFUNCR: lxb_tag_id_enum_t = 69;
pub const lxb_tag_id_enum_t_LXB_TAG_FEGAUSSIANBLUR: lxb_tag_id_enum_t = 70;
pub const lxb_tag_id_enum_t_LXB_TAG_FEIMAGE: lxb_tag_id_enum_t = 71;
pub const lxb_tag_id_enum_t_LXB_TAG_FEMERGE: lxb_tag_id_enum_t = 72;
pub const lxb_tag_id_enum_t_LXB_TAG_FEMERGENODE: lxb_tag_id_enum_t = 73;
pub const lxb_tag_id_enum_t_LXB_TAG_FEMORPHOLOGY: lxb_tag_id_enum_t = 74;
pub const lxb_tag_id_enum_t_LXB_TAG_FEOFFSET: lxb_tag_id_enum_t = 75;
pub const lxb_tag_id_enum_t_LXB_TAG_FEPOINTLIGHT: lxb_tag_id_enum_t = 76;
pub const lxb_tag_id_enum_t_LXB_TAG_FESPECULARLIGHTING: lxb_tag_id_enum_t = 77;
pub const lxb_tag_id_enum_t_LXB_TAG_FESPOTLIGHT: lxb_tag_id_enum_t = 78;
pub const lxb_tag_id_enum_t_LXB_TAG_FETILE: lxb_tag_id_enum_t = 79;
pub const lxb_tag_id_enum_t_LXB_TAG_FETURBULENCE: lxb_tag_id_enum_t = 80;
pub const lxb_tag_id_enum_t_LXB_TAG_FIELDSET: lxb_tag_id_enum_t = 81;
pub const lxb_tag_id_enum_t_LXB_TAG_FIGCAPTION: lxb_tag_id_enum_t = 82;
pub const lxb_tag_id_enum_t_LXB_TAG_FIGURE: lxb_tag_id_enum_t = 83;
pub const lxb_tag_id_enum_t_LXB_TAG_FONT: lxb_tag_id_enum_t = 84;
pub const lxb_tag_id_enum_t_LXB_TAG_FOOTER: lxb_tag_id_enum_t = 85;
pub const lxb_tag_id_enum_t_LXB_TAG_FOREIGNOBJECT: lxb_tag_id_enum_t = 86;
pub const lxb_tag_id_enum_t_LXB_TAG_FORM: lxb_tag_id_enum_t = 87;
pub const lxb_tag_id_enum_t_LXB_TAG_FRAME: lxb_tag_id_enum_t = 88;
pub const lxb_tag_id_enum_t_LXB_TAG_FRAMESET: lxb_tag_id_enum_t = 89;
pub const lxb_tag_id_enum_t_LXB_TAG_GLYPHREF: lxb_tag_id_enum_t = 90;
pub const lxb_tag_id_enum_t_LXB_TAG_H1: lxb_tag_id_enum_t = 91;
pub const lxb_tag_id_enum_t_LXB_TAG_H2: lxb_tag_id_enum_t = 92;
pub const lxb_tag_id_enum_t_LXB_TAG_H3: lxb_tag_id_enum_t = 93;
pub const lxb_tag_id_enum_t_LXB_TAG_H4: lxb_tag_id_enum_t = 94;
pub const lxb_tag_id_enum_t_LXB_TAG_H5: lxb_tag_id_enum_t = 95;
pub const lxb_tag_id_enum_t_LXB_TAG_H6: lxb_tag_id_enum_t = 96;
pub const lxb_tag_id_enum_t_LXB_TAG_HEAD: lxb_tag_id_enum_t = 97;
pub const lxb_tag_id_enum_t_LXB_TAG_HEADER: lxb_tag_id_enum_t = 98;
pub const lxb_tag_id_enum_t_LXB_TAG_HGROUP: lxb_tag_id_enum_t = 99;
pub const lxb_tag_id_enum_t_LXB_TAG_HR: lxb_tag_id_enum_t = 100;
pub const lxb_tag_id_enum_t_LXB_TAG_HTML: lxb_tag_id_enum_t = 101;
pub const lxb_tag_id_enum_t_LXB_TAG_I: lxb_tag_id_enum_t = 102;
pub const lxb_tag_id_enum_t_LXB_TAG_IFRAME: lxb_tag_id_enum_t = 103;
pub const lxb_tag_id_enum_t_LXB_TAG_IMAGE: lxb_tag_id_enum_t = 104;
pub const lxb_tag_id_enum_t_LXB_TAG_IMG: lxb_tag_id_enum_t = 105;
pub const lxb_tag_id_enum_t_LXB_TAG_INPUT: lxb_tag_id_enum_t = 106;
pub const lxb_tag_id_enum_t_LXB_TAG_INS: lxb_tag_id_enum_t = 107;
pub const lxb_tag_id_enum_t_LXB_TAG_ISINDEX: lxb_tag_id_enum_t = 108;
pub const lxb_tag_id_enum_t_LXB_TAG_KBD: lxb_tag_id_enum_t = 109;
pub const lxb_tag_id_enum_t_LXB_TAG_KEYGEN: lxb_tag_id_enum_t = 110;
pub const lxb_tag_id_enum_t_LXB_TAG_LABEL: lxb_tag_id_enum_t = 111;
pub const lxb_tag_id_enum_t_LXB_TAG_LEGEND: lxb_tag_id_enum_t = 112;
pub const lxb_tag_id_enum_t_LXB_TAG_LI: lxb_tag_id_enum_t = 113;
pub const lxb_tag_id_enum_t_LXB_TAG_LINEARGRADIENT: lxb_tag_id_enum_t = 114;
pub const lxb_tag_id_enum_t_LXB_TAG_LINK: lxb_tag_id_enum_t = 115;
pub const lxb_tag_id_enum_t_LXB_TAG_LISTING: lxb_tag_id_enum_t = 116;
pub const lxb_tag_id_enum_t_LXB_TAG_MAIN: lxb_tag_id_enum_t = 117;
pub const lxb_tag_id_enum_t_LXB_TAG_MALIGNMARK: lxb_tag_id_enum_t = 118;
pub const lxb_tag_id_enum_t_LXB_TAG_MAP: lxb_tag_id_enum_t = 119;
pub const lxb_tag_id_enum_t_LXB_TAG_MARK: lxb_tag_id_enum_t = 120;
pub const lxb_tag_id_enum_t_LXB_TAG_MARQUEE: lxb_tag_id_enum_t = 121;
pub const lxb_tag_id_enum_t_LXB_TAG_MATH: lxb_tag_id_enum_t = 122;
pub const lxb_tag_id_enum_t_LXB_TAG_MENU: lxb_tag_id_enum_t = 123;
pub const lxb_tag_id_enum_t_LXB_TAG_META: lxb_tag_id_enum_t = 124;
pub const lxb_tag_id_enum_t_LXB_TAG_METER: lxb_tag_id_enum_t = 125;
pub const lxb_tag_id_enum_t_LXB_TAG_MFENCED: lxb_tag_id_enum_t = 126;
pub const lxb_tag_id_enum_t_LXB_TAG_MGLYPH: lxb_tag_id_enum_t = 127;
pub const lxb_tag_id_enum_t_LXB_TAG_MI: lxb_tag_id_enum_t = 128;
pub const lxb_tag_id_enum_t_LXB_TAG_MN: lxb_tag_id_enum_t = 129;
pub const lxb_tag_id_enum_t_LXB_TAG_MO: lxb_tag_id_enum_t = 130;
pub const lxb_tag_id_enum_t_LXB_TAG_MS: lxb_tag_id_enum_t = 131;
pub const lxb_tag_id_enum_t_LXB_TAG_MTEXT: lxb_tag_id_enum_t = 132;
pub const lxb_tag_id_enum_t_LXB_TAG_MULTICOL: lxb_tag_id_enum_t = 133;
pub const lxb_tag_id_enum_t_LXB_TAG_NAV: lxb_tag_id_enum_t = 134;
pub const lxb_tag_id_enum_t_LXB_TAG_NEXTID: lxb_tag_id_enum_t = 135;
pub const lxb_tag_id_enum_t_LXB_TAG_NOBR: lxb_tag_id_enum_t = 136;
pub const lxb_tag_id_enum_t_LXB_TAG_NOEMBED: lxb_tag_id_enum_t = 137;
pub const lxb_tag_id_enum_t_LXB_TAG_NOFRAMES: lxb_tag_id_enum_t = 138;
pub const lxb_tag_id_enum_t_LXB_TAG_NOSCRIPT: lxb_tag_id_enum_t = 139;
pub const lxb_tag_id_enum_t_LXB_TAG_OBJECT: lxb_tag_id_enum_t = 140;
pub const lxb_tag_id_enum_t_LXB_TAG_OL: lxb_tag_id_enum_t = 141;
pub const lxb_tag_id_enum_t_LXB_TAG_OPTGROUP: lxb_tag_id_enum_t = 142;
pub const lxb_tag_id_enum_t_LXB_TAG_OPTION: lxb_tag_id_enum_t = 143;
pub const lxb_tag_id_enum_t_LXB_TAG_OUTPUT: lxb_tag_id_enum_t = 144;
pub const lxb_tag_id_enum_t_LXB_TAG_P: lxb_tag_id_enum_t = 145;
pub const lxb_tag_id_enum_t_LXB_TAG_PARAM: lxb_tag_id_enum_t = 146;
pub const lxb_tag_id_enum_t_LXB_TAG_PATH: lxb_tag_id_enum_t = 147;
pub const lxb_tag_id_enum_t_LXB_TAG_PICTURE: lxb_tag_id_enum_t = 148;
pub const lxb_tag_id_enum_t_LXB_TAG_PLAINTEXT: lxb_tag_id_enum_t = 149;
pub const lxb_tag_id_enum_t_LXB_TAG_PRE: lxb_tag_id_enum_t = 150;
pub const lxb_tag_id_enum_t_LXB_TAG_PROGRESS: lxb_tag_id_enum_t = 151;
pub const lxb_tag_id_enum_t_LXB_TAG_Q: lxb_tag_id_enum_t = 152;
pub const lxb_tag_id_enum_t_LXB_TAG_RADIALGRADIENT: lxb_tag_id_enum_t = 153;
pub const lxb_tag_id_enum_t_LXB_TAG_RB: lxb_tag_id_enum_t = 154;
pub const lxb_tag_id_enum_t_LXB_TAG_RP: lxb_tag_id_enum_t = 155;
pub const lxb_tag_id_enum_t_LXB_TAG_RT: lxb_tag_id_enum_t = 156;
pub const lxb_tag_id_enum_t_LXB_TAG_RTC: lxb_tag_id_enum_t = 157;
pub const lxb_tag_id_enum_t_LXB_TAG_RUBY: lxb_tag_id_enum_t = 158;
pub const lxb_tag_id_enum_t_LXB_TAG_S: lxb_tag_id_enum_t = 159;
pub const lxb_tag_id_enum_t_LXB_TAG_SAMP: lxb_tag_id_enum_t = 160;
pub const lxb_tag_id_enum_t_LXB_TAG_SCRIPT: lxb_tag_id_enum_t = 161;
pub const lxb_tag_id_enum_t_LXB_TAG_SECTION: lxb_tag_id_enum_t = 162;
pub const lxb_tag_id_enum_t_LXB_TAG_SELECT: lxb_tag_id_enum_t = 163;
pub const lxb_tag_id_enum_t_LXB_TAG_SLOT: lxb_tag_id_enum_t = 164;
pub const lxb_tag_id_enum_t_LXB_TAG_SMALL: lxb_tag_id_enum_t = 165;
pub const lxb_tag_id_enum_t_LXB_TAG_SOURCE: lxb_tag_id_enum_t = 166;
pub const lxb_tag_id_enum_t_LXB_TAG_SPACER: lxb_tag_id_enum_t = 167;
pub const lxb_tag_id_enum_t_LXB_TAG_SPAN: lxb_tag_id_enum_t = 168;
pub const lxb_tag_id_enum_t_LXB_TAG_STRIKE: lxb_tag_id_enum_t = 169;
pub const lxb_tag_id_enum_t_LXB_TAG_STRONG: lxb_tag_id_enum_t = 170;
pub const lxb_tag_id_enum_t_LXB_TAG_STYLE: lxb_tag_id_enum_t = 171;
pub const lxb_tag_id_enum_t_LXB_TAG_SUB: lxb_tag_id_enum_t = 172;
pub const lxb_tag_id_enum_t_LXB_TAG_SUMMARY: lxb_tag_id_enum_t = 173;
pub const lxb_tag_id_enum_t_LXB_TAG_SUP: lxb_tag_id_enum_t = 174;
pub const lxb_tag_id_enum_t_LXB_TAG_SVG: lxb_tag_id_enum_t = 175;
pub const lxb_tag_id_enum_t_LXB_TAG_TABLE: lxb_tag_id_enum_t = 176;
pub const lxb_tag_id_enum_t_LXB_TAG_TBODY: lxb_tag_id_enum_t = 177;
pub const lxb_tag_id_enum_t_LXB_TAG_TD: lxb_tag_id_enum_t = 178;
pub const lxb_tag_id_enum_t_LXB_TAG_TEMPLATE: lxb_tag_id_enum_t = 179;
pub const lxb_tag_id_enum_t_LXB_TAG_TEXTAREA: lxb_tag_id_enum_t = 180;
pub const lxb_tag_id_enum_t_LXB_TAG_TEXTPATH: lxb_tag_id_enum_t = 181;
pub const lxb_tag_id_enum_t_LXB_TAG_TFOOT: lxb_tag_id_enum_t = 182;
pub const lxb_tag_id_enum_t_LXB_TAG_TH: lxb_tag_id_enum_t = 183;
pub const lxb_tag_id_enum_t_LXB_TAG_THEAD: lxb_tag_id_enum_t = 184;
pub const lxb_tag_id_enum_t_LXB_TAG_TIME: lxb_tag_id_enum_t = 185;
pub const lxb_tag_id_enum_t_LXB_TAG_TITLE: lxb_tag_id_enum_t = 186;
pub const lxb_tag_id_enum_t_LXB_TAG_TR: lxb_tag_id_enum_t = 187;
pub const lxb_tag_id_enum_t_LXB_TAG_TRACK: lxb_tag_id_enum_t = 188;
pub const lxb_tag_id_enum_t_LXB_TAG_TT: lxb_tag_id_enum_t = 189;
pub const lxb_tag_id_enum_t_LXB_TAG_U: lxb_tag_id_enum_t = 190;
pub const lxb_tag_id_enum_t_LXB_TAG_UL: lxb_tag_id_enum_t = 191;
pub const lxb_tag_id_enum_t_LXB_TAG_VAR: lxb_tag_id_enum_t = 192;
pub const lxb_tag_id_enum_t_LXB_TAG_VIDEO: lxb_tag_id_enum_t = 193;
pub const lxb_tag_id_enum_t_LXB_TAG_WBR: lxb_tag_id_enum_t = 194;
pub const lxb_tag_id_enum_t_LXB_TAG_XMP: lxb_tag_id_enum_t = 195;
pub const lxb_tag_id_enum_t_LXB_TAG__LAST_ENTRY: lxb_tag_id_enum_t = 196;
pub type lxb_tag_id_enum_t = cty::c_int;
pub type lxb_ns_id_t = usize;
pub type lxb_ns_prefix_id_t = usize;
pub const lxb_ns_id_enum_t_LXB_NS__UNDEF: lxb_ns_id_enum_t = 0;
pub const lxb_ns_id_enum_t_LXB_NS__ANY: lxb_ns_id_enum_t = 1;
pub const lxb_ns_id_enum_t_LXB_NS_HTML: lxb_ns_id_enum_t = 2;
pub const lxb_ns_id_enum_t_LXB_NS_MATH: lxb_ns_id_enum_t = 3;
pub const lxb_ns_id_enum_t_LXB_NS_SVG: lxb_ns_id_enum_t = 4;
pub const lxb_ns_id_enum_t_LXB_NS_XLINK: lxb_ns_id_enum_t = 5;
pub const lxb_ns_id_enum_t_LXB_NS_XML: lxb_ns_id_enum_t = 6;
pub const lxb_ns_id_enum_t_LXB_NS_XMLNS: lxb_ns_id_enum_t = 7;
pub const lxb_ns_id_enum_t_LXB_NS__LAST_ENTRY: lxb_ns_id_enum_t = 8;
pub type lxb_ns_id_enum_t = cty::c_int;
pub const lxb_dom_exception_code_t_LXB_DOM_INDEX_SIZE_ERR: lxb_dom_exception_code_t = 0;
pub const lxb_dom_exception_code_t_LXB_DOM_DOMSTRING_SIZE_ERR: lxb_dom_exception_code_t = 1;
pub const lxb_dom_exception_code_t_LXB_DOM_HIERARCHY_REQUEST_ERR: lxb_dom_exception_code_t = 2;
pub const lxb_dom_exception_code_t_LXB_DOM_WRONG_DOCUMENT_ERR: lxb_dom_exception_code_t = 3;
pub const lxb_dom_exception_code_t_LXB_DOM_INVALID_CHARACTER_ERR: lxb_dom_exception_code_t = 4;
pub const lxb_dom_exception_code_t_LXB_DOM_NO_DATA_ALLOWED_ERR: lxb_dom_exception_code_t = 5;
pub const lxb_dom_exception_code_t_LXB_DOM_NO_MODIFICATION_ALLOWED_ERR: lxb_dom_exception_code_t =
    6;
pub const lxb_dom_exception_code_t_LXB_DOM_NOT_FOUND_ERR: lxb_dom_exception_code_t = 7;
pub const lxb_dom_exception_code_t_LXB_DOM_NOT_SUPPORTED_ERR: lxb_dom_exception_code_t = 8;
pub const lxb_dom_exception_code_t_LXB_DOM_INUSE_ATTRIBUTE_ERR: lxb_dom_exception_code_t = 9;
pub const lxb_dom_exception_code_t_LXB_DOM_INVALID_STATE_ERR: lxb_dom_exception_code_t = 10;
pub const lxb_dom_exception_code_t_LXB_DOM_SYNTAX_ERR: lxb_dom_exception_code_t = 11;
pub const lxb_dom_exception_code_t_LXB_DOM_INVALID_MODIFICATION_ERR: lxb_dom_exception_code_t = 12;
pub const lxb_dom_exception_code_t_LXB_DOM_NAMESPACE_ERR: lxb_dom_exception_code_t = 13;
pub const lxb_dom_exception_code_t_LXB_DOM_INVALID_ACCESS_ERR: lxb_dom_exception_code_t = 14;
pub const lxb_dom_exception_code_t_LXB_DOM_VALIDATION_ERR: lxb_dom_exception_code_t = 15;
pub const lxb_dom_exception_code_t_LXB_DOM_TYPE_MISMATCH_ERR: lxb_dom_exception_code_t = 16;
pub const lxb_dom_exception_code_t_LXB_DOM_SECURITY_ERR: lxb_dom_exception_code_t = 17;
pub const lxb_dom_exception_code_t_LXB_DOM_NETWORK_ERR: lxb_dom_exception_code_t = 18;
pub const lxb_dom_exception_code_t_LXB_DOM_ABORT_ERR: lxb_dom_exception_code_t = 19;
pub const lxb_dom_exception_code_t_LXB_DOM_URL_MISMATCH_ERR: lxb_dom_exception_code_t = 20;
pub const lxb_dom_exception_code_t_LXB_DOM_QUOTA_EXCEEDED_ERR: lxb_dom_exception_code_t = 21;
pub const lxb_dom_exception_code_t_LXB_DOM_TIMEOUT_ERR: lxb_dom_exception_code_t = 22;
pub const lxb_dom_exception_code_t_LXB_DOM_INVALID_NODE_TYPE_ERR: lxb_dom_exception_code_t = 23;
pub const lxb_dom_exception_code_t_LXB_DOM_DATA_CLONE_ERR: lxb_dom_exception_code_t = 24;
pub type lxb_dom_exception_code_t = cty::c_int;
extern "C" {
    pub fn lxb_dom_exception_code_ref_set_noi(
        var: *mut lxb_dom_exception_code_t,
        code: lxb_dom_exception_code_t,
    ) -> *mut cty::c_void;
}
pub type lxb_dom_event_target_t = lxb_dom_event_target;
pub type lxb_dom_node_t = lxb_dom_node;
pub type lxb_dom_element_t = lxb_dom_element;
pub type lxb_dom_attr_t = lxb_dom_attr;
pub type lxb_dom_document_t = lxb_dom_document;
pub type lxb_dom_document_type_t = lxb_dom_document_type;
pub type lxb_dom_document_fragment_t = lxb_dom_document_fragment;
pub type lxb_dom_shadow_root_t = lxb_dom_shadow_root;
pub type lxb_dom_character_data_t = lxb_dom_character_data;
pub type lxb_dom_text_t = lxb_dom_text;
pub type lxb_dom_cdata_section_t = lxb_dom_cdata_section;
pub type lxb_dom_processing_instruction_t = lxb_dom_processing_instruction;
pub type lxb_dom_comment_t = lxb_dom_comment;
pub type lxb_dom_interface_t = cty::c_void;
pub type lxb_dom_interface_constructor_f =
    ::core::option::Option<unsafe extern "C" fn(document: *mut cty::c_void) -> *mut cty::c_void>;
pub type lxb_dom_interface_destructor_f =
    ::core::option::Option<unsafe extern "C" fn(intrfc: *mut cty::c_void) -> *mut cty::c_void>;
pub type lxb_dom_interface_create_f = ::core::option::Option<
    unsafe extern "C" fn(
        document: *mut lxb_dom_document_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
    ) -> *mut lxb_dom_interface_t,
>;
pub type lxb_dom_interface_clone_f = ::core::option::Option<
    unsafe extern "C" fn(
        document: *mut lxb_dom_document_t,
        intrfc: *const lxb_dom_interface_t,
    ) -> *mut lxb_dom_interface_t,
>;
pub type lxb_dom_interface_destroy_f = ::core::option::Option<
    unsafe extern "C" fn(intrfc: *mut lxb_dom_interface_t) -> *mut lxb_dom_interface_t,
>;
pub type lxb_dom_event_insert_f =
    ::core::option::Option<unsafe extern "C" fn(node: *mut lxb_dom_node_t) -> lxb_status_t>;
pub type lxb_dom_event_remove_f =
    ::core::option::Option<unsafe extern "C" fn(node: *mut lxb_dom_node_t) -> lxb_status_t>;
pub type lxb_dom_event_destroy_f =
    ::core::option::Option<unsafe extern "C" fn(node: *mut lxb_dom_node_t) -> lxb_status_t>;
pub type lxb_dom_event_set_value_f = ::core::option::Option<
    unsafe extern "C" fn(
        node: *mut lxb_dom_node_t,
        value: *const lxb_char_t,
        length: usize,
    ) -> lxb_status_t,
>;
extern "C" {
    pub fn lxb_dom_interface_create(
        document: *mut lxb_dom_document_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
    ) -> *mut lxb_dom_interface_t;
}
extern "C" {
    pub fn lxb_dom_interface_clone(
        document: *mut lxb_dom_document_t,
        intrfc: *const lxb_dom_interface_t,
    ) -> *mut lxb_dom_interface_t;
}
extern "C" {
    pub fn lxb_dom_interface_destroy(intrfc: *mut lxb_dom_interface_t) -> *mut lxb_dom_interface_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_array_t {
    pub list: *mut *mut cty::c_void,
    pub size: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_lexbor_array_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_array_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_array_t>(),
        24usize,
        concat!("Size of: ", stringify!(lexbor_array_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_array_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_array_t),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_array_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_array_t),
            "::",
            stringify!(length)
        )
    );
}
impl Default for lexbor_array_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_array_create() -> *mut lexbor_array_t;
}
extern "C" {
    pub fn lexbor_array_init(array: *mut lexbor_array_t, size: usize) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_array_clean(array: *mut lexbor_array_t);
}
extern "C" {
    pub fn lexbor_array_destroy(
        array: *mut lexbor_array_t,
        self_destroy: bool,
    ) -> *mut lexbor_array_t;
}
extern "C" {
    pub fn lexbor_array_expand(array: *mut lexbor_array_t, up_to: usize) -> *mut *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_push(array: *mut lexbor_array_t, value: *mut cty::c_void) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_array_pop(array: *mut lexbor_array_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_insert(
        array: *mut lexbor_array_t,
        idx: usize,
        value: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_array_set(
        array: *mut lexbor_array_t,
        idx: usize,
        value: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_array_delete(array: *mut lexbor_array_t, begin: usize, length: usize);
}
extern "C" {
    pub fn lexbor_array_get_noi(array: *mut lexbor_array_t, idx: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_length_noi(array: *mut lexbor_array_t) -> usize;
}
extern "C" {
    pub fn lexbor_array_size_noi(array: *mut lexbor_array_t) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_collection_t {
    pub array: lexbor_array_t,
    pub document: *mut lxb_dom_document_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_collection_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_collection_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_collection_t>(),
        32usize,
        concat!("Size of: ", stringify!(lxb_dom_collection_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_collection_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_collection_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_collection_t),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).document) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_collection_t),
            "::",
            stringify!(document)
        )
    );
}
impl Default for lxb_dom_collection_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_collection_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_collection_t;
}
extern "C" {
    pub fn lxb_dom_collection_init(
        col: *mut lxb_dom_collection_t,
        start_list_size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_collection_destroy(
        col: *mut lxb_dom_collection_t,
        self_destroy: bool,
    ) -> *mut lxb_dom_collection_t;
}
extern "C" {
    pub fn lxb_dom_collection_make_noi(
        document: *mut lxb_dom_document_t,
        start_list_size: usize,
    ) -> *mut lxb_dom_collection_t;
}
extern "C" {
    pub fn lxb_dom_collection_clean_noi(col: *mut lxb_dom_collection_t);
}
extern "C" {
    pub fn lxb_dom_collection_append_noi(
        col: *mut lxb_dom_collection_t,
        value: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_collection_element_noi(
        col: *mut lxb_dom_collection_t,
        idx: usize,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_collection_node_noi(
        col: *mut lxb_dom_collection_t,
        idx: usize,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_collection_length_noi(col: *mut lxb_dom_collection_t) -> usize;
}
pub type lexbor_mem_chunk_t = lexbor_mem_chunk;
pub type lexbor_mem_t = lexbor_mem;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_mem_chunk {
    pub data: *mut u8,
    pub length: usize,
    pub size: usize,
    pub next: *mut lexbor_mem_chunk_t,
    pub prev: *mut lexbor_mem_chunk_t,
}
#[test]
fn bindgen_test_layout_lexbor_mem_chunk() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_mem_chunk> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_mem_chunk>(),
        40usize,
        concat!("Size of: ", stringify!(lexbor_mem_chunk))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_mem_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_mem_chunk))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem_chunk),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem_chunk),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem_chunk),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem_chunk),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem_chunk),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for lexbor_mem_chunk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_mem {
    pub chunk: *mut lexbor_mem_chunk_t,
    pub chunk_first: *mut lexbor_mem_chunk_t,
    pub chunk_min_size: usize,
    pub chunk_length: usize,
}
#[test]
fn bindgen_test_layout_lexbor_mem() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_mem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_mem>(),
        32usize,
        concat!("Size of: ", stringify!(lexbor_mem))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_mem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem),
            "::",
            stringify!(chunk_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_min_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem),
            "::",
            stringify!(chunk_min_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mem),
            "::",
            stringify!(chunk_length)
        )
    );
}
impl Default for lexbor_mem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_mem_create() -> *mut lexbor_mem_t;
}
extern "C" {
    pub fn lexbor_mem_init(mem: *mut lexbor_mem_t, min_chunk_size: usize) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_mem_clean(mem: *mut lexbor_mem_t);
}
extern "C" {
    pub fn lexbor_mem_destroy(mem: *mut lexbor_mem_t, destroy_self: bool) -> *mut lexbor_mem_t;
}
extern "C" {
    pub fn lexbor_mem_chunk_init(
        mem: *mut lexbor_mem_t,
        chunk: *mut lexbor_mem_chunk_t,
        length: usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn lexbor_mem_chunk_make(mem: *mut lexbor_mem_t, length: usize) -> *mut lexbor_mem_chunk_t;
}
extern "C" {
    pub fn lexbor_mem_chunk_destroy(
        mem: *mut lexbor_mem_t,
        chunk: *mut lexbor_mem_chunk_t,
        self_destroy: bool,
    ) -> *mut lexbor_mem_chunk_t;
}
extern "C" {
    pub fn lexbor_mem_alloc(mem: *mut lexbor_mem_t, length: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_mem_calloc(mem: *mut lexbor_mem_t, length: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_mem_current_length_noi(mem: *mut lexbor_mem_t) -> usize;
}
extern "C" {
    pub fn lexbor_mem_current_size_noi(mem: *mut lexbor_mem_t) -> usize;
}
extern "C" {
    pub fn lexbor_mem_chunk_length_noi(mem: *mut lexbor_mem_t) -> usize;
}
extern "C" {
    pub fn lexbor_mem_align_noi(size: usize) -> usize;
}
extern "C" {
    pub fn lexbor_mem_align_floor_noi(size: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_dobject_t {
    pub mem: *mut lexbor_mem_t,
    pub cache: *mut lexbor_array_t,
    pub allocated: usize,
    pub struct_size: usize,
}
#[test]
fn bindgen_test_layout_lexbor_dobject_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_dobject_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_dobject_t>(),
        32usize,
        concat!("Size of: ", stringify!(lexbor_dobject_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_dobject_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_dobject_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_dobject_t),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_dobject_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_dobject_t),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_dobject_t),
            "::",
            stringify!(struct_size)
        )
    );
}
impl Default for lexbor_dobject_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_dobject_create() -> *mut lexbor_dobject_t;
}
extern "C" {
    pub fn lexbor_dobject_init(
        dobject: *mut lexbor_dobject_t,
        chunk_size: usize,
        struct_size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_dobject_clean(dobject: *mut lexbor_dobject_t);
}
extern "C" {
    pub fn lexbor_dobject_destroy(
        dobject: *mut lexbor_dobject_t,
        destroy_self: bool,
    ) -> *mut lexbor_dobject_t;
}
extern "C" {
    pub fn lexbor_dobject_init_list_entries(dobject: *mut lexbor_dobject_t, pos: usize) -> *mut u8;
}
extern "C" {
    pub fn lexbor_dobject_alloc(dobject: *mut lexbor_dobject_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_dobject_calloc(dobject: *mut lexbor_dobject_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_dobject_free(
        dobject: *mut lexbor_dobject_t,
        data: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_dobject_by_absolute_position(
        dobject: *mut lexbor_dobject_t,
        pos: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_dobject_allocated_noi(dobject: *mut lexbor_dobject_t) -> usize;
}
extern "C" {
    pub fn lexbor_dobject_cache_length_noi(dobject: *mut lexbor_dobject_t) -> usize;
}
pub type lexbor_bst_entry_t = lexbor_bst_entry;
pub type lexbor_bst_t = lexbor_bst;
pub type lexbor_bst_entry_f = ::core::option::Option<
    unsafe extern "C" fn(
        bst: *mut lexbor_bst_t,
        entry: *mut lexbor_bst_entry_t,
        ctx: *mut cty::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_bst_entry {
    pub value: *mut cty::c_void,
    pub right: *mut lexbor_bst_entry_t,
    pub left: *mut lexbor_bst_entry_t,
    pub next: *mut lexbor_bst_entry_t,
    pub parent: *mut lexbor_bst_entry_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_lexbor_bst_entry() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_bst_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_bst_entry>(),
        48usize,
        concat!("Size of: ", stringify!(lexbor_bst_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_bst_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_bst_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst_entry),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst_entry),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst_entry),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst_entry),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst_entry),
            "::",
            stringify!(size)
        )
    );
}
impl Default for lexbor_bst_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_bst {
    pub dobject: *mut lexbor_dobject_t,
    pub root: *mut lexbor_bst_entry_t,
    pub tree_length: usize,
}
#[test]
fn bindgen_test_layout_lexbor_bst() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_bst> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_bst>(),
        24usize,
        concat!("Size of: ", stringify!(lexbor_bst))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_bst>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_bst))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dobject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst),
            "::",
            stringify!(dobject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tree_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_bst),
            "::",
            stringify!(tree_length)
        )
    );
}
impl Default for lexbor_bst {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_bst_create() -> *mut lexbor_bst_t;
}
extern "C" {
    pub fn lexbor_bst_init(bst: *mut lexbor_bst_t, size: usize) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_bst_clean(bst: *mut lexbor_bst_t);
}
extern "C" {
    pub fn lexbor_bst_destroy(bst: *mut lexbor_bst_t, self_destroy: bool) -> *mut lexbor_bst_t;
}
extern "C" {
    pub fn lexbor_bst_entry_make(bst: *mut lexbor_bst_t, size: usize) -> *mut lexbor_bst_entry_t;
}
extern "C" {
    pub fn lexbor_bst_insert(
        bst: *mut lexbor_bst_t,
        scope: *mut *mut lexbor_bst_entry_t,
        size: usize,
        value: *mut cty::c_void,
    ) -> *mut lexbor_bst_entry_t;
}
extern "C" {
    pub fn lexbor_bst_insert_not_exists(
        bst: *mut lexbor_bst_t,
        scope: *mut *mut lexbor_bst_entry_t,
        size: usize,
    ) -> *mut lexbor_bst_entry_t;
}
extern "C" {
    pub fn lexbor_bst_search(
        bst: *mut lexbor_bst_t,
        scope: *mut lexbor_bst_entry_t,
        size: usize,
    ) -> *mut lexbor_bst_entry_t;
}
extern "C" {
    pub fn lexbor_bst_search_close(
        bst: *mut lexbor_bst_t,
        scope: *mut lexbor_bst_entry_t,
        size: usize,
    ) -> *mut lexbor_bst_entry_t;
}
extern "C" {
    pub fn lexbor_bst_remove(
        bst: *mut lexbor_bst_t,
        root: *mut *mut lexbor_bst_entry_t,
        size: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_bst_remove_close(
        bst: *mut lexbor_bst_t,
        root: *mut *mut lexbor_bst_entry_t,
        size: usize,
        found_size: *mut usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_bst_remove_by_pointer(
        bst: *mut lexbor_bst_t,
        entry: *mut lexbor_bst_entry_t,
        root: *mut *mut lexbor_bst_entry_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_bst_serialize(
        bst: *mut lexbor_bst_t,
        callback: lexbor_callback_f,
        ctx: *mut cty::c_void,
    );
}
extern "C" {
    pub fn lexbor_bst_serialize_entry(
        entry: *mut lexbor_bst_entry_t,
        callback: lexbor_callback_f,
        ctx: *mut cty::c_void,
        tabs: usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_mraw_t {
    pub mem: *mut lexbor_mem_t,
    pub cache: *mut lexbor_bst_t,
    pub ref_count: usize,
}
#[test]
fn bindgen_test_layout_lexbor_mraw_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_mraw_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_mraw_t>(),
        24usize,
        concat!("Size of: ", stringify!(lexbor_mraw_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_mraw_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_mraw_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mraw_t),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mraw_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_mraw_t),
            "::",
            stringify!(ref_count)
        )
    );
}
impl Default for lexbor_mraw_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_mraw_create() -> *mut lexbor_mraw_t;
}
extern "C" {
    pub fn lexbor_mraw_init(mraw: *mut lexbor_mraw_t, chunk_size: usize) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_mraw_clean(mraw: *mut lexbor_mraw_t);
}
extern "C" {
    pub fn lexbor_mraw_destroy(mraw: *mut lexbor_mraw_t, destroy_self: bool) -> *mut lexbor_mraw_t;
}
extern "C" {
    pub fn lexbor_mraw_alloc(mraw: *mut lexbor_mraw_t, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_mraw_calloc(mraw: *mut lexbor_mraw_t, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_mraw_realloc(
        mraw: *mut lexbor_mraw_t,
        data: *mut cty::c_void,
        new_size: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_mraw_free(mraw: *mut lexbor_mraw_t, data: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_mraw_data_size_noi(data: *mut cty::c_void) -> usize;
}
extern "C" {
    pub fn lexbor_mraw_data_size_set_noi(data: *mut cty::c_void, size: usize);
}
extern "C" {
    pub fn lexbor_mraw_dup_noi(
        mraw: *mut lexbor_mraw_t,
        src: *const cty::c_void,
        size: usize,
    ) -> *mut cty::c_void;
}
pub type lexbor_hash_search_t = lexbor_hash_search;
pub type lexbor_hash_insert_t = lexbor_hash_insert;
extern "C" {
    pub static mut lexbor_hash_insert_raw: *const lexbor_hash_insert_t;
}
extern "C" {
    pub static mut lexbor_hash_insert_lower: *const lexbor_hash_insert_t;
}
extern "C" {
    pub static mut lexbor_hash_insert_upper: *const lexbor_hash_insert_t;
}
extern "C" {
    pub static mut lexbor_hash_search_raw: *const lexbor_hash_search_t;
}
extern "C" {
    pub static mut lexbor_hash_search_lower: *const lexbor_hash_search_t;
}
extern "C" {
    pub static mut lexbor_hash_search_upper: *const lexbor_hash_search_t;
}
pub type lexbor_hash_t = lexbor_hash;
pub type lexbor_hash_entry_t = lexbor_hash_entry;
pub type lexbor_hash_id_f =
    ::core::option::Option<unsafe extern "C" fn(key: *const lxb_char_t, size: usize) -> u32>;
pub type lexbor_hash_copy_f = ::core::option::Option<
    unsafe extern "C" fn(
        hash: *mut lexbor_hash_t,
        entry: *mut lexbor_hash_entry_t,
        key: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t,
>;
pub type lexbor_hash_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(first: *const lxb_char_t, second: *const lxb_char_t, size: usize) -> bool,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lexbor_hash_entry {
    pub u: lexbor_hash_entry__bindgen_ty_1,
    pub length: usize,
    pub next: *mut lexbor_hash_entry_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lexbor_hash_entry__bindgen_ty_1 {
    pub long_str: *mut lxb_char_t,
    pub short_str: [lxb_char_t; 17usize],
}
#[test]
fn bindgen_test_layout_lexbor_hash_entry__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_hash_entry__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_hash_entry__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(lexbor_hash_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_hash_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_hash_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).long_str) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_entry__bindgen_ty_1),
            "::",
            stringify!(long_str)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).short_str) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_entry__bindgen_ty_1),
            "::",
            stringify!(short_str)
        )
    );
}
impl Default for lexbor_hash_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lexbor_hash_entry() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_hash_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_hash_entry>(),
        40usize,
        concat!("Size of: ", stringify!(lexbor_hash_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_hash_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_hash_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_entry),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_entry),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_entry),
            "::",
            stringify!(next)
        )
    );
}
impl Default for lexbor_hash_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_hash {
    pub entries: *mut lexbor_dobject_t,
    pub mraw: *mut lexbor_mraw_t,
    pub table: *mut *mut lexbor_hash_entry_t,
    pub table_size: usize,
    pub struct_size: usize,
}
#[test]
fn bindgen_test_layout_lexbor_hash() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_hash> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_hash>(),
        40usize,
        concat!("Size of: ", stringify!(lexbor_hash))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_hash))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mraw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash),
            "::",
            stringify!(mraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash),
            "::",
            stringify!(table_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash),
            "::",
            stringify!(struct_size)
        )
    );
}
impl Default for lexbor_hash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lexbor_hash_insert {
    pub hash: lexbor_hash_id_f,
    pub cmp: lexbor_hash_cmp_f,
    pub copy: lexbor_hash_copy_f,
}
#[test]
fn bindgen_test_layout_lexbor_hash_insert() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_hash_insert> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_hash_insert>(),
        24usize,
        concat!("Size of: ", stringify!(lexbor_hash_insert))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_hash_insert>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_hash_insert))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_insert),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_insert),
            "::",
            stringify!(cmp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_insert),
            "::",
            stringify!(copy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lexbor_hash_search {
    pub hash: lexbor_hash_id_f,
    pub cmp: lexbor_hash_cmp_f,
}
#[test]
fn bindgen_test_layout_lexbor_hash_search() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_hash_search> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_hash_search>(),
        16usize,
        concat!("Size of: ", stringify!(lexbor_hash_search))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_hash_search>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_hash_search))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_search),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_hash_search),
            "::",
            stringify!(cmp)
        )
    );
}
extern "C" {
    pub fn lexbor_hash_create() -> *mut lexbor_hash_t;
}
extern "C" {
    pub fn lexbor_hash_init(
        hash: *mut lexbor_hash_t,
        table_size: usize,
        struct_size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_hash_clean(hash: *mut lexbor_hash_t);
}
extern "C" {
    pub fn lexbor_hash_destroy(hash: *mut lexbor_hash_t, destroy_obj: bool) -> *mut lexbor_hash_t;
}
extern "C" {
    pub fn lexbor_hash_insert(
        hash: *mut lexbor_hash_t,
        insert: *const lexbor_hash_insert_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_hash_insert_by_entry(
        hash: *mut lexbor_hash_t,
        entry: *mut lexbor_hash_entry_t,
        search: *const lexbor_hash_search_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_hash_remove(
        hash: *mut lexbor_hash_t,
        search: *const lexbor_hash_search_t,
        key: *const lxb_char_t,
        length: usize,
    );
}
extern "C" {
    pub fn lexbor_hash_search(
        hash: *mut lexbor_hash_t,
        search: *const lexbor_hash_search_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_hash_remove_by_hash_id(
        hash: *mut lexbor_hash_t,
        hash_id: u32,
        key: *const lxb_char_t,
        length: usize,
        cmp_func: lexbor_hash_cmp_f,
    );
}
extern "C" {
    pub fn lexbor_hash_search_by_hash_id(
        hash: *mut lexbor_hash_t,
        hash_id: u32,
        key: *const lxb_char_t,
        length: usize,
        cmp_func: lexbor_hash_cmp_f,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_hash_make_id(key: *const lxb_char_t, length: usize) -> u32;
}
extern "C" {
    pub fn lexbor_hash_make_id_lower(key: *const lxb_char_t, length: usize) -> u32;
}
extern "C" {
    pub fn lexbor_hash_make_id_upper(key: *const lxb_char_t, length: usize) -> u32;
}
extern "C" {
    pub fn lexbor_hash_copy(
        hash: *mut lexbor_hash_t,
        entry: *mut lexbor_hash_entry_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_hash_copy_lower(
        hash: *mut lexbor_hash_t,
        entry: *mut lexbor_hash_entry_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_hash_copy_upper(
        hash: *mut lexbor_hash_t,
        entry: *mut lexbor_hash_entry_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_event_target {
    pub events: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_dom_event_target() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_event_target> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_event_target>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_dom_event_target))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_event_target>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_event_target))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_event_target),
            "::",
            stringify!(events)
        )
    );
}
impl Default for lxb_dom_event_target {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_event_target_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_event_target_t;
}
extern "C" {
    pub fn lxb_dom_event_target_destroy(
        event_target: *mut lxb_dom_event_target_t,
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_event_target_t;
}
pub type lxb_dom_node_simple_walker_f = ::core::option::Option<
    unsafe extern "C" fn(node: *mut lxb_dom_node_t, ctx: *mut cty::c_void) -> lexbor_action_t,
>;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_UNDEF: lxb_dom_node_type_t = 0;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_ELEMENT: lxb_dom_node_type_t = 1;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_ATTRIBUTE: lxb_dom_node_type_t = 2;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_TEXT: lxb_dom_node_type_t = 3;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_CDATA_SECTION: lxb_dom_node_type_t = 4;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_ENTITY_REFERENCE: lxb_dom_node_type_t = 5;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_ENTITY: lxb_dom_node_type_t = 6;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_PROCESSING_INSTRUCTION: lxb_dom_node_type_t = 7;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_COMMENT: lxb_dom_node_type_t = 8;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_DOCUMENT: lxb_dom_node_type_t = 9;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_DOCUMENT_TYPE: lxb_dom_node_type_t = 10;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_DOCUMENT_FRAGMENT: lxb_dom_node_type_t = 11;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_NOTATION: lxb_dom_node_type_t = 12;
pub const lxb_dom_node_type_t_LXB_DOM_NODE_TYPE_LAST_ENTRY: lxb_dom_node_type_t = 13;
pub type lxb_dom_node_type_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_node {
    pub event_target: lxb_dom_event_target_t,
    pub local_name: usize,
    pub prefix: usize,
    pub ns: usize,
    pub owner_document: *mut lxb_dom_document_t,
    pub next: *mut lxb_dom_node_t,
    pub prev: *mut lxb_dom_node_t,
    pub parent: *mut lxb_dom_node_t,
    pub first_child: *mut lxb_dom_node_t,
    pub last_child: *mut lxb_dom_node_t,
    pub user: *mut cty::c_void,
    pub type_: lxb_dom_node_type_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_node() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_node>(),
        96usize,
        concat!("Size of: ", stringify!(lxb_dom_node))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_node>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(event_target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(local_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner_document) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(owner_document)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_child) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(first_child)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_child) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(last_child)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_node),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for lxb_dom_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_node_interface_create(document: *mut lxb_dom_document_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_interface_clone(
        document: *mut lxb_dom_document_t,
        node: *const lxb_dom_node_t,
        is_attr: bool,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_interface_destroy(node: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_interface_copy(
        dst: *mut lxb_dom_node_t,
        src: *const lxb_dom_node_t,
        is_attr: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_destroy(node: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_destroy_deep(root: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_clone(node: *mut lxb_dom_node_t, deep: bool) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_name(node: *mut lxb_dom_node_t, len: *mut usize) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_node_insert_child_wo_events(to: *mut lxb_dom_node_t, node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_insert_child(to: *mut lxb_dom_node_t, node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_insert_before_wo_events(to: *mut lxb_dom_node_t, node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_insert_before(to: *mut lxb_dom_node_t, node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_insert_after_wo_events(to: *mut lxb_dom_node_t, node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_insert_after(to: *mut lxb_dom_node_t, node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_remove_wo_events(node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_remove(node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_dom_node_replace_all(
        parent: *mut lxb_dom_node_t,
        node: *mut lxb_dom_node_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_simple_walk(
        root: *mut lxb_dom_node_t,
        walker_cb: lxb_dom_node_simple_walker_f,
        ctx: *mut cty::c_void,
    );
}
extern "C" {
    pub fn lxb_dom_node_by_tag_name(
        root: *mut lxb_dom_node_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_by_class_name(
        root: *mut lxb_dom_node_t,
        collection: *mut lxb_dom_collection_t,
        class_name: *const lxb_char_t,
        len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_by_attr(
        root: *mut lxb_dom_node_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_by_attr_begin(
        root: *mut lxb_dom_node_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_by_attr_end(
        root: *mut lxb_dom_node_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_by_attr_contain(
        root: *mut lxb_dom_node_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_text_content(node: *mut lxb_dom_node_t, len: *mut usize)
        -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_node_text_content_set(
        node: *mut lxb_dom_node_t,
        content: *const lxb_char_t,
        len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_node_is_empty(root: *mut lxb_dom_node_t) -> bool;
}
extern "C" {
    pub fn lxb_dom_node_tag_id_noi(node: *mut lxb_dom_node_t) -> lxb_tag_id_t;
}
extern "C" {
    pub fn lxb_dom_node_next_noi(node: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_prev_noi(node: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_parent_noi(node: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_first_child_noi(node: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_node_last_child_noi(node: *mut lxb_dom_node_t) -> *mut lxb_dom_node_t;
}
pub const lxb_dom_document_cmode_t_LXB_DOM_DOCUMENT_CMODE_NO_QUIRKS: lxb_dom_document_cmode_t = 0;
pub const lxb_dom_document_cmode_t_LXB_DOM_DOCUMENT_CMODE_QUIRKS: lxb_dom_document_cmode_t = 1;
pub const lxb_dom_document_cmode_t_LXB_DOM_DOCUMENT_CMODE_LIMITED_QUIRKS: lxb_dom_document_cmode_t =
    2;
pub type lxb_dom_document_cmode_t = cty::c_int;
pub const lxb_dom_document_dtype_t_LXB_DOM_DOCUMENT_DTYPE_UNDEF: lxb_dom_document_dtype_t = 0;
pub const lxb_dom_document_dtype_t_LXB_DOM_DOCUMENT_DTYPE_HTML: lxb_dom_document_dtype_t = 1;
pub const lxb_dom_document_dtype_t_LXB_DOM_DOCUMENT_DTYPE_XML: lxb_dom_document_dtype_t = 2;
pub type lxb_dom_document_dtype_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_document {
    pub node: lxb_dom_node_t,
    pub compat_mode: lxb_dom_document_cmode_t,
    pub type_: lxb_dom_document_dtype_t,
    pub doctype: *mut lxb_dom_document_type_t,
    pub element: *mut lxb_dom_element_t,
    pub create_interface: lxb_dom_interface_create_f,
    pub clone_interface: lxb_dom_interface_clone_f,
    pub destroy_interface: lxb_dom_interface_destroy_f,
    pub ev_insert: lxb_dom_event_insert_f,
    pub ev_remove: lxb_dom_event_remove_f,
    pub ev_destroy: lxb_dom_event_destroy_f,
    pub ev_set_value: lxb_dom_event_set_value_f,
    pub mraw: *mut lexbor_mraw_t,
    pub text: *mut lexbor_mraw_t,
    pub tags: *mut lexbor_hash_t,
    pub attrs: *mut lexbor_hash_t,
    pub prefix: *mut lexbor_hash_t,
    pub ns: *mut lexbor_hash_t,
    pub parser: *mut cty::c_void,
    pub user: *mut cty::c_void,
    pub tags_inherited: bool,
    pub ns_inherited: bool,
    pub scripting: bool,
}
#[test]
fn bindgen_test_layout_lxb_dom_document() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_document> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_document>(),
        248usize,
        concat!("Size of: ", stringify!(lxb_dom_document))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_document>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_document))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compat_mode) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(compat_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).doctype) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(doctype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create_interface) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(create_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clone_interface) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(clone_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destroy_interface) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(destroy_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ev_insert) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(ev_insert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ev_remove) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(ev_remove)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ev_destroy) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(ev_destroy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ev_set_value) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(ev_set_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mraw) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(mraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tags) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parser) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tags_inherited) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(tags_inherited)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns_inherited) as usize - ptr as usize },
        241usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(ns_inherited)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scripting) as usize - ptr as usize },
        242usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document),
            "::",
            stringify!(scripting)
        )
    );
}
impl Default for lxb_dom_document {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_document_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_document_t;
}
extern "C" {
    pub fn lxb_dom_document_interface_clone(
        document: *mut lxb_dom_document_t,
        doc: *const lxb_dom_document_t,
    ) -> *mut lxb_dom_document_t;
}
extern "C" {
    pub fn lxb_dom_document_interface_destroy(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_document_t;
}
extern "C" {
    pub fn lxb_dom_document_create(owner: *mut lxb_dom_document_t) -> *mut lxb_dom_document_t;
}
extern "C" {
    pub fn lxb_dom_document_init(
        document: *mut lxb_dom_document_t,
        owner: *mut lxb_dom_document_t,
        create_interface: lxb_dom_interface_create_f,
        clone_interface: lxb_dom_interface_clone_f,
        destroy_interface: lxb_dom_interface_destroy_f,
        type_: lxb_dom_document_dtype_t,
        ns: cty::c_uint,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_document_clean(document: *mut lxb_dom_document_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_document_destroy(document: *mut lxb_dom_document_t) -> *mut lxb_dom_document_t;
}
extern "C" {
    pub fn lxb_dom_document_attach_doctype(
        document: *mut lxb_dom_document_t,
        doctype: *mut lxb_dom_document_type_t,
    );
}
extern "C" {
    pub fn lxb_dom_document_attach_element(
        document: *mut lxb_dom_document_t,
        element: *mut lxb_dom_element_t,
    );
}
extern "C" {
    pub fn lxb_dom_document_create_element(
        document: *mut lxb_dom_document_t,
        local_name: *const lxb_char_t,
        lname_len: usize,
        reserved_for_opt: *mut cty::c_void,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_document_destroy_element(
        element: *mut lxb_dom_element_t,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_document_create_document_fragment(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_document_fragment_t;
}
extern "C" {
    pub fn lxb_dom_document_create_text_node(
        document: *mut lxb_dom_document_t,
        data: *const lxb_char_t,
        len: usize,
    ) -> *mut lxb_dom_text_t;
}
extern "C" {
    pub fn lxb_dom_document_create_cdata_section(
        document: *mut lxb_dom_document_t,
        data: *const lxb_char_t,
        len: usize,
    ) -> *mut lxb_dom_cdata_section_t;
}
extern "C" {
    pub fn lxb_dom_document_create_processing_instruction(
        document: *mut lxb_dom_document_t,
        target: *const lxb_char_t,
        target_len: usize,
        data: *const lxb_char_t,
        data_len: usize,
    ) -> *mut lxb_dom_processing_instruction_t;
}
extern "C" {
    pub fn lxb_dom_document_create_comment(
        document: *mut lxb_dom_document_t,
        data: *const lxb_char_t,
        len: usize,
    ) -> *mut lxb_dom_comment_t;
}
extern "C" {
    pub fn lxb_dom_document_root(document: *mut lxb_dom_document_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_document_import_node(
        doc: *mut lxb_dom_document_t,
        node: *mut lxb_dom_node_t,
        deep: bool,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_dom_document_create_interface_noi(
        document: *mut lxb_dom_document_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
    ) -> *mut lxb_dom_interface_t;
}
extern "C" {
    pub fn lxb_dom_document_destroy_interface_noi(
        intrfc: *mut lxb_dom_interface_t,
    ) -> *mut lxb_dom_interface_t;
}
extern "C" {
    pub fn lxb_dom_document_create_struct_noi(
        document: *mut lxb_dom_document_t,
        struct_size: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_dom_document_destroy_struct_noi(
        document: *mut lxb_dom_document_t,
        structure: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_dom_document_create_text_noi(
        document: *mut lxb_dom_document_t,
        len: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_document_destroy_text_noi(
        document: *mut lxb_dom_document_t,
        text: *mut lxb_char_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_dom_document_element_noi(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_document_scripting_noi(document: *mut lxb_dom_document_t) -> bool;
}
extern "C" {
    pub fn lxb_dom_document_scripting_set_noi(document: *mut lxb_dom_document_t, scripting: bool);
}
extern "C" {
    pub fn lexbor_utils_power(t: usize, k: usize) -> usize;
}
extern "C" {
    pub fn lexbor_utils_hash_hash(key: *const lxb_char_t, key_size: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_str_t {
    pub data: *mut lxb_char_t,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_lexbor_str_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_str_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_str_t>(),
        16usize,
        concat!("Size of: ", stringify!(lexbor_str_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_str_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_str_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_str_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_str_t),
            "::",
            stringify!(length)
        )
    );
}
impl Default for lexbor_str_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_str_create() -> *mut lexbor_str_t;
}
extern "C" {
    pub fn lexbor_str_init(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        size: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_init_append(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_clean(str_: *mut lexbor_str_t);
}
extern "C" {
    pub fn lexbor_str_clean_all(str_: *mut lexbor_str_t);
}
extern "C" {
    pub fn lexbor_str_destroy(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        destroy_obj: bool,
    ) -> *mut lexbor_str_t;
}
extern "C" {
    pub fn lexbor_str_realloc(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        new_size: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_check_size(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        plus_len: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_append(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_append_before(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        buff: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_append_one(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        data: lxb_char_t,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_append_lowercase(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_append_with_rep_null_chars(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        buff: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_copy(
        dest: *mut lexbor_str_t,
        target: *const lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_stay_only_whitespace(target: *mut lexbor_str_t);
}
extern "C" {
    pub fn lexbor_str_strip_collapse_whitespace(target: *mut lexbor_str_t);
}
extern "C" {
    pub fn lexbor_str_crop_whitespace_from_begin(target: *mut lexbor_str_t) -> usize;
}
extern "C" {
    pub fn lexbor_str_whitespace_from_begin(target: *mut lexbor_str_t) -> usize;
}
extern "C" {
    pub fn lexbor_str_whitespace_from_end(target: *mut lexbor_str_t) -> usize;
}
extern "C" {
    pub fn lexbor_str_data_ncasecmp_first(
        first: *const lxb_char_t,
        sec: *const lxb_char_t,
        sec_size: usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_data_ncasecmp_end(
        first: *const lxb_char_t,
        sec: *const lxb_char_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_ncasecmp_contain(
        where_: *const lxb_char_t,
        where_size: usize,
        what: *const lxb_char_t,
        what_size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_ncasecmp(
        first: *const lxb_char_t,
        sec: *const lxb_char_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_nlocmp_right(
        first: *const lxb_char_t,
        sec: *const lxb_char_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_nupcmp_right(
        first: *const lxb_char_t,
        sec: *const lxb_char_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_casecmp(first: *const lxb_char_t, sec: *const lxb_char_t) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_ncmp_end(
        first: *const lxb_char_t,
        sec: *const lxb_char_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_ncmp_contain(
        where_: *const lxb_char_t,
        where_size: usize,
        what: *const lxb_char_t,
        what_size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_ncmp(
        first: *const lxb_char_t,
        sec: *const lxb_char_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_cmp(first: *const lxb_char_t, sec: *const lxb_char_t) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_cmp_ws(first: *const lxb_char_t, sec: *const lxb_char_t) -> bool;
}
extern "C" {
    pub fn lexbor_str_data_to_lowercase(to: *mut lxb_char_t, from: *const lxb_char_t, len: usize);
}
extern "C" {
    pub fn lexbor_str_data_to_uppercase(to: *mut lxb_char_t, from: *const lxb_char_t, len: usize);
}
extern "C" {
    pub fn lexbor_str_data_find_lowercase(data: *const lxb_char_t, len: usize)
        -> *const lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_data_find_uppercase(data: *const lxb_char_t, len: usize)
        -> *const lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_data_noi(str_: *mut lexbor_str_t) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lexbor_str_length_noi(str_: *mut lexbor_str_t) -> usize;
}
extern "C" {
    pub fn lexbor_str_size_noi(str_: *mut lexbor_str_t) -> usize;
}
extern "C" {
    pub fn lexbor_str_data_set_noi(str_: *mut lexbor_str_t, data: *mut lxb_char_t);
}
extern "C" {
    pub fn lexbor_str_length_set_noi(
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        length: usize,
    ) -> *mut lxb_char_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_shs_entry_t {
    pub key: *mut cty::c_char,
    pub value: *mut cty::c_void,
    pub key_len: usize,
    pub next: usize,
}
#[test]
fn bindgen_test_layout_lexbor_shs_entry_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_shs_entry_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_shs_entry_t>(),
        32usize,
        concat!("Size of: ", stringify!(lexbor_shs_entry_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_shs_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_shs_entry_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_shs_entry_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_shs_entry_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_shs_entry_t),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_shs_entry_t),
            "::",
            stringify!(next)
        )
    );
}
impl Default for lexbor_shs_entry_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_shs_hash_t {
    pub key: u32,
    pub value: *mut cty::c_void,
    pub next: usize,
}
#[test]
fn bindgen_test_layout_lexbor_shs_hash_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_shs_hash_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_shs_hash_t>(),
        24usize,
        concat!("Size of: ", stringify!(lexbor_shs_hash_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_shs_hash_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_shs_hash_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_shs_hash_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_shs_hash_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_shs_hash_t),
            "::",
            stringify!(next)
        )
    );
}
impl Default for lexbor_shs_hash_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_shs_entry_get_static(
        tree: *const lexbor_shs_entry_t,
        key: *const lxb_char_t,
        size: usize,
    ) -> *const lexbor_shs_entry_t;
}
extern "C" {
    pub fn lexbor_shs_entry_get_lower_static(
        root: *const lexbor_shs_entry_t,
        key: *const lxb_char_t,
        key_len: usize,
    ) -> *const lexbor_shs_entry_t;
}
extern "C" {
    pub fn lexbor_shs_entry_get_upper_static(
        root: *const lexbor_shs_entry_t,
        key: *const lxb_char_t,
        key_len: usize,
    ) -> *const lexbor_shs_entry_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_ns_data_t {
    pub entry: lexbor_hash_entry_t,
    pub ns_id: lxb_ns_id_t,
    pub ref_count: usize,
    pub read_only: bool,
}
#[test]
fn bindgen_test_layout_lxb_ns_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_ns_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_ns_data_t>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_ns_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_ns_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_ns_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_data_t),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_data_t),
            "::",
            stringify!(ns_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_data_t),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_only) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_data_t),
            "::",
            stringify!(read_only)
        )
    );
}
impl Default for lxb_ns_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_ns_prefix_data_t {
    pub entry: lexbor_hash_entry_t,
    pub prefix_id: lxb_ns_prefix_id_t,
    pub ref_count: usize,
    pub read_only: bool,
}
#[test]
fn bindgen_test_layout_lxb_ns_prefix_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_ns_prefix_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_ns_prefix_data_t>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_ns_prefix_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_ns_prefix_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_ns_prefix_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_prefix_data_t),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefix_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_prefix_data_t),
            "::",
            stringify!(prefix_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_prefix_data_t),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_only) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_ns_prefix_data_t),
            "::",
            stringify!(read_only)
        )
    );
}
impl Default for lxb_ns_prefix_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_ns_by_id(
        hash: *mut lexbor_hash_t,
        ns_id: lxb_ns_id_t,
        length: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_ns_data_by_id(hash: *mut lexbor_hash_t, ns_id: lxb_ns_id_t) -> *const lxb_ns_data_t;
}
extern "C" {
    pub fn lxb_ns_data_by_link(
        hash: *mut lexbor_hash_t,
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_ns_data_t;
}
extern "C" {
    pub fn lxb_ns_prefix_append(
        hash: *mut lexbor_hash_t,
        prefix: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_ns_prefix_data_t;
}
extern "C" {
    pub fn lxb_ns_prefix_data_by_id(
        hash: *mut lexbor_hash_t,
        prefix_id: lxb_ns_prefix_id_t,
    ) -> *const lxb_ns_prefix_data_t;
}
extern "C" {
    pub fn lxb_ns_prefix_data_by_name(
        hash: *mut lexbor_hash_t,
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_ns_prefix_data_t;
}
pub type lxb_dom_attr_id_t = usize;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR__UNDEF: lxb_dom_attr_id_enum_t = 0;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_ACTIVE: lxb_dom_attr_id_enum_t = 1;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_ALT: lxb_dom_attr_id_enum_t = 2;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_CHARSET: lxb_dom_attr_id_enum_t = 3;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_CHECKED: lxb_dom_attr_id_enum_t = 4;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_CLASS: lxb_dom_attr_id_enum_t = 5;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_COLOR: lxb_dom_attr_id_enum_t = 6;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_CONTENT: lxb_dom_attr_id_enum_t = 7;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_DIR: lxb_dom_attr_id_enum_t = 8;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_DISABLED: lxb_dom_attr_id_enum_t = 9;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_FACE: lxb_dom_attr_id_enum_t = 10;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_FOCUS: lxb_dom_attr_id_enum_t = 11;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_FOR: lxb_dom_attr_id_enum_t = 12;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_HEIGHT: lxb_dom_attr_id_enum_t = 13;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_HOVER: lxb_dom_attr_id_enum_t = 14;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_HREF: lxb_dom_attr_id_enum_t = 15;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_HTML: lxb_dom_attr_id_enum_t = 16;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_HTTP_EQUIV: lxb_dom_attr_id_enum_t = 17;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_ID: lxb_dom_attr_id_enum_t = 18;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_IS: lxb_dom_attr_id_enum_t = 19;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_MAXLENGTH: lxb_dom_attr_id_enum_t = 20;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_PLACEHOLDER: lxb_dom_attr_id_enum_t = 21;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_POOL: lxb_dom_attr_id_enum_t = 22;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_PUBLIC: lxb_dom_attr_id_enum_t = 23;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_READONLY: lxb_dom_attr_id_enum_t = 24;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_REQUIRED: lxb_dom_attr_id_enum_t = 25;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_SCHEME: lxb_dom_attr_id_enum_t = 26;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_SELECTED: lxb_dom_attr_id_enum_t = 27;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_SIZE: lxb_dom_attr_id_enum_t = 28;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_SLOT: lxb_dom_attr_id_enum_t = 29;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_SRC: lxb_dom_attr_id_enum_t = 30;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_STYLE: lxb_dom_attr_id_enum_t = 31;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_SYSTEM: lxb_dom_attr_id_enum_t = 32;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_TITLE: lxb_dom_attr_id_enum_t = 33;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_TYPE: lxb_dom_attr_id_enum_t = 34;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR_WIDTH: lxb_dom_attr_id_enum_t = 35;
pub const lxb_dom_attr_id_enum_t_LXB_DOM_ATTR__LAST_ENTRY: lxb_dom_attr_id_enum_t = 36;
pub type lxb_dom_attr_id_enum_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_dom_attr_data_t {
    pub entry: lexbor_hash_entry_t,
    pub attr_id: lxb_dom_attr_id_t,
    pub ref_count: usize,
    pub read_only: bool,
}
#[test]
fn bindgen_test_layout_lxb_dom_attr_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_attr_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_attr_data_t>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_dom_attr_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_attr_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_attr_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr_data_t),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr_data_t),
            "::",
            stringify!(attr_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr_data_t),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_only) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr_data_t),
            "::",
            stringify!(read_only)
        )
    );
}
impl Default for lxb_dom_attr_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_attr {
    pub node: lxb_dom_node_t,
    pub upper_name: lxb_dom_attr_id_t,
    pub qualified_name: lxb_dom_attr_id_t,
    pub value: *mut lexbor_str_t,
    pub owner: *mut lxb_dom_element_t,
    pub next: *mut lxb_dom_attr_t,
    pub prev: *mut lxb_dom_attr_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_attr() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_attr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_attr>(),
        144usize,
        concat!("Size of: ", stringify!(lxb_dom_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_attr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upper_name) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr),
            "::",
            stringify!(upper_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qualified_name) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr),
            "::",
            stringify!(qualified_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_attr),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for lxb_dom_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_attr_interface_create(document: *mut lxb_dom_document_t) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_attr_interface_clone(
        document: *mut lxb_dom_document_t,
        attr: *const lxb_dom_attr_t,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_attr_interface_destroy(attr: *mut lxb_dom_attr_t) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_attr_set_name(
        attr: *mut lxb_dom_attr_t,
        local_name: *const lxb_char_t,
        local_name_len: usize,
        to_lowercase: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_attr_set_value(
        attr: *mut lxb_dom_attr_t,
        value: *const lxb_char_t,
        value_len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_attr_set_value_wo_copy(
        attr: *mut lxb_dom_attr_t,
        value: *mut lxb_char_t,
        value_len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_attr_set_existing_value(
        attr: *mut lxb_dom_attr_t,
        value: *const lxb_char_t,
        value_len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_attr_clone_name_value(
        attr_from: *mut lxb_dom_attr_t,
        attr_to: *mut lxb_dom_attr_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_attr_compare(first: *mut lxb_dom_attr_t, second: *mut lxb_dom_attr_t) -> bool;
}
extern "C" {
    pub fn lxb_dom_attr_remove(attr: *mut lxb_dom_attr_t);
}
extern "C" {
    pub fn lxb_dom_attr_data_undef() -> *const lxb_dom_attr_data_t;
}
extern "C" {
    pub fn lxb_dom_attr_data_by_id(
        hash: *mut lexbor_hash_t,
        attr_id: lxb_dom_attr_id_t,
    ) -> *const lxb_dom_attr_data_t;
}
extern "C" {
    pub fn lxb_dom_attr_data_by_local_name(
        hash: *mut lexbor_hash_t,
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_dom_attr_data_t;
}
extern "C" {
    pub fn lxb_dom_attr_data_by_qualified_name(
        hash: *mut lexbor_hash_t,
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_dom_attr_data_t;
}
extern "C" {
    pub fn lxb_dom_attr_qualified_name(
        attr: *mut lxb_dom_attr_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_attr_local_name_noi(
        attr: *mut lxb_dom_attr_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_attr_value_noi(attr: *mut lxb_dom_attr_t, len: *mut usize) -> *const lxb_char_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_tag_data_t {
    pub entry: lexbor_hash_entry_t,
    pub tag_id: lxb_tag_id_t,
    pub ref_count: usize,
    pub read_only: bool,
}
#[test]
fn bindgen_test_layout_lxb_tag_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_tag_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_tag_data_t>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_tag_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_tag_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_tag_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_tag_data_t),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_tag_data_t),
            "::",
            stringify!(tag_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_tag_data_t),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_only) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_tag_data_t),
            "::",
            stringify!(read_only)
        )
    );
}
impl Default for lxb_tag_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_tag_data_by_id(
        hash: *mut lexbor_hash_t,
        tag_id: lxb_tag_id_t,
    ) -> *const lxb_tag_data_t;
}
extern "C" {
    pub fn lxb_tag_data_by_name(
        hash: *mut lexbor_hash_t,
        name: *const lxb_char_t,
        len: usize,
    ) -> *const lxb_tag_data_t;
}
extern "C" {
    pub fn lxb_tag_data_by_name_upper(
        hash: *mut lexbor_hash_t,
        name: *const lxb_char_t,
        len: usize,
    ) -> *const lxb_tag_data_t;
}
extern "C" {
    pub fn lxb_tag_name_by_id_noi(
        hash: *mut lexbor_hash_t,
        tag_id: lxb_tag_id_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_tag_name_upper_by_id_noi(
        hash: *mut lexbor_hash_t,
        tag_id: lxb_tag_id_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_tag_id_by_name_noi(
        hash: *mut lexbor_hash_t,
        name: *const lxb_char_t,
        len: usize,
    ) -> lxb_tag_id_t;
}
extern "C" {
    pub fn lxb_tag_mraw_noi(hash: *mut lexbor_hash_t) -> *mut lexbor_mraw_t;
}
pub const lxb_dom_element_custom_state_t_LXB_DOM_ELEMENT_CUSTOM_STATE_UNDEFINED:
    lxb_dom_element_custom_state_t = 0;
pub const lxb_dom_element_custom_state_t_LXB_DOM_ELEMENT_CUSTOM_STATE_FAILED:
    lxb_dom_element_custom_state_t = 1;
pub const lxb_dom_element_custom_state_t_LXB_DOM_ELEMENT_CUSTOM_STATE_UNCUSTOMIZED:
    lxb_dom_element_custom_state_t = 2;
pub const lxb_dom_element_custom_state_t_LXB_DOM_ELEMENT_CUSTOM_STATE_CUSTOM:
    lxb_dom_element_custom_state_t = 3;
pub type lxb_dom_element_custom_state_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_element {
    pub node: lxb_dom_node_t,
    pub upper_name: lxb_dom_attr_id_t,
    pub qualified_name: lxb_dom_attr_id_t,
    pub is_value: *mut lexbor_str_t,
    pub first_attr: *mut lxb_dom_attr_t,
    pub last_attr: *mut lxb_dom_attr_t,
    pub attr_id: *mut lxb_dom_attr_t,
    pub attr_class: *mut lxb_dom_attr_t,
    pub custom_state: lxb_dom_element_custom_state_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_element> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_element>(),
        160usize,
        concat!("Size of: ", stringify!(lxb_dom_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upper_name) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(upper_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qualified_name) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(qualified_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_value) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(is_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_attr) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(first_attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_attr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(last_attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr_id) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(attr_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr_class) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(attr_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_state) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_element),
            "::",
            stringify!(custom_state)
        )
    );
}
impl Default for lxb_dom_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_element_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_element_interface_clone(
        document: *mut lxb_dom_document_t,
        element: *const lxb_dom_element_t,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_element_interface_destroy(
        element: *mut lxb_dom_element_t,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_element_interface_copy(
        dst: *mut lxb_dom_element_t,
        src: *const lxb_dom_element_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_element_create(
        document: *mut lxb_dom_document_t,
        local_name: *const lxb_char_t,
        lname_len: usize,
        ns_name: *const lxb_char_t,
        ns_len: usize,
        prefix: *const lxb_char_t,
        prefix_len: usize,
        is: *const lxb_char_t,
        is_len: usize,
        sync_custom: bool,
    ) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_element_destroy(element: *mut lxb_dom_element_t) -> *mut lxb_dom_element_t;
}
extern "C" {
    pub fn lxb_dom_element_has_attributes(element: *mut lxb_dom_element_t) -> bool;
}
extern "C" {
    pub fn lxb_dom_element_set_attribute(
        element: *mut lxb_dom_element_t,
        qualified_name: *const lxb_char_t,
        qn_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_get_attribute(
        element: *mut lxb_dom_element_t,
        qualified_name: *const lxb_char_t,
        qn_len: usize,
        value_len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_remove_attribute(
        element: *mut lxb_dom_element_t,
        qualified_name: *const lxb_char_t,
        qn_len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_element_has_attribute(
        element: *mut lxb_dom_element_t,
        qualified_name: *const lxb_char_t,
        qn_len: usize,
    ) -> bool;
}
extern "C" {
    pub fn lxb_dom_element_attr_append(
        element: *mut lxb_dom_element_t,
        attr: *mut lxb_dom_attr_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_element_attr_remove(
        element: *mut lxb_dom_element_t,
        attr: *mut lxb_dom_attr_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_element_attr_by_name(
        element: *mut lxb_dom_element_t,
        qualified_name: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_attr_by_local_name_data(
        element: *mut lxb_dom_element_t,
        data: *const lxb_dom_attr_data_t,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_attr_by_id(
        element: *mut lxb_dom_element_t,
        attr_id: lxb_dom_attr_id_t,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_attr_by_data(
        element: *mut lxb_dom_element_t,
        data: *const lxb_dom_attr_data_t,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_compare(
        first: *mut lxb_dom_element_t,
        second: *mut lxb_dom_element_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_dom_element_attr_is_exist(
        element: *mut lxb_dom_element_t,
        qualified_name: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_is_set(
        element: *mut lxb_dom_element_t,
        is: *const lxb_char_t,
        is_len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_elements_by_tag_name(
        root: *mut lxb_dom_element_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_elements_by_class_name(
        root: *mut lxb_dom_element_t,
        collection: *mut lxb_dom_collection_t,
        class_name: *const lxb_char_t,
        len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_elements_by_attr(
        root: *mut lxb_dom_element_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_elements_by_attr_begin(
        root: *mut lxb_dom_element_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_elements_by_attr_end(
        root: *mut lxb_dom_element_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_elements_by_attr_contain(
        root: *mut lxb_dom_element_t,
        collection: *mut lxb_dom_collection_t,
        qualified_name: *const lxb_char_t,
        qname_len: usize,
        value: *const lxb_char_t,
        value_len: usize,
        case_insensitive: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_element_qualified_name(
        element: *mut lxb_dom_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_qualified_name_upper(
        element: *mut lxb_dom_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_local_name(
        element: *mut lxb_dom_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_prefix(
        element: *mut lxb_dom_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_tag_name(
        element: *mut lxb_dom_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_id_noi(
        element: *mut lxb_dom_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_class_noi(
        element: *mut lxb_dom_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_element_is_custom_noi(element: *mut lxb_dom_element_t) -> bool;
}
extern "C" {
    pub fn lxb_dom_element_custom_is_defined_noi(element: *mut lxb_dom_element_t) -> bool;
}
extern "C" {
    pub fn lxb_dom_element_first_attribute_noi(
        element: *mut lxb_dom_element_t,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_next_attribute_noi(attr: *mut lxb_dom_attr_t) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_prev_attribute_noi(attr: *mut lxb_dom_attr_t) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_last_attribute_noi(
        element: *mut lxb_dom_element_t,
    ) -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_id_attribute_noi(element: *mut lxb_dom_element_t)
        -> *mut lxb_dom_attr_t;
}
extern "C" {
    pub fn lxb_dom_element_class_attribute_noi(
        element: *mut lxb_dom_element_t,
    ) -> *mut lxb_dom_attr_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_document_fragment {
    pub node: lxb_dom_node_t,
    pub host: *mut lxb_dom_element_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_document_fragment() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_document_fragment> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_document_fragment>(),
        104usize,
        concat!("Size of: ", stringify!(lxb_dom_document_fragment))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_document_fragment>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_document_fragment))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document_fragment),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document_fragment),
            "::",
            stringify!(host)
        )
    );
}
impl Default for lxb_dom_document_fragment {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_document_fragment_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_document_fragment_t;
}
extern "C" {
    pub fn lxb_dom_document_fragment_interface_destroy(
        document_fragment: *mut lxb_dom_document_fragment_t,
    ) -> *mut lxb_dom_document_fragment_t;
}
pub const lxb_dom_shadow_root_mode_t_LXB_DOM_SHADOW_ROOT_MODE_OPEN: lxb_dom_shadow_root_mode_t = 0;
pub const lxb_dom_shadow_root_mode_t_LXB_DOM_SHADOW_ROOT_MODE_CLOSED: lxb_dom_shadow_root_mode_t =
    1;
pub type lxb_dom_shadow_root_mode_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_shadow_root {
    pub document_fragment: lxb_dom_document_fragment_t,
    pub mode: lxb_dom_shadow_root_mode_t,
    pub host: *mut lxb_dom_element_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_shadow_root() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_shadow_root> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_shadow_root>(),
        120usize,
        concat!("Size of: ", stringify!(lxb_dom_shadow_root))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_shadow_root>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_shadow_root))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).document_fragment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_shadow_root),
            "::",
            stringify!(document_fragment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_shadow_root),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_shadow_root),
            "::",
            stringify!(host)
        )
    );
}
impl Default for lxb_dom_shadow_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_shadow_root_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_shadow_root_t;
}
extern "C" {
    pub fn lxb_dom_shadow_root_interface_destroy(
        shadow_root: *mut lxb_dom_shadow_root_t,
    ) -> *mut lxb_dom_shadow_root_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_character_data {
    pub node: lxb_dom_node_t,
    pub data: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_character_data() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_character_data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_character_data>(),
        112usize,
        concat!("Size of: ", stringify!(lxb_dom_character_data))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_character_data>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_character_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_character_data),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_character_data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for lxb_dom_character_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_character_data_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_character_data_t;
}
extern "C" {
    pub fn lxb_dom_character_data_interface_clone(
        document: *mut lxb_dom_document_t,
        ch_data: *const lxb_dom_character_data_t,
    ) -> *mut lxb_dom_character_data_t;
}
extern "C" {
    pub fn lxb_dom_character_data_interface_destroy(
        character_data: *mut lxb_dom_character_data_t,
    ) -> *mut lxb_dom_character_data_t;
}
extern "C" {
    pub fn lxb_dom_character_data_interface_copy(
        dst: *mut lxb_dom_character_data_t,
        src: *const lxb_dom_character_data_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_character_data_replace(
        ch_data: *mut lxb_dom_character_data_t,
        data: *const lxb_char_t,
        len: usize,
        offset: usize,
        count: usize,
    ) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_text {
    pub char_data: lxb_dom_character_data_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_text() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_text> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_text>(),
        112usize,
        concat!("Size of: ", stringify!(lxb_dom_text))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_text>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_text))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).char_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_text),
            "::",
            stringify!(char_data)
        )
    );
}
impl Default for lxb_dom_text {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_text_interface_create(document: *mut lxb_dom_document_t) -> *mut lxb_dom_text_t;
}
extern "C" {
    pub fn lxb_dom_text_interface_clone(
        document: *mut lxb_dom_document_t,
        text: *const lxb_dom_text_t,
    ) -> *mut lxb_dom_text_t;
}
extern "C" {
    pub fn lxb_dom_text_interface_destroy(text: *mut lxb_dom_text_t) -> *mut lxb_dom_text_t;
}
extern "C" {
    pub fn lxb_dom_text_interface_copy(
        dst: *mut lxb_dom_text_t,
        src: *const lxb_dom_text_t,
    ) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_cdata_section {
    pub text: lxb_dom_text_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_cdata_section() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_cdata_section> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_cdata_section>(),
        112usize,
        concat!("Size of: ", stringify!(lxb_dom_cdata_section))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_cdata_section>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_cdata_section))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_cdata_section),
            "::",
            stringify!(text)
        )
    );
}
impl Default for lxb_dom_cdata_section {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_cdata_section_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_cdata_section_t;
}
extern "C" {
    pub fn lxb_dom_cdata_section_interface_clone(
        document: *mut lxb_dom_document_t,
        cdata: *const lxb_dom_cdata_section_t,
    ) -> *mut lxb_dom_cdata_section_t;
}
extern "C" {
    pub fn lxb_dom_cdata_section_interface_destroy(
        cdata_section: *mut lxb_dom_cdata_section_t,
    ) -> *mut lxb_dom_cdata_section_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_comment {
    pub char_data: lxb_dom_character_data_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_comment() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_comment> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_comment>(),
        112usize,
        concat!("Size of: ", stringify!(lxb_dom_comment))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_comment>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_comment))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).char_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_comment),
            "::",
            stringify!(char_data)
        )
    );
}
impl Default for lxb_dom_comment {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_comment_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_comment_t;
}
extern "C" {
    pub fn lxb_dom_comment_interface_clone(
        document: *mut lxb_dom_document_t,
        text: *const lxb_dom_comment_t,
    ) -> *mut lxb_dom_comment_t;
}
extern "C" {
    pub fn lxb_dom_comment_interface_destroy(
        comment: *mut lxb_dom_comment_t,
    ) -> *mut lxb_dom_comment_t;
}
extern "C" {
    pub fn lxb_dom_comment_interface_copy(
        dst: *mut lxb_dom_comment_t,
        src: *const lxb_dom_comment_t,
    ) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_document_type {
    pub node: lxb_dom_node_t,
    pub name: lxb_dom_attr_id_t,
    pub public_id: lexbor_str_t,
    pub system_id: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_document_type() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_document_type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_document_type>(),
        136usize,
        concat!("Size of: ", stringify!(lxb_dom_document_type))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_document_type>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_document_type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document_type),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).public_id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document_type),
            "::",
            stringify!(public_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).system_id) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_document_type),
            "::",
            stringify!(system_id)
        )
    );
}
impl Default for lxb_dom_document_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_document_type_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_document_type_t;
}
extern "C" {
    pub fn lxb_dom_document_type_interface_clone(
        document: *mut lxb_dom_document_t,
        dtype: *const lxb_dom_document_type_t,
    ) -> *mut lxb_dom_document_type_t;
}
extern "C" {
    pub fn lxb_dom_document_type_interface_destroy(
        document_type: *mut lxb_dom_document_type_t,
    ) -> *mut lxb_dom_document_type_t;
}
extern "C" {
    pub fn lxb_dom_document_type_name_noi(
        doc_type: *mut lxb_dom_document_type_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_document_type_public_id_noi(
        doc_type: *mut lxb_dom_document_type_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_dom_document_type_system_id_noi(
        doc_type: *mut lxb_dom_document_type_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_dom_processing_instruction {
    pub char_data: lxb_dom_character_data_t,
    pub target: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_dom_processing_instruction() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_dom_processing_instruction> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_dom_processing_instruction>(),
        128usize,
        concat!("Size of: ", stringify!(lxb_dom_processing_instruction))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_dom_processing_instruction>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_dom_processing_instruction))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).char_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_processing_instruction),
            "::",
            stringify!(char_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_dom_processing_instruction),
            "::",
            stringify!(target)
        )
    );
}
impl Default for lxb_dom_processing_instruction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_dom_processing_instruction_interface_create(
        document: *mut lxb_dom_document_t,
    ) -> *mut lxb_dom_processing_instruction_t;
}
extern "C" {
    pub fn lxb_dom_processing_instruction_interface_clone(
        document: *mut lxb_dom_document_t,
        processing_instruction: *const lxb_dom_processing_instruction_t,
    ) -> *mut lxb_dom_processing_instruction_t;
}
extern "C" {
    pub fn lxb_dom_processing_instruction_interface_destroy(
        processing_instruction: *mut lxb_dom_processing_instruction_t,
    ) -> *mut lxb_dom_processing_instruction_t;
}
extern "C" {
    pub fn lxb_dom_processing_instruction_copy(
        dst: *mut lxb_dom_processing_instruction_t,
        src: *const lxb_dom_processing_instruction_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_dom_processing_instruction_target_noi(
        pi: *mut lxb_dom_processing_instruction_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
pub type lxb_html_tokenizer_t = lxb_html_tokenizer;
pub type lxb_html_tokenizer_opt_t = cty::c_uint;
pub type lxb_html_tree_t = lxb_html_tree;
pub const lxb_html_status_t_LXB_HTML_STATUS_OK: lxb_html_status_t = 0;
pub type lxb_html_status_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_array_obj_t {
    pub list: *mut u8,
    pub size: usize,
    pub length: usize,
    pub struct_size: usize,
}
#[test]
fn bindgen_test_layout_lexbor_array_obj_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_array_obj_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_array_obj_t>(),
        32usize,
        concat!("Size of: ", stringify!(lexbor_array_obj_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_array_obj_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_array_obj_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_array_obj_t),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_array_obj_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_array_obj_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).struct_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_array_obj_t),
            "::",
            stringify!(struct_size)
        )
    );
}
impl Default for lexbor_array_obj_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_array_obj_create() -> *mut lexbor_array_obj_t;
}
extern "C" {
    pub fn lexbor_array_obj_init(
        array: *mut lexbor_array_obj_t,
        size: usize,
        struct_size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_array_obj_clean(array: *mut lexbor_array_obj_t);
}
extern "C" {
    pub fn lexbor_array_obj_destroy(
        array: *mut lexbor_array_obj_t,
        self_destroy: bool,
    ) -> *mut lexbor_array_obj_t;
}
extern "C" {
    pub fn lexbor_array_obj_expand(array: *mut lexbor_array_obj_t, up_to: usize) -> *mut u8;
}
extern "C" {
    pub fn lexbor_array_obj_push(array: *mut lexbor_array_obj_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_obj_push_wo_cls(array: *mut lexbor_array_obj_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_obj_push_n(
        array: *mut lexbor_array_obj_t,
        count: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_obj_pop(array: *mut lexbor_array_obj_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_obj_delete(array: *mut lexbor_array_obj_t, begin: usize, length: usize);
}
extern "C" {
    pub fn lexbor_array_obj_erase_noi(array: *mut lexbor_array_obj_t);
}
extern "C" {
    pub fn lexbor_array_obj_get_noi(array: *mut lexbor_array_obj_t, idx: usize)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_array_obj_length_noi(array: *mut lexbor_array_obj_t) -> usize;
}
extern "C" {
    pub fn lexbor_array_obj_size_noi(array: *mut lexbor_array_obj_t) -> usize;
}
extern "C" {
    pub fn lexbor_array_obj_struct_size_noi(array: *mut lexbor_array_obj_t) -> usize;
}
extern "C" {
    pub fn lexbor_array_obj_last_noi(array: *mut lexbor_array_obj_t) -> *mut cty::c_void;
}
pub type lxb_html_token_attr_t = lxb_html_token_attr;
pub type lxb_html_token_attr_type_t = cty::c_int;
pub const lxb_html_token_attr_type_LXB_HTML_TOKEN_ATTR_TYPE_UNDEF: lxb_html_token_attr_type = 0;
pub const lxb_html_token_attr_type_LXB_HTML_TOKEN_ATTR_TYPE_NAME_NULL: lxb_html_token_attr_type = 1;
pub const lxb_html_token_attr_type_LXB_HTML_TOKEN_ATTR_TYPE_VALUE_NULL: lxb_html_token_attr_type =
    2;
pub type lxb_html_token_attr_type = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_token_attr {
    pub name_begin: *const lxb_char_t,
    pub name_end: *const lxb_char_t,
    pub value_begin: *const lxb_char_t,
    pub value_end: *const lxb_char_t,
    pub name: *const lxb_dom_attr_data_t,
    pub value: *mut lxb_char_t,
    pub value_size: usize,
    pub next: *mut lxb_html_token_attr_t,
    pub prev: *mut lxb_html_token_attr_t,
    pub type_: lxb_html_token_attr_type_t,
}
#[test]
fn bindgen_test_layout_lxb_html_token_attr() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_token_attr> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_token_attr>(),
        80usize,
        concat!("Size of: ", stringify!(lxb_html_token_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_token_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_token_attr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name_begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(name_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(name_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_begin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(value_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(value_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(value_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_attr),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for lxb_html_token_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_token_attr_create(dobj: *mut lexbor_dobject_t) -> *mut lxb_html_token_attr_t;
}
extern "C" {
    pub fn lxb_html_token_attr_clean(attr: *mut lxb_html_token_attr_t);
}
extern "C" {
    pub fn lxb_html_token_attr_destroy(
        attr: *mut lxb_html_token_attr_t,
        dobj: *mut lexbor_dobject_t,
    ) -> *mut lxb_html_token_attr_t;
}
extern "C" {
    pub fn lxb_html_token_attr_name(
        attr: *mut lxb_html_token_attr_t,
        length: *mut usize,
    ) -> *const lxb_char_t;
}
pub type lxb_html_token_type_t = cty::c_int;
pub const lxb_html_token_type_LXB_HTML_TOKEN_TYPE_OPEN: lxb_html_token_type = 0;
pub const lxb_html_token_type_LXB_HTML_TOKEN_TYPE_CLOSE: lxb_html_token_type = 1;
pub const lxb_html_token_type_LXB_HTML_TOKEN_TYPE_CLOSE_SELF: lxb_html_token_type = 2;
pub const lxb_html_token_type_LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS: lxb_html_token_type = 4;
pub const lxb_html_token_type_LXB_HTML_TOKEN_TYPE_DONE: lxb_html_token_type = 8;
pub type lxb_html_token_type = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_token_t {
    pub begin: *const lxb_char_t,
    pub end: *const lxb_char_t,
    pub text_start: *const lxb_char_t,
    pub text_end: *const lxb_char_t,
    pub attr_first: *mut lxb_html_token_attr_t,
    pub attr_last: *mut lxb_html_token_attr_t,
    pub base_element: *mut cty::c_void,
    pub null_count: usize,
    pub tag_id: lxb_tag_id_t,
    pub type_: lxb_html_token_type_t,
}
#[test]
fn bindgen_test_layout_lxb_html_token_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_token_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_token_t>(),
        80usize,
        concat!("Size of: ", stringify!(lxb_html_token_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_token_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_token_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(text_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr_first) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(attr_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr_last) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(attr_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base_element) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(base_element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).null_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(null_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(tag_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_token_t),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for lxb_html_token_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_token_create(dobj: *mut lexbor_dobject_t) -> *mut lxb_html_token_t;
}
extern "C" {
    pub fn lxb_html_token_destroy(
        token: *mut lxb_html_token_t,
        dobj: *mut lexbor_dobject_t,
    ) -> *mut lxb_html_token_t;
}
extern "C" {
    pub fn lxb_html_token_attr_append(
        token: *mut lxb_html_token_t,
        dobj: *mut lexbor_dobject_t,
    ) -> *mut lxb_html_token_attr_t;
}
extern "C" {
    pub fn lxb_html_token_attr_remove(
        token: *mut lxb_html_token_t,
        attr: *mut lxb_html_token_attr_t,
    );
}
extern "C" {
    pub fn lxb_html_token_attr_delete(
        token: *mut lxb_html_token_t,
        attr: *mut lxb_html_token_attr_t,
        dobj: *mut lexbor_dobject_t,
    );
}
extern "C" {
    pub fn lxb_html_token_make_text(
        token: *mut lxb_html_token_t,
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_token_make_text_drop_null(
        token: *mut lxb_html_token_t,
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_token_make_text_replace_null(
        token: *mut lxb_html_token_t,
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_token_data_skip_ws_begin(token: *mut lxb_html_token_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_token_data_skip_one_newline_begin(token: *mut lxb_html_token_t)
        -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_token_data_split_ws_begin(
        token: *mut lxb_html_token_t,
        ws_token: *mut lxb_html_token_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_token_doctype_parse(
        token: *mut lxb_html_token_t,
        doc_type: *mut lxb_dom_document_type_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_token_find_attr(
        tkz: *mut lxb_html_tokenizer_t,
        token: *mut lxb_html_token_t,
        name: *const lxb_char_t,
        name_len: usize,
    ) -> *mut lxb_html_token_attr_t;
}
extern "C" {
    pub fn lxb_html_token_clean_noi(token: *mut lxb_html_token_t);
}
extern "C" {
    pub fn lxb_html_token_create_eof_noi(dobj: *mut lexbor_dobject_t) -> *mut lxb_html_token_t;
}
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNTO: lxb_html_tree_error_id_t = 0;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNCLTO: lxb_html_tree_error_id_t = 1;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_NUCH: lxb_html_tree_error_id_t = 2;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNCHTO: lxb_html_tree_error_id_t = 3;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNTOININMO: lxb_html_tree_error_id_t = 4;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_BADOTOININMO: lxb_html_tree_error_id_t = 5;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINBEHTMO: lxb_html_tree_error_id_t = 6;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNCLTOINBEHTMO: lxb_html_tree_error_id_t =
    7;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINBEHEMO: lxb_html_tree_error_id_t = 8;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNCLTOINBEHEMO: lxb_html_tree_error_id_t =
    9;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINHEMO: lxb_html_tree_error_id_t = 10;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_NOVOHTELSTTAWITRSO:
    lxb_html_tree_error_id_t = 11;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_HETOINHEMO: lxb_html_tree_error_id_t = 12;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNCLTOINHEMO: lxb_html_tree_error_id_t = 13;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_TECLTOWIOPINHEMO: lxb_html_tree_error_id_t =
    14;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_TEELISNOCUINHEMO: lxb_html_tree_error_id_t =
    15;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINHENOMO: lxb_html_tree_error_id_t = 16;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOAFHEMO: lxb_html_tree_error_id_t = 17;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_HETOAFHEMO: lxb_html_tree_error_id_t = 18;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINBOMO: lxb_html_tree_error_id_t = 19;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_BAENOPELISWR: lxb_html_tree_error_id_t = 20;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_OPELISWR: lxb_html_tree_error_id_t = 21;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNELINOPELST: lxb_html_tree_error_id_t = 22;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_MIELINOPELST: lxb_html_tree_error_id_t = 23;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_NOBOELINSC: lxb_html_tree_error_id_t = 24;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_MIELINSC: lxb_html_tree_error_id_t = 25;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNELINSC: lxb_html_tree_error_id_t = 26;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNELINACFOST: lxb_html_tree_error_id_t = 27;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_UNENOFFI: lxb_html_tree_error_id_t = 28;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_CHINTATE: lxb_html_tree_error_id_t = 29;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINTAMO: lxb_html_tree_error_id_t = 30;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINSEMO: lxb_html_tree_error_id_t = 31;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOAFBOMO: lxb_html_tree_error_id_t = 32;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOINFRMO: lxb_html_tree_error_id_t = 33;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOAFFRMO: lxb_html_tree_error_id_t = 34;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_DOTOFOCOMO: lxb_html_tree_error_id_t = 35;
pub const lxb_html_tree_error_id_t_LXB_HTML_RULES_ERROR_LAST_ENTRY: lxb_html_tree_error_id_t = 36;
pub type lxb_html_tree_error_id_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_tree_error_t {
    pub id: lxb_html_tree_error_id_t,
    pub begin: *const lxb_char_t,
    pub end: *const lxb_char_t,
}
#[test]
fn bindgen_test_layout_lxb_html_tree_error_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_tree_error_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_tree_error_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_html_tree_error_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_tree_error_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_tree_error_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree_error_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree_error_t),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree_error_t),
            "::",
            stringify!(end)
        )
    );
}
impl Default for lxb_html_tree_error_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_tree_error_add(
        parse_errors: *mut lexbor_array_obj_t,
        token: *mut lxb_html_token_t,
        id: lxb_html_tree_error_id_t,
    ) -> *mut lxb_html_tree_error_t;
}
extern "C" {
    pub fn lxb_html_node_is_void_noi(node: *mut lxb_dom_node_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_sbst_entry_static_t {
    pub key: lxb_char_t,
    pub value: *mut cty::c_void,
    pub value_len: usize,
    pub left: usize,
    pub right: usize,
    pub next: usize,
}
#[test]
fn bindgen_test_layout_lexbor_sbst_entry_static_t() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_sbst_entry_static_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_sbst_entry_static_t>(),
        48usize,
        concat!("Size of: ", stringify!(lexbor_sbst_entry_static_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_sbst_entry_static_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_sbst_entry_static_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_sbst_entry_static_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_sbst_entry_static_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_sbst_entry_static_t),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_sbst_entry_static_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_sbst_entry_static_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_sbst_entry_static_t),
            "::",
            stringify!(next)
        )
    );
}
impl Default for lexbor_sbst_entry_static_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_html_tokenizer_state_f = ::core::option::Option<
    unsafe extern "C" fn(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t,
>;
pub type lxb_html_tokenizer_token_f = ::core::option::Option<
    unsafe extern "C" fn(
        tkz: *mut lxb_html_tokenizer_t,
        token: *mut lxb_html_token_t,
        ctx: *mut cty::c_void,
    ) -> *mut lxb_html_token_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_tokenizer {
    pub state: lxb_html_tokenizer_state_f,
    pub state_return: lxb_html_tokenizer_state_f,
    pub callback_token_done: lxb_html_tokenizer_token_f,
    pub callback_token_ctx: *mut cty::c_void,
    pub tags: *mut lexbor_hash_t,
    pub attrs: *mut lexbor_hash_t,
    pub attrs_mraw: *mut lexbor_mraw_t,
    pub mraw: *mut lexbor_mraw_t,
    pub token: *mut lxb_html_token_t,
    pub dobj_token: *mut lexbor_dobject_t,
    pub dobj_token_attr: *mut lexbor_dobject_t,
    pub parse_errors: *mut lexbor_array_obj_t,
    pub tree: *mut lxb_html_tree_t,
    pub markup: *const lxb_char_t,
    pub temp: *const lxb_char_t,
    pub tmp_tag_id: lxb_tag_id_t,
    pub start: *mut lxb_char_t,
    pub pos: *mut lxb_char_t,
    pub end: *const lxb_char_t,
    pub begin: *const lxb_char_t,
    pub last: *const lxb_char_t,
    pub entity: *const lexbor_sbst_entry_static_t,
    pub entity_match: *const lexbor_sbst_entry_static_t,
    pub entity_start: usize,
    pub entity_end: usize,
    pub entity_length: u32,
    pub entity_number: u32,
    pub is_attribute: bool,
    pub opt: lxb_html_tokenizer_opt_t,
    pub status: lxb_status_t,
    pub is_eof: bool,
    pub base: *mut lxb_html_tokenizer_t,
    pub ref_count: usize,
}
#[test]
fn bindgen_test_layout_lxb_html_tokenizer() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_tokenizer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_tokenizer>(),
        240usize,
        concat!("Size of: ", stringify!(lxb_html_tokenizer))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_tokenizer>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_tokenizer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state_return) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(state_return)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_token_done) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(callback_token_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_token_ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(callback_token_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attrs_mraw) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(attrs_mraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mraw) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(mraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dobj_token) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(dobj_token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dobj_token_attr) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(dobj_token_attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tree) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).markup) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(markup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(temp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmp_tag_id) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(tmp_tag_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entity) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(entity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entity_match) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(entity_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entity_start) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(entity_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entity_end) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(entity_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entity_length) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(entity_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entity_number) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(entity_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_attribute) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(is_attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(opt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_eof) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(is_eof)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer),
            "::",
            stringify!(ref_count)
        )
    );
}
impl Default for lxb_html_tokenizer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_ABCLOFEMCO:
    lxb_html_tokenizer_error_id_t = 0;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_ABDOPUID:
    lxb_html_tokenizer_error_id_t = 1;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_ABDOSYID:
    lxb_html_tokenizer_error_id_t = 2;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_ABOFDIINNUCHRE:
    lxb_html_tokenizer_error_id_t = 3;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_CDINHTCO:
    lxb_html_tokenizer_error_id_t = 4;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_CHREOUUNRA:
    lxb_html_tokenizer_error_id_t = 5;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_COCHININST:
    lxb_html_tokenizer_error_id_t = 6;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_COCHRE:
    lxb_html_tokenizer_error_id_t = 7;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_ENTAWIAT:
    lxb_html_tokenizer_error_id_t = 8;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_DUAT:
    lxb_html_tokenizer_error_id_t = 9;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_ENTAWITRSO:
    lxb_html_tokenizer_error_id_t = 10;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_EOBETANA:
    lxb_html_tokenizer_error_id_t = 11;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_EOINCD:
    lxb_html_tokenizer_error_id_t = 12;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_EOINCO:
    lxb_html_tokenizer_error_id_t = 13;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_EOINDO:
    lxb_html_tokenizer_error_id_t = 14;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_EOINSCHTCOLITE:
    lxb_html_tokenizer_error_id_t = 15;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_EOINTA:
    lxb_html_tokenizer_error_id_t = 16;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_INCLCO:
    lxb_html_tokenizer_error_id_t = 17;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_INOPCO:
    lxb_html_tokenizer_error_id_t = 18;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_INCHSEAFDONA:
    lxb_html_tokenizer_error_id_t = 19;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_INFICHOFTANA:
    lxb_html_tokenizer_error_id_t = 20;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIATVA:
    lxb_html_tokenizer_error_id_t = 21;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIDONA:
    lxb_html_tokenizer_error_id_t = 22;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIDOPUID:
    lxb_html_tokenizer_error_id_t = 23;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIDOSYID:
    lxb_html_tokenizer_error_id_t = 24;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIENTANA:
    lxb_html_tokenizer_error_id_t = 25;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIQUBEDOPUID:
    lxb_html_tokenizer_error_id_t = 26;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIQUBEDOSYID:
    lxb_html_tokenizer_error_id_t = 27;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MISEAFCHRE:
    lxb_html_tokenizer_error_id_t = 28;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIWHAFDOPUKE:
    lxb_html_tokenizer_error_id_t = 29;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIWHAFDOSYKE:
    lxb_html_tokenizer_error_id_t = 30;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIWHBEDONA:
    lxb_html_tokenizer_error_id_t = 31;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIWHBEAT:
    lxb_html_tokenizer_error_id_t = 32;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_MIWHBEDOPUANSYID:
    lxb_html_tokenizer_error_id_t = 33;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_NECO:
    lxb_html_tokenizer_error_id_t = 34;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_NOCHRE:
    lxb_html_tokenizer_error_id_t = 35;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_NOININST:
    lxb_html_tokenizer_error_id_t = 36;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_NOVOHTELSTTAWITRSO:
    lxb_html_tokenizer_error_id_t = 37;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_NUCHRE:
    lxb_html_tokenizer_error_id_t = 38;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_SUCHRE:
    lxb_html_tokenizer_error_id_t = 39;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_SUININST:
    lxb_html_tokenizer_error_id_t = 40;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNCHAFDOSYID:
    lxb_html_tokenizer_error_id_t = 41;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNCHINATNA:
    lxb_html_tokenizer_error_id_t = 42;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNCHINUNATVA:
    lxb_html_tokenizer_error_id_t = 43;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNEQSIBEATNA:
    lxb_html_tokenizer_error_id_t = 44;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNNUCH:
    lxb_html_tokenizer_error_id_t = 45;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNQUMAINOFTANA:
    lxb_html_tokenizer_error_id_t = 46;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNSOINTA:
    lxb_html_tokenizer_error_id_t = 47;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_UNNACHRE:
    lxb_html_tokenizer_error_id_t = 48;
pub const lxb_html_tokenizer_error_id_t_LXB_HTML_TOKENIZER_ERROR_LAST_ENTRY:
    lxb_html_tokenizer_error_id_t = 49;
pub type lxb_html_tokenizer_error_id_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_tokenizer_error_t {
    pub pos: *const lxb_char_t,
    pub id: lxb_html_tokenizer_error_id_t,
}
#[test]
fn bindgen_test_layout_lxb_html_tokenizer_error_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_tokenizer_error_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_tokenizer_error_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_html_tokenizer_error_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_tokenizer_error_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_tokenizer_error_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer_error_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tokenizer_error_t),
            "::",
            stringify!(id)
        )
    );
}
impl Default for lxb_html_tokenizer_error_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_tokenizer_error_add(
        parse_errors: *mut lexbor_array_obj_t,
        pos: *const lxb_char_t,
        id: lxb_html_tokenizer_error_id_t,
    ) -> *mut lxb_html_tokenizer_error_t;
}
extern "C" {
    pub static mut lxb_html_tokenizer_eof: *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_create() -> *mut lxb_html_tokenizer_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_init(tkz: *mut lxb_html_tokenizer_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_inherit(
        tkz_to: *mut lxb_html_tokenizer_t,
        tkz_from: *mut lxb_html_tokenizer_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_ref(tkz: *mut lxb_html_tokenizer_t) -> *mut lxb_html_tokenizer_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_unref(tkz: *mut lxb_html_tokenizer_t) -> *mut lxb_html_tokenizer_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_clean(tkz: *mut lxb_html_tokenizer_t);
}
extern "C" {
    pub fn lxb_html_tokenizer_destroy(tkz: *mut lxb_html_tokenizer_t) -> *mut lxb_html_tokenizer_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_tags_make(
        tkz: *mut lxb_html_tokenizer_t,
        table_size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_tags_destroy(tkz: *mut lxb_html_tokenizer_t);
}
extern "C" {
    pub fn lxb_html_tokenizer_attrs_make(
        tkz: *mut lxb_html_tokenizer_t,
        table_size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_attrs_destroy(tkz: *mut lxb_html_tokenizer_t);
}
extern "C" {
    pub fn lxb_html_tokenizer_begin(tkz: *mut lxb_html_tokenizer_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_chunk(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_end(tkz: *mut lxb_html_tokenizer_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_change_incoming(
        tkz: *mut lxb_html_tokenizer_t,
        pos: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_current_namespace(tkz: *mut lxb_html_tokenizer_t) -> lxb_ns_id_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_set_state_by_tag(
        tkz: *mut lxb_html_tokenizer_t,
        scripting: bool,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
    );
}
extern "C" {
    pub fn lxb_html_tokenizer_status_set_noi(tkz: *mut lxb_html_tokenizer_t, status: lxb_status_t);
}
extern "C" {
    pub fn lxb_html_tokenizer_callback_token_done_set_noi(
        tkz: *mut lxb_html_tokenizer_t,
        call_func: lxb_html_tokenizer_token_f,
        ctx: *mut cty::c_void,
    );
}
extern "C" {
    pub fn lxb_html_tokenizer_callback_token_done_ctx_noi(
        tkz: *mut lxb_html_tokenizer_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_set_noi(
        tkz: *mut lxb_html_tokenizer_t,
        state: lxb_html_tokenizer_state_f,
    );
}
extern "C" {
    pub fn lxb_html_tokenizer_tmp_tag_id_set_noi(
        tkz: *mut lxb_html_tokenizer_t,
        tag_id: lxb_tag_id_t,
    );
}
extern "C" {
    pub fn lxb_html_tokenizer_tree_noi(tkz: *mut lxb_html_tokenizer_t) -> *mut lxb_html_tree_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_tree_set_noi(
        tkz: *mut lxb_html_tokenizer_t,
        tree: *mut lxb_html_tree_t,
    );
}
extern "C" {
    pub fn lxb_html_tokenizer_mraw_noi(tkz: *mut lxb_html_tokenizer_t) -> *mut lexbor_mraw_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_tags_noi(tkz: *mut lxb_html_tokenizer_t) -> *mut lexbor_hash_t;
}
pub type lexbor_avl_t = lexbor_avl;
pub type lexbor_avl_node_t = lexbor_avl_node;
pub type lexbor_avl_node_f = ::core::option::Option<
    unsafe extern "C" fn(
        avl: *mut lexbor_avl_t,
        root: *mut *mut lexbor_avl_node_t,
        node: *mut lexbor_avl_node_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_avl_node {
    pub type_: usize,
    pub height: cty::c_short,
    pub value: *mut cty::c_void,
    pub left: *mut lexbor_avl_node_t,
    pub right: *mut lexbor_avl_node_t,
    pub parent: *mut lexbor_avl_node_t,
}
#[test]
fn bindgen_test_layout_lexbor_avl_node() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_avl_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_avl_node>(),
        48usize,
        concat!("Size of: ", stringify!(lexbor_avl_node))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_avl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_avl_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl_node),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl_node),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl_node),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl_node),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl_node),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl_node),
            "::",
            stringify!(parent)
        )
    );
}
impl Default for lexbor_avl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lexbor_avl {
    pub nodes: *mut lexbor_dobject_t,
    pub last_right: *mut lexbor_avl_node_t,
}
#[test]
fn bindgen_test_layout_lexbor_avl() {
    const UNINIT: ::core::mem::MaybeUninit<lexbor_avl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lexbor_avl>(),
        16usize,
        concat!("Size of: ", stringify!(lexbor_avl))
    );
    assert_eq!(
        ::core::mem::align_of::<lexbor_avl>(),
        8usize,
        concat!("Alignment of ", stringify!(lexbor_avl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nodes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lexbor_avl),
            "::",
            stringify!(last_right)
        )
    );
}
impl Default for lexbor_avl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lexbor_avl_create() -> *mut lexbor_avl_t;
}
extern "C" {
    pub fn lexbor_avl_init(
        avl: *mut lexbor_avl_t,
        chunk_len: usize,
        struct_size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_avl_clean(avl: *mut lexbor_avl_t);
}
extern "C" {
    pub fn lexbor_avl_destroy(avl: *mut lexbor_avl_t, self_destroy: bool) -> *mut lexbor_avl_t;
}
extern "C" {
    pub fn lexbor_avl_node_make(
        avl: *mut lexbor_avl_t,
        type_: usize,
        value: *mut cty::c_void,
    ) -> *mut lexbor_avl_node_t;
}
extern "C" {
    pub fn lexbor_avl_node_clean(node: *mut lexbor_avl_node_t);
}
extern "C" {
    pub fn lexbor_avl_node_destroy(
        avl: *mut lexbor_avl_t,
        node: *mut lexbor_avl_node_t,
        self_destroy: bool,
    ) -> *mut lexbor_avl_node_t;
}
extern "C" {
    pub fn lexbor_avl_insert(
        avl: *mut lexbor_avl_t,
        scope: *mut *mut lexbor_avl_node_t,
        type_: usize,
        value: *mut cty::c_void,
    ) -> *mut lexbor_avl_node_t;
}
extern "C" {
    pub fn lexbor_avl_search(
        avl: *mut lexbor_avl_t,
        scope: *mut lexbor_avl_node_t,
        type_: usize,
    ) -> *mut lexbor_avl_node_t;
}
extern "C" {
    pub fn lexbor_avl_remove(
        avl: *mut lexbor_avl_t,
        scope: *mut *mut lexbor_avl_node_t,
        type_: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lexbor_avl_remove_by_node(
        avl: *mut lexbor_avl_t,
        root: *mut *mut lexbor_avl_node_t,
        node: *mut lexbor_avl_node_t,
    );
}
extern "C" {
    pub fn lexbor_avl_foreach(
        avl: *mut lexbor_avl_t,
        scope: *mut *mut lexbor_avl_node_t,
        cb: lexbor_avl_node_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_avl_foreach_recursion(
        avl: *mut lexbor_avl_t,
        scope: *mut lexbor_avl_node_t,
        callback: lexbor_avl_node_f,
        ctx: *mut cty::c_void,
    );
}
pub type lxb_html_document_t = lxb_html_document;
pub type lxb_html_anchor_element_t = lxb_html_anchor_element;
pub type lxb_html_area_element_t = lxb_html_area_element;
pub type lxb_html_audio_element_t = lxb_html_audio_element;
pub type lxb_html_br_element_t = lxb_html_br_element;
pub type lxb_html_base_element_t = lxb_html_base_element;
pub type lxb_html_body_element_t = lxb_html_body_element;
pub type lxb_html_button_element_t = lxb_html_button_element;
pub type lxb_html_canvas_element_t = lxb_html_canvas_element;
pub type lxb_html_d_list_element_t = lxb_html_d_list_element;
pub type lxb_html_data_element_t = lxb_html_data_element;
pub type lxb_html_data_list_element_t = lxb_html_data_list_element;
pub type lxb_html_details_element_t = lxb_html_details_element;
pub type lxb_html_dialog_element_t = lxb_html_dialog_element;
pub type lxb_html_directory_element_t = lxb_html_directory_element;
pub type lxb_html_div_element_t = lxb_html_div_element;
pub type lxb_html_element_t = lxb_html_element;
pub type lxb_html_embed_element_t = lxb_html_embed_element;
pub type lxb_html_field_set_element_t = lxb_html_field_set_element;
pub type lxb_html_font_element_t = lxb_html_font_element;
pub type lxb_html_form_element_t = lxb_html_form_element;
pub type lxb_html_frame_element_t = lxb_html_frame_element;
pub type lxb_html_frame_set_element_t = lxb_html_frame_set_element;
pub type lxb_html_hr_element_t = lxb_html_hr_element;
pub type lxb_html_head_element_t = lxb_html_head_element;
pub type lxb_html_heading_element_t = lxb_html_heading_element;
pub type lxb_html_html_element_t = lxb_html_html_element;
pub type lxb_html_iframe_element_t = lxb_html_iframe_element;
pub type lxb_html_image_element_t = lxb_html_image_element;
pub type lxb_html_input_element_t = lxb_html_input_element;
pub type lxb_html_li_element_t = lxb_html_li_element;
pub type lxb_html_label_element_t = lxb_html_label_element;
pub type lxb_html_legend_element_t = lxb_html_legend_element;
pub type lxb_html_link_element_t = lxb_html_link_element;
pub type lxb_html_map_element_t = lxb_html_map_element;
pub type lxb_html_marquee_element_t = lxb_html_marquee_element;
pub type lxb_html_media_element_t = lxb_html_media_element;
pub type lxb_html_menu_element_t = lxb_html_menu_element;
pub type lxb_html_meta_element_t = lxb_html_meta_element;
pub type lxb_html_meter_element_t = lxb_html_meter_element;
pub type lxb_html_mod_element_t = lxb_html_mod_element;
pub type lxb_html_o_list_element_t = lxb_html_o_list_element;
pub type lxb_html_object_element_t = lxb_html_object_element;
pub type lxb_html_opt_group_element_t = lxb_html_opt_group_element;
pub type lxb_html_option_element_t = lxb_html_option_element;
pub type lxb_html_output_element_t = lxb_html_output_element;
pub type lxb_html_paragraph_element_t = lxb_html_paragraph_element;
pub type lxb_html_param_element_t = lxb_html_param_element;
pub type lxb_html_picture_element_t = lxb_html_picture_element;
pub type lxb_html_pre_element_t = lxb_html_pre_element;
pub type lxb_html_progress_element_t = lxb_html_progress_element;
pub type lxb_html_quote_element_t = lxb_html_quote_element;
pub type lxb_html_script_element_t = lxb_html_script_element;
pub type lxb_html_select_element_t = lxb_html_select_element;
pub type lxb_html_slot_element_t = lxb_html_slot_element;
pub type lxb_html_source_element_t = lxb_html_source_element;
pub type lxb_html_span_element_t = lxb_html_span_element;
pub type lxb_html_style_element_t = lxb_html_style_element;
pub type lxb_html_table_caption_element_t = lxb_html_table_caption_element;
pub type lxb_html_table_cell_element_t = lxb_html_table_cell_element;
pub type lxb_html_table_col_element_t = lxb_html_table_col_element;
pub type lxb_html_table_element_t = lxb_html_table_element;
pub type lxb_html_table_row_element_t = lxb_html_table_row_element;
pub type lxb_html_table_section_element_t = lxb_html_table_section_element;
pub type lxb_html_template_element_t = lxb_html_template_element;
pub type lxb_html_text_area_element_t = lxb_html_text_area_element;
pub type lxb_html_time_element_t = lxb_html_time_element;
pub type lxb_html_title_element_t = lxb_html_title_element;
pub type lxb_html_track_element_t = lxb_html_track_element;
pub type lxb_html_u_list_element_t = lxb_html_u_list_element;
pub type lxb_html_unknown_element_t = lxb_html_unknown_element;
pub type lxb_html_video_element_t = lxb_html_video_element;
pub type lxb_html_window_t = lxb_html_window;
extern "C" {
    pub fn lxb_html_interface_create(
        document: *mut lxb_html_document_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
    ) -> *mut lxb_dom_interface_t;
}
extern "C" {
    pub fn lxb_html_interface_clone(
        document: *mut lxb_dom_document_t,
        intrfc: *const lxb_dom_interface_t,
    ) -> *mut lxb_dom_interface_t;
}
extern "C" {
    pub fn lxb_html_interface_destroy(intrfc: *mut lxb_dom_interface_t)
        -> *mut lxb_dom_interface_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_memory {
    pub objs: *mut lexbor_dobject_t,
    pub mraw: *mut lexbor_mraw_t,
    pub tree: *mut lexbor_mraw_t,
    pub ref_count: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_memory() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_memory> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_memory>(),
        32usize,
        concat!("Size of: ", stringify!(lxb_css_memory))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_memory>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_memory))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).objs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_memory),
            "::",
            stringify!(objs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mraw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_memory),
            "::",
            stringify!(mraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tree) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_memory),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_memory),
            "::",
            stringify!(ref_count)
        )
    );
}
impl Default for lxb_css_memory {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_memory_t = lxb_css_memory;
pub type lxb_css_type_t = u32;
pub type lxb_css_parser_t = lxb_css_parser;
pub type lxb_css_parser_state_t = lxb_css_parser_state;
pub type lxb_css_parser_error_t = lxb_css_parser_error;
pub type lxb_css_syntax_tokenizer_t = lxb_css_syntax_tokenizer;
pub type lxb_css_syntax_token_t = lxb_css_syntax_token;
pub type lxb_css_parser_state_f = ::core::option::Option<
    unsafe extern "C" fn(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool,
>;
pub type lxb_css_style_create_f =
    ::core::option::Option<unsafe extern "C" fn(memory: *mut lxb_css_memory_t) -> *mut cty::c_void>;
pub type lxb_css_style_serialize_f = ::core::option::Option<
    unsafe extern "C" fn(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
pub type lxb_css_style_destroy_f = ::core::option::Option<
    unsafe extern "C" fn(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void,
>;
pub type lxb_css_stylesheet_t = lxb_css_stylesheet;
pub type lxb_css_rule_list_t = lxb_css_rule_list;
pub type lxb_css_rule_style_t = lxb_css_rule_style;
pub type lxb_css_rule_bad_style_t = lxb_css_rule_bad_style;
pub type lxb_css_rule_declaration_list_t = lxb_css_rule_declaration_list;
pub type lxb_css_rule_declaration_t = lxb_css_rule_declaration;
pub type lxb_css_rule_at_t = lxb_css_rule_at;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_entry_data_t {
    pub name: *mut lxb_char_t,
    pub length: usize,
    pub unique: usize,
    pub state: lxb_css_parser_state_f,
    pub create: lxb_css_style_create_f,
    pub destroy: lxb_css_style_destroy_f,
    pub serialize: lxb_css_style_serialize_f,
    pub initial: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_css_entry_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_entry_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_entry_data_t>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_css_entry_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_entry_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_entry_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unique) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(unique)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initial) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_entry_data_t),
            "::",
            stringify!(initial)
        )
    );
}
impl Default for lxb_css_entry_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_data_t {
    pub name: *mut lxb_char_t,
    pub length: usize,
    pub unique: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_data_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_data_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_data_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unique) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_data_t),
            "::",
            stringify!(unique)
        )
    );
}
impl Default for lxb_css_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_memory_create() -> *mut lxb_css_memory_t;
}
extern "C" {
    pub fn lxb_css_memory_init(memory: *mut lxb_css_memory_t, prepare_count: usize)
        -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_memory_clean(memory: *mut lxb_css_memory_t);
}
extern "C" {
    pub fn lxb_css_memory_destroy(
        memory: *mut lxb_css_memory_t,
        self_destroy: bool,
    ) -> *mut lxb_css_memory_t;
}
extern "C" {
    pub fn lxb_css_memory_ref_inc(memory: *mut lxb_css_memory_t) -> *mut lxb_css_memory_t;
}
extern "C" {
    pub fn lxb_css_memory_ref_dec(memory: *mut lxb_css_memory_t);
}
extern "C" {
    pub fn lxb_css_memory_ref_dec_destroy(memory: *mut lxb_css_memory_t) -> *mut lxb_css_memory_t;
}
pub const lxb_css_log_type_t_LXB_CSS_LOG_INFO: lxb_css_log_type_t = 0;
pub const lxb_css_log_type_t_LXB_CSS_LOG_WARNING: lxb_css_log_type_t = 1;
pub const lxb_css_log_type_t_LXB_CSS_LOG_ERROR: lxb_css_log_type_t = 2;
pub const lxb_css_log_type_t_LXB_CSS_LOG_SYNTAX_ERROR: lxb_css_log_type_t = 3;
pub type lxb_css_log_type_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_log_message_t {
    pub text: lexbor_str_t,
    pub type_: lxb_css_log_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_log_message_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_log_message_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_log_message_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_log_message_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_log_message_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_log_message_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_log_message_t),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_log_message_t),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for lxb_css_log_message_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_log_t {
    pub messages: lexbor_array_obj_t,
    pub mraw: *mut lexbor_mraw_t,
    pub self_mraw: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_log_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_log_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_log_t>(),
        48usize,
        concat!("Size of: ", stringify!(lxb_css_log_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_log_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_log_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).messages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_log_t),
            "::",
            stringify!(messages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mraw) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_log_t),
            "::",
            stringify!(mraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).self_mraw) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_log_t),
            "::",
            stringify!(self_mraw)
        )
    );
}
impl Default for lxb_css_log_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_log_create() -> *mut lxb_css_log_t;
}
extern "C" {
    pub fn lxb_css_log_init(log: *mut lxb_css_log_t, mraw: *mut lexbor_mraw_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_log_clean(log: *mut lxb_css_log_t);
}
extern "C" {
    pub fn lxb_css_log_destroy(log: *mut lxb_css_log_t, self_destroy: bool) -> *mut lxb_css_log_t;
}
extern "C" {
    pub fn lxb_css_log_append(
        log: *mut lxb_css_log_t,
        type_: lxb_css_log_type_t,
        str_: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_log_message_t;
}
extern "C" {
    pub fn lxb_css_log_push(
        log: *mut lxb_css_log_t,
        type_: lxb_css_log_type_t,
        length: usize,
    ) -> *mut lxb_css_log_message_t;
}
extern "C" {
    pub fn lxb_css_log_format(
        log: *mut lxb_css_log_t,
        type_: lxb_css_log_type_t,
        format: *const cty::c_char,
        ...
    ) -> *mut lxb_css_log_message_t;
}
extern "C" {
    pub fn lxb_css_log_not_supported(
        log: *mut lxb_css_log_t,
        module_name: *const cty::c_char,
        description: *const cty::c_char,
    ) -> *mut lxb_css_log_message_t;
}
extern "C" {
    pub fn lxb_css_log_type_by_id(
        type_: lxb_css_log_type_t,
        out_length: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_css_log_serialize(
        log: *mut lxb_css_log_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
        indent: *const lxb_char_t,
        indent_length: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_log_serialize_char(
        log: *mut lxb_css_log_t,
        out_length: *mut usize,
        indent: *const lxb_char_t,
        indent_length: usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_css_log_message_serialize(
        msg: *mut lxb_css_log_message_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_log_message_serialize_char(
        msg: *mut lxb_css_log_message_t,
        out_length: *mut usize,
    ) -> *mut lxb_char_t;
}
pub type lxb_css_syntax_token_data_t = lxb_css_syntax_token_data;
pub type lxb_css_syntax_token_data_cb_f = ::core::option::Option<
    unsafe extern "C" fn(
        begin: *const lxb_char_t,
        end: *const lxb_char_t,
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        td: *mut lxb_css_syntax_token_data_t,
    ) -> *const lxb_char_t,
>;
pub type lxb_css_syntax_token_cb_f = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const lxb_char_t,
        len: usize,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_token_data {
    pub cb: lxb_css_syntax_token_data_cb_f,
    pub status: lxb_status_t,
    pub count: cty::c_int,
    pub num: u32,
    pub is_last: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token_data() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token_data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token_data>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_token_data))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token_data>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_token_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_data),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_data),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_data),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_last) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_data),
            "::",
            stringify!(is_last)
        )
    );
}
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_UNDEF: lxb_css_syntax_token_type_t = 0;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_IDENT: lxb_css_syntax_token_type_t = 1;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_FUNCTION: lxb_css_syntax_token_type_t =
    2;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_AT_KEYWORD: lxb_css_syntax_token_type_t =
    3;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_HASH: lxb_css_syntax_token_type_t = 4;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_STRING: lxb_css_syntax_token_type_t = 5;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_BAD_STRING: lxb_css_syntax_token_type_t =
    6;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_URL: lxb_css_syntax_token_type_t = 7;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_BAD_URL: lxb_css_syntax_token_type_t = 8;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_COMMENT: lxb_css_syntax_token_type_t = 9;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_WHITESPACE: lxb_css_syntax_token_type_t =
    10;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_DIMENSION: lxb_css_syntax_token_type_t =
    11;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_DELIM: lxb_css_syntax_token_type_t = 12;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_NUMBER: lxb_css_syntax_token_type_t = 13;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_PERCENTAGE: lxb_css_syntax_token_type_t =
    14;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_CDO: lxb_css_syntax_token_type_t = 15;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_CDC: lxb_css_syntax_token_type_t = 16;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_COLON: lxb_css_syntax_token_type_t = 17;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_SEMICOLON: lxb_css_syntax_token_type_t =
    18;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_COMMA: lxb_css_syntax_token_type_t = 19;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_LS_BRACKET: lxb_css_syntax_token_type_t =
    20;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_RS_BRACKET: lxb_css_syntax_token_type_t =
    21;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_L_PARENTHESIS:
    lxb_css_syntax_token_type_t = 22;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_R_PARENTHESIS:
    lxb_css_syntax_token_type_t = 23;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_LC_BRACKET: lxb_css_syntax_token_type_t =
    24;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN_RC_BRACKET: lxb_css_syntax_token_type_t =
    25;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN__EOF: lxb_css_syntax_token_type_t = 26;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN__TERMINATED:
    lxb_css_syntax_token_type_t = 27;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN__END: lxb_css_syntax_token_type_t = 27;
pub const lxb_css_syntax_token_type_t_LXB_CSS_SYNTAX_TOKEN__LAST_ENTRY:
    lxb_css_syntax_token_type_t = 28;
pub type lxb_css_syntax_token_type_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_token_base {
    pub begin: *const lxb_char_t,
    pub length: usize,
    pub user_id: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token_base() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token_base>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_token_base))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token_base>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_token_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_base),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_base),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_base),
            "::",
            stringify!(user_id)
        )
    );
}
impl Default for lxb_css_syntax_token_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_syntax_token_base_t = lxb_css_syntax_token_base;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_token_number {
    pub base: lxb_css_syntax_token_base_t,
    pub num: f64,
    pub is_float: bool,
    pub have_sign: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token_number() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token_number> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token_number>(),
        40usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_token_number))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token_number>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_token_number))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_number),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_number),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_float) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_number),
            "::",
            stringify!(is_float)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).have_sign) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_number),
            "::",
            stringify!(have_sign)
        )
    );
}
impl Default for lxb_css_syntax_token_number {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_syntax_token_number_t = lxb_css_syntax_token_number;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_token_string {
    pub base: lxb_css_syntax_token_base_t,
    pub data: *const lxb_char_t,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token_string() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token_string> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token_string>(),
        40usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_token_string))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token_string>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_token_string))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_string),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_string),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_string),
            "::",
            stringify!(length)
        )
    );
}
impl Default for lxb_css_syntax_token_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_syntax_token_string_t = lxb_css_syntax_token_string;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_token_dimension {
    pub num: lxb_css_syntax_token_number_t,
    pub str_: lxb_css_syntax_token_string_t,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token_dimension() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token_dimension> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token_dimension>(),
        80usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_token_dimension))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token_dimension>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_token_dimension))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_dimension),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_dimension),
            "::",
            stringify!(str_)
        )
    );
}
impl Default for lxb_css_syntax_token_dimension {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_syntax_token_dimension_t = lxb_css_syntax_token_dimension;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_token_delim {
    pub base: lxb_css_syntax_token_base_t,
    pub character: lxb_char_t,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token_delim() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token_delim> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token_delim>(),
        32usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_token_delim))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token_delim>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_token_delim))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_delim),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).character) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_delim),
            "::",
            stringify!(character)
        )
    );
}
impl Default for lxb_css_syntax_token_delim {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_syntax_token_delim_t = lxb_css_syntax_token_delim;
pub type lxb_css_syntax_token_ident_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_function_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_at_keyword_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_hash_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_bad_string_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_url_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_bad_url_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_percentage_t = lxb_css_syntax_token_number_t;
pub type lxb_css_syntax_token_whitespace_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_cdo_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_cdc_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_colon_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_semicolon_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_comma_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_ls_bracket_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_rs_bracket_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_l_parenthesis_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_r_parenthesis_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_lc_bracket_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_rc_bracket_t = lxb_css_syntax_token_base_t;
pub type lxb_css_syntax_token_comment_t = lxb_css_syntax_token_string_t;
pub type lxb_css_syntax_token_terminated_t = lxb_css_syntax_token_base_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_syntax_token {
    pub types: lxb_css_syntax_token_lxb_css_syntax_token_u,
    pub type_: lxb_css_syntax_token_type_t,
    pub offset: usize,
    pub cloned: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_syntax_token_lxb_css_syntax_token_u {
    pub base: lxb_css_syntax_token_base_t,
    pub comment: lxb_css_syntax_token_comment_t,
    pub number: lxb_css_syntax_token_number_t,
    pub dimension: lxb_css_syntax_token_dimension_t,
    pub percentage: lxb_css_syntax_token_percentage_t,
    pub hash: lxb_css_syntax_token_hash_t,
    pub string: lxb_css_syntax_token_string_t,
    pub bad_string: lxb_css_syntax_token_bad_string_t,
    pub delim: lxb_css_syntax_token_delim_t,
    pub lparenthesis: lxb_css_syntax_token_l_parenthesis_t,
    pub rparenthesis: lxb_css_syntax_token_r_parenthesis_t,
    pub cdc: lxb_css_syntax_token_cdc_t,
    pub function: lxb_css_syntax_token_function_t,
    pub ident: lxb_css_syntax_token_ident_t,
    pub url: lxb_css_syntax_token_url_t,
    pub bad_url: lxb_css_syntax_token_bad_url_t,
    pub at_keyword: lxb_css_syntax_token_at_keyword_t,
    pub whitespace: lxb_css_syntax_token_whitespace_t,
    pub terminated: lxb_css_syntax_token_terminated_t,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token_lxb_css_syntax_token_u() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token_lxb_css_syntax_token_u> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token_lxb_css_syntax_token_u>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token_lxb_css_syntax_token_u>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dimension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(dimension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(percentage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bad_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(bad_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(delim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lparenthesis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(lparenthesis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rparenthesis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(rparenthesis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cdc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(cdc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ident) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(ident)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).url) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bad_url) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(bad_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).at_keyword) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(at_keyword)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).whitespace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(whitespace)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).terminated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token_lxb_css_syntax_token_u),
            "::",
            stringify!(terminated)
        )
    );
}
impl Default for lxb_css_syntax_token_lxb_css_syntax_token_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_token() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_token> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_token>(),
        104usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_token))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_token>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_token))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cloned) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_token),
            "::",
            stringify!(cloned)
        )
    );
}
impl Default for lxb_css_syntax_token {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_syntax_token(
        tkz: *mut lxb_css_syntax_tokenizer_t,
    ) -> *mut lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_next(
        tkz: *mut lxb_css_syntax_tokenizer_t,
    ) -> *mut lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_consume(tkz: *mut lxb_css_syntax_tokenizer_t);
}
extern "C" {
    pub fn lxb_css_syntax_token_consume_n(tkz: *mut lxb_css_syntax_tokenizer_t, count: cty::c_uint);
}
extern "C" {
    pub fn lxb_css_syntax_token_string_dup(
        token: *mut lxb_css_syntax_token_string_t,
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_string_make(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        token: *mut lxb_css_syntax_token_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_cached_create(
        tkz: *mut lxb_css_syntax_tokenizer_t,
    ) -> *mut lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_string_free(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        token: *mut lxb_css_syntax_token_t,
    );
}
extern "C" {
    pub fn lxb_css_syntax_token_type_name_by_id(
        type_: lxb_css_syntax_token_type_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_type_id_by_name(
        type_name: *const lxb_char_t,
        len: usize,
    ) -> lxb_css_syntax_token_type_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_serialize(
        token: *const lxb_css_syntax_token_t,
        cb: lxb_css_syntax_token_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_serialize_str(
        token: *const lxb_css_syntax_token_t,
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_serialize_char(
        token: *const lxb_css_syntax_token_t,
        out_length: *mut usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_error(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        module_name: *const cty::c_char,
    ) -> *mut lxb_css_log_message_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_create_noi(
        dobj: *mut lexbor_dobject_t,
    ) -> *mut lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_clean_noi(token: *mut lxb_css_syntax_token_t);
}
extern "C" {
    pub fn lxb_css_syntax_token_destroy_noi(
        token: *mut lxb_css_syntax_token_t,
        dobj: *mut lexbor_dobject_t,
    ) -> *mut lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_type_name_noi(
        token: *mut lxb_css_syntax_token_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_css_syntax_token_type_noi(
        token: *mut lxb_css_syntax_token_t,
    ) -> lxb_css_syntax_token_type_t;
}
pub type lxb_css_syntax_tokenizer_state_f = ::core::option::Option<
    unsafe extern "C" fn(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        token: *mut lxb_css_syntax_token_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t,
>;
pub type lxb_css_syntax_tokenizer_chunk_f = ::core::option::Option<
    unsafe extern "C" fn(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        data: *mut *const lxb_char_t,
        end: *mut *const lxb_char_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
pub const lxb_css_syntax_tokenizer_opt_LXB_CSS_SYNTAX_TOKENIZER_OPT_UNDEF:
    lxb_css_syntax_tokenizer_opt = 0;
pub type lxb_css_syntax_tokenizer_opt = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_tokenizer_cache_t {
    pub list: *mut *mut lxb_css_syntax_token_t,
    pub size: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_tokenizer_cache_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_tokenizer_cache_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_tokenizer_cache_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_tokenizer_cache_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_tokenizer_cache_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_tokenizer_cache_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer_cache_t),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer_cache_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer_cache_t),
            "::",
            stringify!(length)
        )
    );
}
impl Default for lxb_css_syntax_tokenizer_cache_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_tokenizer {
    pub cache: *mut lxb_css_syntax_tokenizer_cache_t,
    pub tokens: *mut lexbor_dobject_t,
    pub parse_errors: *mut lexbor_array_obj_t,
    pub in_begin: *const lxb_char_t,
    pub in_end: *const lxb_char_t,
    pub begin: *const lxb_char_t,
    pub offset: usize,
    pub cache_pos: usize,
    pub prepared: usize,
    pub mraw: *mut lexbor_mraw_t,
    pub chunk_cb: lxb_css_syntax_tokenizer_chunk_f,
    pub chunk_ctx: *mut cty::c_void,
    pub start: *mut lxb_char_t,
    pub pos: *mut lxb_char_t,
    pub end: *const lxb_char_t,
    pub buffer: [lxb_char_t; 128usize],
    pub token_data: lxb_css_syntax_token_data_t,
    pub opt: cty::c_uint,
    pub status: lxb_status_t,
    pub eof: bool,
    pub with_comment: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_tokenizer() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_tokenizer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_tokenizer>(),
        288usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_tokenizer))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_tokenizer>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_tokenizer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tokens) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(tokens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_begin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(in_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(in_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_pos) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(cache_pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepared) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(prepared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mraw) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(mraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_cb) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(chunk_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_ctx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(chunk_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token_data) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(token_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(opt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eof) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).with_comment) as usize - ptr as usize },
        281usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer),
            "::",
            stringify!(with_comment)
        )
    );
}
impl Default for lxb_css_syntax_tokenizer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_create() -> *mut lxb_css_syntax_tokenizer_t;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_init(tkz: *mut lxb_css_syntax_tokenizer_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_clean(tkz: *mut lxb_css_syntax_tokenizer_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_destroy(
        tkz: *mut lxb_css_syntax_tokenizer_t,
    ) -> *mut lxb_css_syntax_tokenizer_t;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_next_chunk(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        data: *mut *const lxb_char_t,
        end: *mut *const lxb_char_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_lookup_colon(tkz: *mut lxb_css_syntax_tokenizer_t) -> bool;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_lookup_important(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        stop: lxb_css_syntax_token_type_t,
        stop_ch: lxb_char_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_lookup_declaration_ws_end(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        stop: lxb_css_syntax_token_type_t,
        stop_ch: lxb_char_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_status_noi(
        tkz: *mut lxb_css_syntax_tokenizer_t,
    ) -> lxb_status_t;
}
pub type lxb_css_syntax_rule_t = lxb_css_syntax_rule;
pub type lxb_css_syntax_state_f = ::core::option::Option<
    unsafe extern "C" fn(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        rule: *mut lxb_css_syntax_rule_t,
    ) -> *const lxb_css_syntax_token_t,
>;
pub type lxb_css_syntax_declaration_end_f = ::core::option::Option<
    unsafe extern "C" fn(
        parser: *mut lxb_css_parser_t,
        ctx: *mut cty::c_void,
        important: bool,
        failed: bool,
    ) -> lxb_status_t,
>;
pub type lxb_css_syntax_cb_done_f = ::core::option::Option<
    unsafe extern "C" fn(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
        failed: bool,
    ) -> lxb_status_t,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_list_rules_offset_t {
    pub begin: usize,
    pub end: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_list_rules_offset_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_list_rules_offset_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_list_rules_offset_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_list_rules_offset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_list_rules_offset_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_list_rules_offset_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_list_rules_offset_t),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_list_rules_offset_t),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_at_rule_offset_t {
    pub name: usize,
    pub prelude: usize,
    pub prelude_end: usize,
    pub block: usize,
    pub block_end: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_at_rule_offset_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_at_rule_offset_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_at_rule_offset_t>(),
        40usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_at_rule_offset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_at_rule_offset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_at_rule_offset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_at_rule_offset_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prelude) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_at_rule_offset_t),
            "::",
            stringify!(prelude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prelude_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_at_rule_offset_t),
            "::",
            stringify!(prelude_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_at_rule_offset_t),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_at_rule_offset_t),
            "::",
            stringify!(block_end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_qualified_offset_t {
    pub prelude: usize,
    pub prelude_end: usize,
    pub block: usize,
    pub block_end: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_qualified_offset_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_qualified_offset_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_qualified_offset_t>(),
        32usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_qualified_offset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_qualified_offset_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_qualified_offset_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prelude) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_qualified_offset_t),
            "::",
            stringify!(prelude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prelude_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_qualified_offset_t),
            "::",
            stringify!(prelude_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_qualified_offset_t),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_qualified_offset_t),
            "::",
            stringify!(block_end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_declarations_offset_t {
    pub begin: usize,
    pub end: usize,
    pub name_begin: usize,
    pub name_end: usize,
    pub value_begin: usize,
    pub before_important: usize,
    pub value_end: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_declarations_offset_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_declarations_offset_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_declarations_offset_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_syntax_declarations_offset_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_declarations_offset_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_declarations_offset_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_declarations_offset_t),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_declarations_offset_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name_begin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_declarations_offset_t),
            "::",
            stringify!(name_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_declarations_offset_t),
            "::",
            stringify!(name_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_begin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_declarations_offset_t),
            "::",
            stringify!(value_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).before_important) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_declarations_offset_t),
            "::",
            stringify!(before_important)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_declarations_offset_t),
            "::",
            stringify!(value_end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_cb_base_t {
    pub state: lxb_css_parser_state_f,
    pub block: lxb_css_parser_state_f,
    pub failed: lxb_css_parser_state_f,
    pub end: lxb_css_syntax_cb_done_f,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_cb_base_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_cb_base_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_cb_base_t>(),
        32usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_cb_base_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_cb_base_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_cb_base_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_base_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_base_t),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_base_t),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_base_t),
            "::",
            stringify!(end)
        )
    );
}
pub type lxb_css_syntax_cb_pipe_t = lxb_css_syntax_cb_base_t;
pub type lxb_css_syntax_cb_block_t = lxb_css_syntax_cb_base_t;
pub type lxb_css_syntax_cb_function_t = lxb_css_syntax_cb_base_t;
pub type lxb_css_syntax_cb_components_t = lxb_css_syntax_cb_base_t;
pub type lxb_css_syntax_cb_at_rule_t = lxb_css_syntax_cb_base_t;
pub type lxb_css_syntax_cb_qualified_rule_t = lxb_css_syntax_cb_base_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_cb_declarations_t {
    pub cb: lxb_css_syntax_cb_base_t,
    pub declaration_end: lxb_css_syntax_declaration_end_f,
    pub at_rule: *const lxb_css_syntax_cb_at_rule_t,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_cb_declarations_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_cb_declarations_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_cb_declarations_t>(),
        48usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_cb_declarations_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_cb_declarations_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_cb_declarations_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_declarations_t),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).declaration_end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_declarations_t),
            "::",
            stringify!(declaration_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).at_rule) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_declarations_t),
            "::",
            stringify!(at_rule)
        )
    );
}
impl Default for lxb_css_syntax_cb_declarations_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_cb_list_rules_t {
    pub cb: lxb_css_syntax_cb_base_t,
    pub next: lxb_css_parser_state_f,
    pub at_rule: *const lxb_css_syntax_cb_at_rule_t,
    pub qualified_rule: *const lxb_css_syntax_cb_qualified_rule_t,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_cb_list_rules_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_cb_list_rules_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_cb_list_rules_t>(),
        56usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_cb_list_rules_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_cb_list_rules_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_cb_list_rules_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_list_rules_t),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_list_rules_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).at_rule) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_list_rules_t),
            "::",
            stringify!(at_rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qualified_rule) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_cb_list_rules_t),
            "::",
            stringify!(qualified_rule)
        )
    );
}
impl Default for lxb_css_syntax_cb_list_rules_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_syntax_rule {
    pub phase: lxb_css_syntax_state_f,
    pub state: lxb_css_parser_state_f,
    pub state_back: lxb_css_parser_state_f,
    pub back: lxb_css_syntax_state_f,
    pub cbx: lxb_css_syntax_rule__bindgen_ty_1,
    pub context: *mut cty::c_void,
    pub offset: usize,
    pub deep: usize,
    pub block_end: lxb_css_syntax_token_type_t,
    pub skip_ending: bool,
    pub skip_consume: bool,
    pub important: bool,
    pub failed: bool,
    pub top_level: bool,
    pub u: lxb_css_syntax_rule__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_syntax_rule__bindgen_ty_1 {
    pub cb: *const lxb_css_syntax_cb_base_t,
    pub list_rules: *const lxb_css_syntax_cb_list_rules_t,
    pub at_rule: *const lxb_css_syntax_cb_at_rule_t,
    pub qualified_rule: *const lxb_css_syntax_cb_qualified_rule_t,
    pub declarations: *const lxb_css_syntax_cb_declarations_t,
    pub components: *const lxb_css_syntax_cb_components_t,
    pub func: *const lxb_css_syntax_cb_function_t,
    pub block: *const lxb_css_syntax_cb_block_t,
    pub pipe: *const lxb_css_syntax_cb_pipe_t,
    pub user: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_rule__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_rule__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_rule__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_rule__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_rule__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list_rules) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(list_rules)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).at_rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(at_rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qualified_rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(qualified_rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).declarations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(declarations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).components) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pipe) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(pipe)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_1),
            "::",
            stringify!(user)
        )
    );
}
impl Default for lxb_css_syntax_rule__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_syntax_rule__bindgen_ty_2 {
    pub list_rules: lxb_css_syntax_list_rules_offset_t,
    pub at_rule: lxb_css_syntax_at_rule_offset_t,
    pub qualified: lxb_css_syntax_qualified_offset_t,
    pub declarations: lxb_css_syntax_declarations_offset_t,
    pub user: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_rule__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_rule__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_rule__bindgen_ty_2>(),
        56usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_rule__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_rule__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list_rules) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_2),
            "::",
            stringify!(list_rules)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).at_rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_2),
            "::",
            stringify!(at_rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qualified) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_2),
            "::",
            stringify!(qualified)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).declarations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_2),
            "::",
            stringify!(declarations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule__bindgen_ty_2),
            "::",
            stringify!(user)
        )
    );
}
impl Default for lxb_css_syntax_rule__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_rule() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_rule> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_rule>(),
        136usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_rule))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_rule))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phase) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state_back) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(state_back)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).back) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(back)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(cbx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deep) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(deep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(block_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip_ending) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(skip_ending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip_consume) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(skip_consume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).important) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(important)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top_level) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(top_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_rule),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_syntax_rule {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_syntax_parse_list_rules(
        parser: *mut lxb_css_parser_t,
        cb: *const lxb_css_syntax_cb_list_rules_t,
        data: *const lxb_char_t,
        length: usize,
        ctx: *mut cty::c_void,
        top_level: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_stack_expand(parser: *mut lxb_css_parser_t, count: usize)
        -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_codepoint_to_ascii(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        cp: lxb_codepoint_t,
    );
}
extern "C" {
    pub fn lxb_css_syntax_ident_serialize(
        data: *const lxb_char_t,
        length: usize,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_string_serialize(
        data: *const lxb_char_t,
        length: usize,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_ident_or_string_serialize(
        data: *const lxb_char_t,
        length: usize,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
pub const LXB_CSS_VALUE__UNDEF: _bindgen_ty_1 = 0;
pub const LXB_CSS_VALUE_INITIAL: _bindgen_ty_1 = 1;
pub const LXB_CSS_VALUE_INHERIT: _bindgen_ty_1 = 2;
pub const LXB_CSS_VALUE_UNSET: _bindgen_ty_1 = 3;
pub const LXB_CSS_VALUE_REVERT: _bindgen_ty_1 = 4;
pub const LXB_CSS_VALUE_FLEX_START: _bindgen_ty_1 = 5;
pub const LXB_CSS_VALUE_FLEX_END: _bindgen_ty_1 = 6;
pub const LXB_CSS_VALUE_CENTER: _bindgen_ty_1 = 7;
pub const LXB_CSS_VALUE_SPACE_BETWEEN: _bindgen_ty_1 = 8;
pub const LXB_CSS_VALUE_SPACE_AROUND: _bindgen_ty_1 = 9;
pub const LXB_CSS_VALUE_STRETCH: _bindgen_ty_1 = 10;
pub const LXB_CSS_VALUE_BASELINE: _bindgen_ty_1 = 11;
pub const LXB_CSS_VALUE_AUTO: _bindgen_ty_1 = 12;
pub const LXB_CSS_VALUE_TEXT_BOTTOM: _bindgen_ty_1 = 13;
pub const LXB_CSS_VALUE_ALPHABETIC: _bindgen_ty_1 = 14;
pub const LXB_CSS_VALUE_IDEOGRAPHIC: _bindgen_ty_1 = 15;
pub const LXB_CSS_VALUE_MIDDLE: _bindgen_ty_1 = 16;
pub const LXB_CSS_VALUE_CENTRAL: _bindgen_ty_1 = 17;
pub const LXB_CSS_VALUE_MATHEMATICAL: _bindgen_ty_1 = 18;
pub const LXB_CSS_VALUE_TEXT_TOP: _bindgen_ty_1 = 19;
pub const LXB_CSS_VALUE__LENGTH: _bindgen_ty_1 = 20;
pub const LXB_CSS_VALUE__PERCENTAGE: _bindgen_ty_1 = 21;
pub const LXB_CSS_VALUE_SUB: _bindgen_ty_1 = 22;
pub const LXB_CSS_VALUE_SUPER: _bindgen_ty_1 = 23;
pub const LXB_CSS_VALUE_TOP: _bindgen_ty_1 = 24;
pub const LXB_CSS_VALUE_BOTTOM: _bindgen_ty_1 = 25;
pub const LXB_CSS_VALUE_FIRST: _bindgen_ty_1 = 26;
pub const LXB_CSS_VALUE_LAST: _bindgen_ty_1 = 27;
pub const LXB_CSS_VALUE_THIN: _bindgen_ty_1 = 28;
pub const LXB_CSS_VALUE_MEDIUM: _bindgen_ty_1 = 29;
pub const LXB_CSS_VALUE_THICK: _bindgen_ty_1 = 30;
pub const LXB_CSS_VALUE_NONE: _bindgen_ty_1 = 31;
pub const LXB_CSS_VALUE_HIDDEN: _bindgen_ty_1 = 32;
pub const LXB_CSS_VALUE_DOTTED: _bindgen_ty_1 = 33;
pub const LXB_CSS_VALUE_DASHED: _bindgen_ty_1 = 34;
pub const LXB_CSS_VALUE_SOLID: _bindgen_ty_1 = 35;
pub const LXB_CSS_VALUE_DOUBLE: _bindgen_ty_1 = 36;
pub const LXB_CSS_VALUE_GROOVE: _bindgen_ty_1 = 37;
pub const LXB_CSS_VALUE_RIDGE: _bindgen_ty_1 = 38;
pub const LXB_CSS_VALUE_INSET: _bindgen_ty_1 = 39;
pub const LXB_CSS_VALUE_OUTSET: _bindgen_ty_1 = 40;
pub const LXB_CSS_VALUE_CONTENT_BOX: _bindgen_ty_1 = 41;
pub const LXB_CSS_VALUE_BORDER_BOX: _bindgen_ty_1 = 42;
pub const LXB_CSS_VALUE_INLINE_START: _bindgen_ty_1 = 43;
pub const LXB_CSS_VALUE_INLINE_END: _bindgen_ty_1 = 44;
pub const LXB_CSS_VALUE_BLOCK_START: _bindgen_ty_1 = 45;
pub const LXB_CSS_VALUE_BLOCK_END: _bindgen_ty_1 = 46;
pub const LXB_CSS_VALUE_LEFT: _bindgen_ty_1 = 47;
pub const LXB_CSS_VALUE_RIGHT: _bindgen_ty_1 = 48;
pub const LXB_CSS_VALUE_CURRENTCOLOR: _bindgen_ty_1 = 49;
pub const LXB_CSS_VALUE_TRANSPARENT: _bindgen_ty_1 = 50;
pub const LXB_CSS_VALUE_HEX: _bindgen_ty_1 = 51;
pub const LXB_CSS_VALUE_ALICEBLUE: _bindgen_ty_1 = 52;
pub const LXB_CSS_VALUE_ANTIQUEWHITE: _bindgen_ty_1 = 53;
pub const LXB_CSS_VALUE_AQUA: _bindgen_ty_1 = 54;
pub const LXB_CSS_VALUE_AQUAMARINE: _bindgen_ty_1 = 55;
pub const LXB_CSS_VALUE_AZURE: _bindgen_ty_1 = 56;
pub const LXB_CSS_VALUE_BEIGE: _bindgen_ty_1 = 57;
pub const LXB_CSS_VALUE_BISQUE: _bindgen_ty_1 = 58;
pub const LXB_CSS_VALUE_BLACK: _bindgen_ty_1 = 59;
pub const LXB_CSS_VALUE_BLANCHEDALMOND: _bindgen_ty_1 = 60;
pub const LXB_CSS_VALUE_BLUE: _bindgen_ty_1 = 61;
pub const LXB_CSS_VALUE_BLUEVIOLET: _bindgen_ty_1 = 62;
pub const LXB_CSS_VALUE_BROWN: _bindgen_ty_1 = 63;
pub const LXB_CSS_VALUE_BURLYWOOD: _bindgen_ty_1 = 64;
pub const LXB_CSS_VALUE_CADETBLUE: _bindgen_ty_1 = 65;
pub const LXB_CSS_VALUE_CHARTREUSE: _bindgen_ty_1 = 66;
pub const LXB_CSS_VALUE_CHOCOLATE: _bindgen_ty_1 = 67;
pub const LXB_CSS_VALUE_CORAL: _bindgen_ty_1 = 68;
pub const LXB_CSS_VALUE_CORNFLOWERBLUE: _bindgen_ty_1 = 69;
pub const LXB_CSS_VALUE_CORNSILK: _bindgen_ty_1 = 70;
pub const LXB_CSS_VALUE_CRIMSON: _bindgen_ty_1 = 71;
pub const LXB_CSS_VALUE_CYAN: _bindgen_ty_1 = 72;
pub const LXB_CSS_VALUE_DARKBLUE: _bindgen_ty_1 = 73;
pub const LXB_CSS_VALUE_DARKCYAN: _bindgen_ty_1 = 74;
pub const LXB_CSS_VALUE_DARKGOLDENROD: _bindgen_ty_1 = 75;
pub const LXB_CSS_VALUE_DARKGRAY: _bindgen_ty_1 = 76;
pub const LXB_CSS_VALUE_DARKGREEN: _bindgen_ty_1 = 77;
pub const LXB_CSS_VALUE_DARKGREY: _bindgen_ty_1 = 78;
pub const LXB_CSS_VALUE_DARKKHAKI: _bindgen_ty_1 = 79;
pub const LXB_CSS_VALUE_DARKMAGENTA: _bindgen_ty_1 = 80;
pub const LXB_CSS_VALUE_DARKOLIVEGREEN: _bindgen_ty_1 = 81;
pub const LXB_CSS_VALUE_DARKORANGE: _bindgen_ty_1 = 82;
pub const LXB_CSS_VALUE_DARKORCHID: _bindgen_ty_1 = 83;
pub const LXB_CSS_VALUE_DARKRED: _bindgen_ty_1 = 84;
pub const LXB_CSS_VALUE_DARKSALMON: _bindgen_ty_1 = 85;
pub const LXB_CSS_VALUE_DARKSEAGREEN: _bindgen_ty_1 = 86;
pub const LXB_CSS_VALUE_DARKSLATEBLUE: _bindgen_ty_1 = 87;
pub const LXB_CSS_VALUE_DARKSLATEGRAY: _bindgen_ty_1 = 88;
pub const LXB_CSS_VALUE_DARKSLATEGREY: _bindgen_ty_1 = 89;
pub const LXB_CSS_VALUE_DARKTURQUOISE: _bindgen_ty_1 = 90;
pub const LXB_CSS_VALUE_DARKVIOLET: _bindgen_ty_1 = 91;
pub const LXB_CSS_VALUE_DEEPPINK: _bindgen_ty_1 = 92;
pub const LXB_CSS_VALUE_DEEPSKYBLUE: _bindgen_ty_1 = 93;
pub const LXB_CSS_VALUE_DIMGRAY: _bindgen_ty_1 = 94;
pub const LXB_CSS_VALUE_DIMGREY: _bindgen_ty_1 = 95;
pub const LXB_CSS_VALUE_DODGERBLUE: _bindgen_ty_1 = 96;
pub const LXB_CSS_VALUE_FIREBRICK: _bindgen_ty_1 = 97;
pub const LXB_CSS_VALUE_FLORALWHITE: _bindgen_ty_1 = 98;
pub const LXB_CSS_VALUE_FORESTGREEN: _bindgen_ty_1 = 99;
pub const LXB_CSS_VALUE_FUCHSIA: _bindgen_ty_1 = 100;
pub const LXB_CSS_VALUE_GAINSBORO: _bindgen_ty_1 = 101;
pub const LXB_CSS_VALUE_GHOSTWHITE: _bindgen_ty_1 = 102;
pub const LXB_CSS_VALUE_GOLD: _bindgen_ty_1 = 103;
pub const LXB_CSS_VALUE_GOLDENROD: _bindgen_ty_1 = 104;
pub const LXB_CSS_VALUE_GRAY: _bindgen_ty_1 = 105;
pub const LXB_CSS_VALUE_GREEN: _bindgen_ty_1 = 106;
pub const LXB_CSS_VALUE_GREENYELLOW: _bindgen_ty_1 = 107;
pub const LXB_CSS_VALUE_GREY: _bindgen_ty_1 = 108;
pub const LXB_CSS_VALUE_HONEYDEW: _bindgen_ty_1 = 109;
pub const LXB_CSS_VALUE_HOTPINK: _bindgen_ty_1 = 110;
pub const LXB_CSS_VALUE_INDIANRED: _bindgen_ty_1 = 111;
pub const LXB_CSS_VALUE_INDIGO: _bindgen_ty_1 = 112;
pub const LXB_CSS_VALUE_IVORY: _bindgen_ty_1 = 113;
pub const LXB_CSS_VALUE_KHAKI: _bindgen_ty_1 = 114;
pub const LXB_CSS_VALUE_LAVENDER: _bindgen_ty_1 = 115;
pub const LXB_CSS_VALUE_LAVENDERBLUSH: _bindgen_ty_1 = 116;
pub const LXB_CSS_VALUE_LAWNGREEN: _bindgen_ty_1 = 117;
pub const LXB_CSS_VALUE_LEMONCHIFFON: _bindgen_ty_1 = 118;
pub const LXB_CSS_VALUE_LIGHTBLUE: _bindgen_ty_1 = 119;
pub const LXB_CSS_VALUE_LIGHTCORAL: _bindgen_ty_1 = 120;
pub const LXB_CSS_VALUE_LIGHTCYAN: _bindgen_ty_1 = 121;
pub const LXB_CSS_VALUE_LIGHTGOLDENRODYELLOW: _bindgen_ty_1 = 122;
pub const LXB_CSS_VALUE_LIGHTGRAY: _bindgen_ty_1 = 123;
pub const LXB_CSS_VALUE_LIGHTGREEN: _bindgen_ty_1 = 124;
pub const LXB_CSS_VALUE_LIGHTGREY: _bindgen_ty_1 = 125;
pub const LXB_CSS_VALUE_LIGHTPINK: _bindgen_ty_1 = 126;
pub const LXB_CSS_VALUE_LIGHTSALMON: _bindgen_ty_1 = 127;
pub const LXB_CSS_VALUE_LIGHTSEAGREEN: _bindgen_ty_1 = 128;
pub const LXB_CSS_VALUE_LIGHTSKYBLUE: _bindgen_ty_1 = 129;
pub const LXB_CSS_VALUE_LIGHTSLATEGRAY: _bindgen_ty_1 = 130;
pub const LXB_CSS_VALUE_LIGHTSLATEGREY: _bindgen_ty_1 = 131;
pub const LXB_CSS_VALUE_LIGHTSTEELBLUE: _bindgen_ty_1 = 132;
pub const LXB_CSS_VALUE_LIGHTYELLOW: _bindgen_ty_1 = 133;
pub const LXB_CSS_VALUE_LIME: _bindgen_ty_1 = 134;
pub const LXB_CSS_VALUE_LIMEGREEN: _bindgen_ty_1 = 135;
pub const LXB_CSS_VALUE_LINEN: _bindgen_ty_1 = 136;
pub const LXB_CSS_VALUE_MAGENTA: _bindgen_ty_1 = 137;
pub const LXB_CSS_VALUE_MAROON: _bindgen_ty_1 = 138;
pub const LXB_CSS_VALUE_MEDIUMAQUAMARINE: _bindgen_ty_1 = 139;
pub const LXB_CSS_VALUE_MEDIUMBLUE: _bindgen_ty_1 = 140;
pub const LXB_CSS_VALUE_MEDIUMORCHID: _bindgen_ty_1 = 141;
pub const LXB_CSS_VALUE_MEDIUMPURPLE: _bindgen_ty_1 = 142;
pub const LXB_CSS_VALUE_MEDIUMSEAGREEN: _bindgen_ty_1 = 143;
pub const LXB_CSS_VALUE_MEDIUMSLATEBLUE: _bindgen_ty_1 = 144;
pub const LXB_CSS_VALUE_MEDIUMSPRINGGREEN: _bindgen_ty_1 = 145;
pub const LXB_CSS_VALUE_MEDIUMTURQUOISE: _bindgen_ty_1 = 146;
pub const LXB_CSS_VALUE_MEDIUMVIOLETRED: _bindgen_ty_1 = 147;
pub const LXB_CSS_VALUE_MIDNIGHTBLUE: _bindgen_ty_1 = 148;
pub const LXB_CSS_VALUE_MINTCREAM: _bindgen_ty_1 = 149;
pub const LXB_CSS_VALUE_MISTYROSE: _bindgen_ty_1 = 150;
pub const LXB_CSS_VALUE_MOCCASIN: _bindgen_ty_1 = 151;
pub const LXB_CSS_VALUE_NAVAJOWHITE: _bindgen_ty_1 = 152;
pub const LXB_CSS_VALUE_NAVY: _bindgen_ty_1 = 153;
pub const LXB_CSS_VALUE_OLDLACE: _bindgen_ty_1 = 154;
pub const LXB_CSS_VALUE_OLIVE: _bindgen_ty_1 = 155;
pub const LXB_CSS_VALUE_OLIVEDRAB: _bindgen_ty_1 = 156;
pub const LXB_CSS_VALUE_ORANGE: _bindgen_ty_1 = 157;
pub const LXB_CSS_VALUE_ORANGERED: _bindgen_ty_1 = 158;
pub const LXB_CSS_VALUE_ORCHID: _bindgen_ty_1 = 159;
pub const LXB_CSS_VALUE_PALEGOLDENROD: _bindgen_ty_1 = 160;
pub const LXB_CSS_VALUE_PALEGREEN: _bindgen_ty_1 = 161;
pub const LXB_CSS_VALUE_PALETURQUOISE: _bindgen_ty_1 = 162;
pub const LXB_CSS_VALUE_PALEVIOLETRED: _bindgen_ty_1 = 163;
pub const LXB_CSS_VALUE_PAPAYAWHIP: _bindgen_ty_1 = 164;
pub const LXB_CSS_VALUE_PEACHPUFF: _bindgen_ty_1 = 165;
pub const LXB_CSS_VALUE_PERU: _bindgen_ty_1 = 166;
pub const LXB_CSS_VALUE_PINK: _bindgen_ty_1 = 167;
pub const LXB_CSS_VALUE_PLUM: _bindgen_ty_1 = 168;
pub const LXB_CSS_VALUE_POWDERBLUE: _bindgen_ty_1 = 169;
pub const LXB_CSS_VALUE_PURPLE: _bindgen_ty_1 = 170;
pub const LXB_CSS_VALUE_REBECCAPURPLE: _bindgen_ty_1 = 171;
pub const LXB_CSS_VALUE_RED: _bindgen_ty_1 = 172;
pub const LXB_CSS_VALUE_ROSYBROWN: _bindgen_ty_1 = 173;
pub const LXB_CSS_VALUE_ROYALBLUE: _bindgen_ty_1 = 174;
pub const LXB_CSS_VALUE_SADDLEBROWN: _bindgen_ty_1 = 175;
pub const LXB_CSS_VALUE_SALMON: _bindgen_ty_1 = 176;
pub const LXB_CSS_VALUE_SANDYBROWN: _bindgen_ty_1 = 177;
pub const LXB_CSS_VALUE_SEAGREEN: _bindgen_ty_1 = 178;
pub const LXB_CSS_VALUE_SEASHELL: _bindgen_ty_1 = 179;
pub const LXB_CSS_VALUE_SIENNA: _bindgen_ty_1 = 180;
pub const LXB_CSS_VALUE_SILVER: _bindgen_ty_1 = 181;
pub const LXB_CSS_VALUE_SKYBLUE: _bindgen_ty_1 = 182;
pub const LXB_CSS_VALUE_SLATEBLUE: _bindgen_ty_1 = 183;
pub const LXB_CSS_VALUE_SLATEGRAY: _bindgen_ty_1 = 184;
pub const LXB_CSS_VALUE_SLATEGREY: _bindgen_ty_1 = 185;
pub const LXB_CSS_VALUE_SNOW: _bindgen_ty_1 = 186;
pub const LXB_CSS_VALUE_SPRINGGREEN: _bindgen_ty_1 = 187;
pub const LXB_CSS_VALUE_STEELBLUE: _bindgen_ty_1 = 188;
pub const LXB_CSS_VALUE_TAN: _bindgen_ty_1 = 189;
pub const LXB_CSS_VALUE_TEAL: _bindgen_ty_1 = 190;
pub const LXB_CSS_VALUE_THISTLE: _bindgen_ty_1 = 191;
pub const LXB_CSS_VALUE_TOMATO: _bindgen_ty_1 = 192;
pub const LXB_CSS_VALUE_TURQUOISE: _bindgen_ty_1 = 193;
pub const LXB_CSS_VALUE_VIOLET: _bindgen_ty_1 = 194;
pub const LXB_CSS_VALUE_WHEAT: _bindgen_ty_1 = 195;
pub const LXB_CSS_VALUE_WHITE: _bindgen_ty_1 = 196;
pub const LXB_CSS_VALUE_WHITESMOKE: _bindgen_ty_1 = 197;
pub const LXB_CSS_VALUE_YELLOW: _bindgen_ty_1 = 198;
pub const LXB_CSS_VALUE_YELLOWGREEN: _bindgen_ty_1 = 199;
pub const LXB_CSS_VALUE_CANVAS: _bindgen_ty_1 = 200;
pub const LXB_CSS_VALUE_CANVASTEXT: _bindgen_ty_1 = 201;
pub const LXB_CSS_VALUE_LINKTEXT: _bindgen_ty_1 = 202;
pub const LXB_CSS_VALUE_VISITEDTEXT: _bindgen_ty_1 = 203;
pub const LXB_CSS_VALUE_ACTIVETEXT: _bindgen_ty_1 = 204;
pub const LXB_CSS_VALUE_BUTTONFACE: _bindgen_ty_1 = 205;
pub const LXB_CSS_VALUE_BUTTONTEXT: _bindgen_ty_1 = 206;
pub const LXB_CSS_VALUE_BUTTONBORDER: _bindgen_ty_1 = 207;
pub const LXB_CSS_VALUE_FIELD: _bindgen_ty_1 = 208;
pub const LXB_CSS_VALUE_FIELDTEXT: _bindgen_ty_1 = 209;
pub const LXB_CSS_VALUE_HIGHLIGHT: _bindgen_ty_1 = 210;
pub const LXB_CSS_VALUE_HIGHLIGHTTEXT: _bindgen_ty_1 = 211;
pub const LXB_CSS_VALUE_SELECTEDITEM: _bindgen_ty_1 = 212;
pub const LXB_CSS_VALUE_SELECTEDITEMTEXT: _bindgen_ty_1 = 213;
pub const LXB_CSS_VALUE_MARK: _bindgen_ty_1 = 214;
pub const LXB_CSS_VALUE_MARKTEXT: _bindgen_ty_1 = 215;
pub const LXB_CSS_VALUE_GRAYTEXT: _bindgen_ty_1 = 216;
pub const LXB_CSS_VALUE_ACCENTCOLOR: _bindgen_ty_1 = 217;
pub const LXB_CSS_VALUE_ACCENTCOLORTEXT: _bindgen_ty_1 = 218;
pub const LXB_CSS_VALUE_RGB: _bindgen_ty_1 = 219;
pub const LXB_CSS_VALUE_RGBA: _bindgen_ty_1 = 220;
pub const LXB_CSS_VALUE_HSL: _bindgen_ty_1 = 221;
pub const LXB_CSS_VALUE_HSLA: _bindgen_ty_1 = 222;
pub const LXB_CSS_VALUE_HWB: _bindgen_ty_1 = 223;
pub const LXB_CSS_VALUE_LAB: _bindgen_ty_1 = 224;
pub const LXB_CSS_VALUE_LCH: _bindgen_ty_1 = 225;
pub const LXB_CSS_VALUE_OKLAB: _bindgen_ty_1 = 226;
pub const LXB_CSS_VALUE_OKLCH: _bindgen_ty_1 = 227;
pub const LXB_CSS_VALUE_COLOR: _bindgen_ty_1 = 228;
pub const LXB_CSS_VALUE_LTR: _bindgen_ty_1 = 229;
pub const LXB_CSS_VALUE_RTL: _bindgen_ty_1 = 230;
pub const LXB_CSS_VALUE_BLOCK: _bindgen_ty_1 = 231;
pub const LXB_CSS_VALUE_INLINE: _bindgen_ty_1 = 232;
pub const LXB_CSS_VALUE_RUN_IN: _bindgen_ty_1 = 233;
pub const LXB_CSS_VALUE_FLOW: _bindgen_ty_1 = 234;
pub const LXB_CSS_VALUE_FLOW_ROOT: _bindgen_ty_1 = 235;
pub const LXB_CSS_VALUE_TABLE: _bindgen_ty_1 = 236;
pub const LXB_CSS_VALUE_FLEX: _bindgen_ty_1 = 237;
pub const LXB_CSS_VALUE_GRID: _bindgen_ty_1 = 238;
pub const LXB_CSS_VALUE_RUBY: _bindgen_ty_1 = 239;
pub const LXB_CSS_VALUE_LIST_ITEM: _bindgen_ty_1 = 240;
pub const LXB_CSS_VALUE_TABLE_ROW_GROUP: _bindgen_ty_1 = 241;
pub const LXB_CSS_VALUE_TABLE_HEADER_GROUP: _bindgen_ty_1 = 242;
pub const LXB_CSS_VALUE_TABLE_FOOTER_GROUP: _bindgen_ty_1 = 243;
pub const LXB_CSS_VALUE_TABLE_ROW: _bindgen_ty_1 = 244;
pub const LXB_CSS_VALUE_TABLE_CELL: _bindgen_ty_1 = 245;
pub const LXB_CSS_VALUE_TABLE_COLUMN_GROUP: _bindgen_ty_1 = 246;
pub const LXB_CSS_VALUE_TABLE_COLUMN: _bindgen_ty_1 = 247;
pub const LXB_CSS_VALUE_TABLE_CAPTION: _bindgen_ty_1 = 248;
pub const LXB_CSS_VALUE_RUBY_BASE: _bindgen_ty_1 = 249;
pub const LXB_CSS_VALUE_RUBY_TEXT: _bindgen_ty_1 = 250;
pub const LXB_CSS_VALUE_RUBY_BASE_CONTAINER: _bindgen_ty_1 = 251;
pub const LXB_CSS_VALUE_RUBY_TEXT_CONTAINER: _bindgen_ty_1 = 252;
pub const LXB_CSS_VALUE_CONTENTS: _bindgen_ty_1 = 253;
pub const LXB_CSS_VALUE_INLINE_BLOCK: _bindgen_ty_1 = 254;
pub const LXB_CSS_VALUE_INLINE_TABLE: _bindgen_ty_1 = 255;
pub const LXB_CSS_VALUE_INLINE_FLEX: _bindgen_ty_1 = 256;
pub const LXB_CSS_VALUE_INLINE_GRID: _bindgen_ty_1 = 257;
pub const LXB_CSS_VALUE_HANGING: _bindgen_ty_1 = 258;
pub const LXB_CSS_VALUE_CONTENT: _bindgen_ty_1 = 259;
pub const LXB_CSS_VALUE_ROW: _bindgen_ty_1 = 260;
pub const LXB_CSS_VALUE_ROW_REVERSE: _bindgen_ty_1 = 261;
pub const LXB_CSS_VALUE_COLUMN: _bindgen_ty_1 = 262;
pub const LXB_CSS_VALUE_COLUMN_REVERSE: _bindgen_ty_1 = 263;
pub const LXB_CSS_VALUE__NUMBER: _bindgen_ty_1 = 264;
pub const LXB_CSS_VALUE_NOWRAP: _bindgen_ty_1 = 265;
pub const LXB_CSS_VALUE_WRAP: _bindgen_ty_1 = 266;
pub const LXB_CSS_VALUE_WRAP_REVERSE: _bindgen_ty_1 = 267;
pub const LXB_CSS_VALUE_SNAP_BLOCK: _bindgen_ty_1 = 268;
pub const LXB_CSS_VALUE_START: _bindgen_ty_1 = 269;
pub const LXB_CSS_VALUE_END: _bindgen_ty_1 = 270;
pub const LXB_CSS_VALUE_NEAR: _bindgen_ty_1 = 271;
pub const LXB_CSS_VALUE_SNAP_INLINE: _bindgen_ty_1 = 272;
pub const LXB_CSS_VALUE__INTEGER: _bindgen_ty_1 = 273;
pub const LXB_CSS_VALUE_REGION: _bindgen_ty_1 = 274;
pub const LXB_CSS_VALUE_PAGE: _bindgen_ty_1 = 275;
pub const LXB_CSS_VALUE_SERIF: _bindgen_ty_1 = 276;
pub const LXB_CSS_VALUE_SANS_SERIF: _bindgen_ty_1 = 277;
pub const LXB_CSS_VALUE_CURSIVE: _bindgen_ty_1 = 278;
pub const LXB_CSS_VALUE_FANTASY: _bindgen_ty_1 = 279;
pub const LXB_CSS_VALUE_MONOSPACE: _bindgen_ty_1 = 280;
pub const LXB_CSS_VALUE_SYSTEM_UI: _bindgen_ty_1 = 281;
pub const LXB_CSS_VALUE_EMOJI: _bindgen_ty_1 = 282;
pub const LXB_CSS_VALUE_MATH: _bindgen_ty_1 = 283;
pub const LXB_CSS_VALUE_FANGSONG: _bindgen_ty_1 = 284;
pub const LXB_CSS_VALUE_UI_SERIF: _bindgen_ty_1 = 285;
pub const LXB_CSS_VALUE_UI_SANS_SERIF: _bindgen_ty_1 = 286;
pub const LXB_CSS_VALUE_UI_MONOSPACE: _bindgen_ty_1 = 287;
pub const LXB_CSS_VALUE_UI_ROUNDED: _bindgen_ty_1 = 288;
pub const LXB_CSS_VALUE_XX_SMALL: _bindgen_ty_1 = 289;
pub const LXB_CSS_VALUE_X_SMALL: _bindgen_ty_1 = 290;
pub const LXB_CSS_VALUE_SMALL: _bindgen_ty_1 = 291;
pub const LXB_CSS_VALUE_LARGE: _bindgen_ty_1 = 292;
pub const LXB_CSS_VALUE_X_LARGE: _bindgen_ty_1 = 293;
pub const LXB_CSS_VALUE_XX_LARGE: _bindgen_ty_1 = 294;
pub const LXB_CSS_VALUE_XXX_LARGE: _bindgen_ty_1 = 295;
pub const LXB_CSS_VALUE_LARGER: _bindgen_ty_1 = 296;
pub const LXB_CSS_VALUE_SMALLER: _bindgen_ty_1 = 297;
pub const LXB_CSS_VALUE_NORMAL: _bindgen_ty_1 = 298;
pub const LXB_CSS_VALUE_ULTRA_CONDENSED: _bindgen_ty_1 = 299;
pub const LXB_CSS_VALUE_EXTRA_CONDENSED: _bindgen_ty_1 = 300;
pub const LXB_CSS_VALUE_CONDENSED: _bindgen_ty_1 = 301;
pub const LXB_CSS_VALUE_SEMI_CONDENSED: _bindgen_ty_1 = 302;
pub const LXB_CSS_VALUE_SEMI_EXPANDED: _bindgen_ty_1 = 303;
pub const LXB_CSS_VALUE_EXPANDED: _bindgen_ty_1 = 304;
pub const LXB_CSS_VALUE_EXTRA_EXPANDED: _bindgen_ty_1 = 305;
pub const LXB_CSS_VALUE_ULTRA_EXPANDED: _bindgen_ty_1 = 306;
pub const LXB_CSS_VALUE_ITALIC: _bindgen_ty_1 = 307;
pub const LXB_CSS_VALUE_OBLIQUE: _bindgen_ty_1 = 308;
pub const LXB_CSS_VALUE_BOLD: _bindgen_ty_1 = 309;
pub const LXB_CSS_VALUE_BOLDER: _bindgen_ty_1 = 310;
pub const LXB_CSS_VALUE_LIGHTER: _bindgen_ty_1 = 311;
pub const LXB_CSS_VALUE_FORCE_END: _bindgen_ty_1 = 312;
pub const LXB_CSS_VALUE_ALLOW_END: _bindgen_ty_1 = 313;
pub const LXB_CSS_VALUE_MIN_CONTENT: _bindgen_ty_1 = 314;
pub const LXB_CSS_VALUE_MAX_CONTENT: _bindgen_ty_1 = 315;
pub const LXB_CSS_VALUE__ANGLE: _bindgen_ty_1 = 316;
pub const LXB_CSS_VALUE_MANUAL: _bindgen_ty_1 = 317;
pub const LXB_CSS_VALUE_LOOSE: _bindgen_ty_1 = 318;
pub const LXB_CSS_VALUE_STRICT: _bindgen_ty_1 = 319;
pub const LXB_CSS_VALUE_ANYWHERE: _bindgen_ty_1 = 320;
pub const LXB_CSS_VALUE_VISIBLE: _bindgen_ty_1 = 321;
pub const LXB_CSS_VALUE_CLIP: _bindgen_ty_1 = 322;
pub const LXB_CSS_VALUE_SCROLL: _bindgen_ty_1 = 323;
pub const LXB_CSS_VALUE_BREAK_WORD: _bindgen_ty_1 = 324;
pub const LXB_CSS_VALUE_STATIC: _bindgen_ty_1 = 325;
pub const LXB_CSS_VALUE_RELATIVE: _bindgen_ty_1 = 326;
pub const LXB_CSS_VALUE_ABSOLUTE: _bindgen_ty_1 = 327;
pub const LXB_CSS_VALUE_STICKY: _bindgen_ty_1 = 328;
pub const LXB_CSS_VALUE_FIXED: _bindgen_ty_1 = 329;
pub const LXB_CSS_VALUE_JUSTIFY: _bindgen_ty_1 = 330;
pub const LXB_CSS_VALUE_MATCH_PARENT: _bindgen_ty_1 = 331;
pub const LXB_CSS_VALUE_JUSTIFY_ALL: _bindgen_ty_1 = 332;
pub const LXB_CSS_VALUE_ALL: _bindgen_ty_1 = 333;
pub const LXB_CSS_VALUE_DIGITS: _bindgen_ty_1 = 334;
pub const LXB_CSS_VALUE_UNDERLINE: _bindgen_ty_1 = 335;
pub const LXB_CSS_VALUE_OVERLINE: _bindgen_ty_1 = 336;
pub const LXB_CSS_VALUE_LINE_THROUGH: _bindgen_ty_1 = 337;
pub const LXB_CSS_VALUE_BLINK: _bindgen_ty_1 = 338;
pub const LXB_CSS_VALUE_WAVY: _bindgen_ty_1 = 339;
pub const LXB_CSS_VALUE_EACH_LINE: _bindgen_ty_1 = 340;
pub const LXB_CSS_VALUE_INTER_WORD: _bindgen_ty_1 = 341;
pub const LXB_CSS_VALUE_INTER_CHARACTER: _bindgen_ty_1 = 342;
pub const LXB_CSS_VALUE_MIXED: _bindgen_ty_1 = 343;
pub const LXB_CSS_VALUE_UPRIGHT: _bindgen_ty_1 = 344;
pub const LXB_CSS_VALUE_SIDEWAYS: _bindgen_ty_1 = 345;
pub const LXB_CSS_VALUE_ELLIPSIS: _bindgen_ty_1 = 346;
pub const LXB_CSS_VALUE_CAPITALIZE: _bindgen_ty_1 = 347;
pub const LXB_CSS_VALUE_UPPERCASE: _bindgen_ty_1 = 348;
pub const LXB_CSS_VALUE_LOWERCASE: _bindgen_ty_1 = 349;
pub const LXB_CSS_VALUE_FULL_WIDTH: _bindgen_ty_1 = 350;
pub const LXB_CSS_VALUE_FULL_SIZE_KANA: _bindgen_ty_1 = 351;
pub const LXB_CSS_VALUE_EMBED: _bindgen_ty_1 = 352;
pub const LXB_CSS_VALUE_ISOLATE: _bindgen_ty_1 = 353;
pub const LXB_CSS_VALUE_BIDI_OVERRIDE: _bindgen_ty_1 = 354;
pub const LXB_CSS_VALUE_ISOLATE_OVERRIDE: _bindgen_ty_1 = 355;
pub const LXB_CSS_VALUE_PLAINTEXT: _bindgen_ty_1 = 356;
pub const LXB_CSS_VALUE_COLLAPSE: _bindgen_ty_1 = 357;
pub const LXB_CSS_VALUE_PRE: _bindgen_ty_1 = 358;
pub const LXB_CSS_VALUE_PRE_WRAP: _bindgen_ty_1 = 359;
pub const LXB_CSS_VALUE_BREAK_SPACES: _bindgen_ty_1 = 360;
pub const LXB_CSS_VALUE_PRE_LINE: _bindgen_ty_1 = 361;
pub const LXB_CSS_VALUE_KEEP_ALL: _bindgen_ty_1 = 362;
pub const LXB_CSS_VALUE_BREAK_ALL: _bindgen_ty_1 = 363;
pub const LXB_CSS_VALUE_BOTH: _bindgen_ty_1 = 364;
pub const LXB_CSS_VALUE_MINIMUM: _bindgen_ty_1 = 365;
pub const LXB_CSS_VALUE_MAXIMUM: _bindgen_ty_1 = 366;
pub const LXB_CSS_VALUE_CLEAR: _bindgen_ty_1 = 367;
pub const LXB_CSS_VALUE_HORIZONTAL_TB: _bindgen_ty_1 = 368;
pub const LXB_CSS_VALUE_VERTICAL_RL: _bindgen_ty_1 = 369;
pub const LXB_CSS_VALUE_VERTICAL_LR: _bindgen_ty_1 = 370;
pub const LXB_CSS_VALUE_SIDEWAYS_RL: _bindgen_ty_1 = 371;
pub const LXB_CSS_VALUE_SIDEWAYS_LR: _bindgen_ty_1 = 372;
pub const LXB_CSS_VALUE__LAST_ENTRY: _bindgen_ty_1 = 373;
pub type _bindgen_ty_1 = cty::c_int;
pub type lxb_css_value_type_t = cty::c_uint;
pub const LXB_CSS_AT_RULE__UNDEF: _bindgen_ty_2 = 0;
pub const LXB_CSS_AT_RULE__CUSTOM: _bindgen_ty_2 = 1;
pub const LXB_CSS_AT_RULE_MEDIA: _bindgen_ty_2 = 2;
pub const LXB_CSS_AT_RULE_NAMESPACE: _bindgen_ty_2 = 3;
pub const LXB_CSS_AT_RULE__LAST_ENTRY: _bindgen_ty_2 = 4;
pub type _bindgen_ty_2 = cty::c_int;
pub type lxb_css_at_rule_type_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_at_rule__undef_t {
    pub type_: lxb_css_at_rule_type_t,
    pub prelude: lexbor_str_t,
    pub block: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_css_at_rule__undef_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_at_rule__undef_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_at_rule__undef_t>(),
        40usize,
        concat!("Size of: ", stringify!(lxb_css_at_rule__undef_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_at_rule__undef_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_at_rule__undef_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule__undef_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prelude) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule__undef_t),
            "::",
            stringify!(prelude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule__undef_t),
            "::",
            stringify!(block)
        )
    );
}
impl Default for lxb_css_at_rule__undef_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_at_rule__custom_t {
    pub name: lexbor_str_t,
    pub prelude: lexbor_str_t,
    pub block: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_css_at_rule__custom_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_at_rule__custom_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_at_rule__custom_t>(),
        48usize,
        concat!("Size of: ", stringify!(lxb_css_at_rule__custom_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_at_rule__custom_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_at_rule__custom_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule__custom_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prelude) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule__custom_t),
            "::",
            stringify!(prelude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule__custom_t),
            "::",
            stringify!(block)
        )
    );
}
impl Default for lxb_css_at_rule__custom_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_at_rule_media_t {
    pub reserved: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_at_rule_media_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_at_rule_media_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_at_rule_media_t>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_at_rule_media_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_at_rule_media_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_at_rule_media_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule_media_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_at_rule_namespace_t {
    pub reserved: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_at_rule_namespace_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_at_rule_namespace_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_at_rule_namespace_t>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_at_rule_namespace_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_at_rule_namespace_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_at_rule_namespace_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_at_rule_namespace_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn lxb_css_at_rule_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_entry_data_t;
}
extern "C" {
    pub fn lxb_css_at_rule_by_id(id: usize) -> *const lxb_css_entry_data_t;
}
extern "C" {
    pub fn lxb_css_at_rule_destroy(
        memory: *mut lxb_css_memory_t,
        value: *mut cty::c_void,
        type_: lxb_css_at_rule_type_t,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule_serialize(
        style: *const cty::c_void,
        type_: lxb_css_at_rule_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule_serialize_str(
        style: *const cty::c_void,
        type_: lxb_css_at_rule_type_t,
        mraw: *mut lexbor_mraw_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule_serialize_name(
        style: *const cty::c_void,
        type_: lxb_css_at_rule_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule_serialize_name_str(
        style: *const cty::c_void,
        type_: lxb_css_at_rule_type_t,
        mraw: *mut lexbor_mraw_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule__undef_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule__undef_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule__undef_make(
        parser: *mut lxb_css_parser_t,
        undef: *mut lxb_css_at_rule__undef_t,
        at_rule: *const lxb_css_syntax_at_rule_offset_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule__undef_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule__undef_serialize_name(
        at: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule__custom_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule__custom_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule__custom_make(
        parser: *mut lxb_css_parser_t,
        custom: *mut lxb_css_at_rule__custom_t,
        at_rule: *const lxb_css_syntax_at_rule_offset_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule__custom_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule__custom_serialize_name(
        at: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule_media_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule_media_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule_media_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_at_rule_namespace_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule_namespace_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_at_rule_namespace_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_serialize_length_cb(
        data: *const lxb_char_t,
        length: usize,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lexbor_serialize_copy_cb(
        data: *const lxb_char_t,
        length: usize,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
pub const lxb_css_unit_t_LXB_CSS_UNIT__UNDEF: lxb_css_unit_t = 0;
pub const lxb_css_unit_t_LXB_CSS_UNIT__LAST_ENTRY: lxb_css_unit_t = 34;
pub type lxb_css_unit_t = cty::c_int;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_ABSOLUTE__BEGIN: lxb_css_unit_absolute_t = 1;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_Q: lxb_css_unit_absolute_t = 1;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_CM: lxb_css_unit_absolute_t = 2;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_IN: lxb_css_unit_absolute_t = 3;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_MM: lxb_css_unit_absolute_t = 4;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_PC: lxb_css_unit_absolute_t = 5;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_PT: lxb_css_unit_absolute_t = 6;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_PX: lxb_css_unit_absolute_t = 7;
pub const lxb_css_unit_absolute_t_LXB_CSS_UNIT_ABSOLUTE__LAST_ENTRY: lxb_css_unit_absolute_t = 8;
pub type lxb_css_unit_absolute_t = cty::c_int;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_RELATIVE__BEGIN: lxb_css_unit_relative_t = 8;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_CAP: lxb_css_unit_relative_t = 8;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_CH: lxb_css_unit_relative_t = 9;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_EM: lxb_css_unit_relative_t = 10;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_EX: lxb_css_unit_relative_t = 11;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_IC: lxb_css_unit_relative_t = 12;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_LH: lxb_css_unit_relative_t = 13;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_REM: lxb_css_unit_relative_t = 14;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_RLH: lxb_css_unit_relative_t = 15;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_VB: lxb_css_unit_relative_t = 16;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_VH: lxb_css_unit_relative_t = 17;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_VI: lxb_css_unit_relative_t = 18;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_VMAX: lxb_css_unit_relative_t = 19;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_VMIN: lxb_css_unit_relative_t = 20;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_VW: lxb_css_unit_relative_t = 21;
pub const lxb_css_unit_relative_t_LXB_CSS_UNIT_RELATIVE__LAST_ENTRY: lxb_css_unit_relative_t = 22;
pub type lxb_css_unit_relative_t = cty::c_int;
pub const lxb_css_unit_angel_t_LXB_CSS_UNIT_ANGEL__BEGIN: lxb_css_unit_angel_t = 22;
pub const lxb_css_unit_angel_t_LXB_CSS_UNIT_DEG: lxb_css_unit_angel_t = 22;
pub const lxb_css_unit_angel_t_LXB_CSS_UNIT_GRAD: lxb_css_unit_angel_t = 23;
pub const lxb_css_unit_angel_t_LXB_CSS_UNIT_RAD: lxb_css_unit_angel_t = 24;
pub const lxb_css_unit_angel_t_LXB_CSS_UNIT_TURN: lxb_css_unit_angel_t = 25;
pub const lxb_css_unit_angel_t_LXB_CSS_UNIT_ANGEL__LAST_ENTRY: lxb_css_unit_angel_t = 26;
pub type lxb_css_unit_angel_t = cty::c_int;
pub const lxb_css_unit_frequency_t_LXB_CSS_UNIT_FREQUENCY__BEGIN: lxb_css_unit_frequency_t = 26;
pub const lxb_css_unit_frequency_t_LXB_CSS_UNIT_HZ: lxb_css_unit_frequency_t = 26;
pub const lxb_css_unit_frequency_t_LXB_CSS_UNIT_KHZ: lxb_css_unit_frequency_t = 27;
pub const lxb_css_unit_frequency_t_LXB_CSS_UNIT_FREQUENCY__LAST_ENTRY: lxb_css_unit_frequency_t =
    28;
pub type lxb_css_unit_frequency_t = cty::c_int;
pub const lxb_css_unit_resolution_t_LXB_CSS_UNIT_RESOLUTION__BEGIN: lxb_css_unit_resolution_t = 28;
pub const lxb_css_unit_resolution_t_LXB_CSS_UNIT_DPCM: lxb_css_unit_resolution_t = 28;
pub const lxb_css_unit_resolution_t_LXB_CSS_UNIT_DPI: lxb_css_unit_resolution_t = 29;
pub const lxb_css_unit_resolution_t_LXB_CSS_UNIT_DPPX: lxb_css_unit_resolution_t = 30;
pub const lxb_css_unit_resolution_t_LXB_CSS_UNIT_X: lxb_css_unit_resolution_t = 31;
pub const lxb_css_unit_resolution_t_LXB_CSS_UNIT_RESOLUTION__LAST_ENTRY: lxb_css_unit_resolution_t =
    32;
pub type lxb_css_unit_resolution_t = cty::c_int;
pub const lxb_css_unit_duration_t_LXB_CSS_UNIT_DURATION__BEGIN: lxb_css_unit_duration_t = 32;
pub const lxb_css_unit_duration_t_LXB_CSS_UNIT_MS: lxb_css_unit_duration_t = 32;
pub const lxb_css_unit_duration_t_LXB_CSS_UNIT_S: lxb_css_unit_duration_t = 33;
pub const lxb_css_unit_duration_t_LXB_CSS_UNIT_DURATION__LAST_ENTRY: lxb_css_unit_duration_t = 34;
pub type lxb_css_unit_duration_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_value_number_t {
    pub num: f64,
    pub is_float: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_value_number_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_number_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_float) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_t),
            "::",
            stringify!(is_float)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_value_integer_t {
    pub num: cty::c_long,
}
#[test]
fn bindgen_test_layout_lxb_css_value_integer_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_integer_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_integer_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_value_integer_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_integer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_value_integer_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_integer_t),
            "::",
            stringify!(num)
        )
    );
}
pub type lxb_css_value_percentage_t = lxb_css_value_number_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_value_length_t {
    pub num: f64,
    pub is_float: bool,
    pub unit: lxb_css_unit_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_length_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_length_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_length_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_value_length_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_length_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_length_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_float) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_t),
            "::",
            stringify!(is_float)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_t),
            "::",
            stringify!(unit)
        )
    );
}
impl Default for lxb_css_value_length_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_length_percentage_t {
    pub type_: lxb_css_value_type_t,
    pub u: lxb_css_value_length_percentage_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_value_length_percentage_t__bindgen_ty_1 {
    pub length: lxb_css_value_length_t,
    pub percentage: lxb_css_value_percentage_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_length_percentage_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_length_percentage_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_length_percentage_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_value_length_percentage_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_length_percentage_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_length_percentage_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_percentage_t__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_percentage_t__bindgen_ty_1),
            "::",
            stringify!(percentage)
        )
    );
}
impl Default for lxb_css_value_length_percentage_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_value_length_percentage_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_length_percentage_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_length_percentage_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_length_percentage_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_length_percentage_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_length_percentage_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_percentage_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_percentage_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_value_length_percentage_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_number_length_percentage_t {
    pub type_: lxb_css_value_type_t,
    pub u: lxb_css_value_number_length_percentage_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_value_number_length_percentage_t__bindgen_ty_1 {
    pub number: lxb_css_value_number_t,
    pub length: lxb_css_value_length_t,
    pub percentage: lxb_css_value_percentage_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_length_percentage_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_length_percentage_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_length_percentage_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_value_number_length_percentage_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_length_percentage_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_number_length_percentage_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_percentage_t__bindgen_ty_1),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_percentage_t__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_percentage_t__bindgen_ty_1),
            "::",
            stringify!(percentage)
        )
    );
}
impl Default for lxb_css_value_number_length_percentage_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_length_percentage_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_length_percentage_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_length_percentage_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_value_number_length_percentage_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_length_percentage_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_number_length_percentage_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_percentage_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_percentage_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_value_number_length_percentage_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_number_length_t {
    pub type_: lxb_css_value_type_t,
    pub u: lxb_css_value_number_length_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_value_number_length_t__bindgen_ty_1 {
    pub number: lxb_css_value_number_t,
    pub length: lxb_css_value_length_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_length_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_length_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_length_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_value_number_length_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_length_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_number_length_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_t__bindgen_ty_1),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_t__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
}
impl Default for lxb_css_value_number_length_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_length_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_length_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_length_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_number_length_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_length_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_number_length_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_length_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_value_number_length_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_number_percentage_t {
    pub type_: lxb_css_value_type_t,
    pub u: lxb_css_value_number_percentage_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_value_number_percentage_t__bindgen_ty_1 {
    pub number: lxb_css_value_number_t,
    pub percentage: lxb_css_value_percentage_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_percentage_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_percentage_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_percentage_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_value_number_percentage_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_percentage_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_number_percentage_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_percentage_t__bindgen_ty_1),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_percentage_t__bindgen_ty_1),
            "::",
            stringify!(percentage)
        )
    );
}
impl Default for lxb_css_value_number_percentage_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_percentage_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_percentage_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_percentage_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_number_percentage_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_percentage_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_number_percentage_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_percentage_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_percentage_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_value_number_percentage_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_value_number_type_t {
    pub type_: lxb_css_value_type_t,
    pub number: lxb_css_value_number_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_number_type_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_number_type_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_number_type_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_number_type_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_number_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_number_type_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_type_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_number_type_t),
            "::",
            stringify!(number)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_value_integer_type_t {
    pub type_: lxb_css_value_type_t,
    pub integer: lxb_css_value_integer_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_integer_type_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_integer_type_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_integer_type_t>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_value_integer_type_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_integer_type_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_value_integer_type_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_integer_type_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).integer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_integer_type_t),
            "::",
            stringify!(integer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_value_percentage_type_t {
    pub type_: lxb_css_value_type_t,
    pub percentage: lxb_css_value_percentage_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_percentage_type_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_percentage_type_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_percentage_type_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_percentage_type_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_percentage_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_percentage_type_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_percentage_type_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_percentage_type_t),
            "::",
            stringify!(percentage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_value_length_type_t {
    pub type_: lxb_css_value_type_t,
    pub length: lxb_css_value_length_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_length_type_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_length_type_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_length_type_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_length_type_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_length_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_length_type_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_type_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_type_t),
            "::",
            stringify!(length)
        )
    );
}
impl Default for lxb_css_value_length_type_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_length_percentage_type_t {
    pub type_: lxb_css_value_type_t,
    pub length: lxb_css_value_length_percentage_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_length_percentage_type_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_length_percentage_type_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_length_percentage_type_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_value_length_percentage_type_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_length_percentage_type_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_length_percentage_type_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_percentage_type_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_length_percentage_type_t),
            "::",
            stringify!(length)
        )
    );
}
impl Default for lxb_css_value_length_percentage_type_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_value_angle_t {
    pub num: f64,
    pub is_float: bool,
    pub unit: lxb_css_unit_angel_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_angle_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_angle_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_angle_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_value_angle_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_angle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_angle_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_angle_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_float) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_angle_t),
            "::",
            stringify!(is_float)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_angle_t),
            "::",
            stringify!(unit)
        )
    );
}
impl Default for lxb_css_value_angle_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_value_angle_type_t {
    pub type_: lxb_css_value_type_t,
    pub angle: lxb_css_value_angle_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_angle_type_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_angle_type_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_angle_type_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_angle_type_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_angle_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_angle_type_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_angle_type_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_angle_type_t),
            "::",
            stringify!(angle)
        )
    );
}
impl Default for lxb_css_value_angle_type_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_hue_t {
    pub type_: lxb_css_value_type_t,
    pub u: lxb_css_value_hue_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_value_hue_t__bindgen_ty_1 {
    pub number: lxb_css_value_number_t,
    pub angle: lxb_css_value_angle_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_hue_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_hue_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_hue_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_value_hue_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_hue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_hue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_hue_t__bindgen_ty_1),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_hue_t__bindgen_ty_1),
            "::",
            stringify!(angle)
        )
    );
}
impl Default for lxb_css_value_hue_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_value_hue_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_hue_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_hue_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_value_hue_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_hue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_hue_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_hue_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_hue_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_value_hue_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_value_color_hex_rgba_t {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_hex_rgba_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_hex_rgba_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_hex_rgba_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_hex_rgba_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_hex_rgba_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lxb_css_value_color_hex_rgba_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hex_rgba_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hex_rgba_t),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hex_rgba_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hex_rgba_t),
            "::",
            stringify!(a)
        )
    );
}
pub const lxb_css_value_color_hex_type_t_LXB_CSS_PROPERTY_COLOR_HEX_TYPE_3:
    lxb_css_value_color_hex_type_t = 0;
pub const lxb_css_value_color_hex_type_t_LXB_CSS_PROPERTY_COLOR_HEX_TYPE_4:
    lxb_css_value_color_hex_type_t = 1;
pub const lxb_css_value_color_hex_type_t_LXB_CSS_PROPERTY_COLOR_HEX_TYPE_6:
    lxb_css_value_color_hex_type_t = 2;
pub const lxb_css_value_color_hex_type_t_LXB_CSS_PROPERTY_COLOR_HEX_TYPE_8:
    lxb_css_value_color_hex_type_t = 3;
pub type lxb_css_value_color_hex_type_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_value_color_hex_t {
    pub rgba: lxb_css_value_color_hex_rgba_t,
    pub type_: lxb_css_value_color_hex_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_hex_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_hex_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_hex_t>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_hex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_hex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_value_color_hex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rgba) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hex_t),
            "::",
            stringify!(rgba)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hex_t),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for lxb_css_value_color_hex_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_color_rgba_t {
    pub r: lxb_css_value_number_percentage_t,
    pub g: lxb_css_value_number_percentage_t,
    pub b: lxb_css_value_number_percentage_t,
    pub a: lxb_css_value_number_percentage_t,
    pub old: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_rgba_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_rgba_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_rgba_t>(),
        104usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_rgba_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_rgba_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_color_rgba_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_rgba_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_rgba_t),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_rgba_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_rgba_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_rgba_t),
            "::",
            stringify!(old)
        )
    );
}
impl Default for lxb_css_value_color_rgba_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_color_hsla_t {
    pub h: lxb_css_value_hue_t,
    pub s: lxb_css_value_percentage_type_t,
    pub l: lxb_css_value_percentage_type_t,
    pub a: lxb_css_value_number_percentage_t,
    pub old: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_hsla_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_hsla_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_hsla_t>(),
        104usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_hsla_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_hsla_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_color_hsla_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hsla_t),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hsla_t),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hsla_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hsla_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_hsla_t),
            "::",
            stringify!(old)
        )
    );
}
impl Default for lxb_css_value_color_hsla_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_color_lab_t {
    pub l: lxb_css_value_number_percentage_t,
    pub a: lxb_css_value_number_percentage_t,
    pub b: lxb_css_value_number_percentage_t,
    pub alpha: lxb_css_value_number_percentage_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_lab_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_lab_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_lab_t>(),
        96usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_lab_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_lab_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_color_lab_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lab_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lab_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lab_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lab_t),
            "::",
            stringify!(alpha)
        )
    );
}
impl Default for lxb_css_value_color_lab_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_color_lch_t {
    pub l: lxb_css_value_number_percentage_t,
    pub c: lxb_css_value_number_percentage_t,
    pub h: lxb_css_value_hue_t,
    pub a: lxb_css_value_number_percentage_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_lch_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_lch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_lch_t>(),
        96usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_lch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_lch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_color_lch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lch_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lch_t),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lch_t),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_lch_t),
            "::",
            stringify!(a)
        )
    );
}
impl Default for lxb_css_value_color_lch_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_value_color_t {
    pub type_: lxb_css_value_type_t,
    pub u: lxb_css_value_color_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_value_color_t__bindgen_ty_1 {
    pub hex: lxb_css_value_color_hex_t,
    pub rgb: lxb_css_value_color_rgba_t,
    pub hsl: lxb_css_value_color_hsla_t,
    pub hwb: lxb_css_value_color_hsla_t,
    pub lab: lxb_css_value_color_lab_t,
    pub lch: lxb_css_value_color_lch_t,
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_t__bindgen_ty_1>(),
        104usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_value_color_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t__bindgen_ty_1),
            "::",
            stringify!(hex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rgb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t__bindgen_ty_1),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hsl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t__bindgen_ty_1),
            "::",
            stringify!(hsl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t__bindgen_ty_1),
            "::",
            stringify!(hwb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lab) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t__bindgen_ty_1),
            "::",
            stringify!(lab)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t__bindgen_ty_1),
            "::",
            stringify!(lch)
        )
    );
}
impl Default for lxb_css_value_color_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_value_color_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_value_color_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_value_color_t>(),
        112usize,
        concat!("Size of: ", stringify!(lxb_css_value_color_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_value_color_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_value_color_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_value_color_t),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_value_color_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_value_by_id(id: usize) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_value_by_name(name: *const lxb_char_t, length: usize) -> lxb_css_value_type_t;
}
extern "C" {
    pub fn lxb_css_value_serialize(
        type_: lxb_css_value_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_percentage_sr(
        percent: *const lxb_css_value_percentage_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_length_sr(
        len: *const lxb_css_value_length_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_number_sr(
        number: *const lxb_css_value_number_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_integer_sr(
        integer: *const lxb_css_value_integer_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_length_percentage_sr(
        lp: *const lxb_css_value_length_percentage_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_number_length_sr(
        nl: *const lxb_css_value_number_length_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_number_percentage_sr(
        np: *const lxb_css_value_number_percentage_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_length_type_sr(
        lt: *const lxb_css_value_length_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_percentage_type_sr(
        pt: *const lxb_css_value_percentage_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_number_type_sr(
        num: *const lxb_css_value_number_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_integer_type_sr(
        num: *const lxb_css_value_integer_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_length_percentage_type_sr(
        lpt: *const lxb_css_value_length_percentage_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_number_length_percentage_type_sr(
        nlp: *const lxb_css_value_number_length_percentage_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_angle_sr(
        angle: *const lxb_css_value_angle_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_hue_sr(
        hue: *const lxb_css_value_hue_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_value_color_serialize(
        color: *const lxb_css_value_color_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
pub const LXB_CSS_PROPERTY__UNDEF: _bindgen_ty_3 = 0;
pub const LXB_CSS_PROPERTY__CUSTOM: _bindgen_ty_3 = 1;
pub const LXB_CSS_PROPERTY_ALIGN_CONTENT: _bindgen_ty_3 = 2;
pub const LXB_CSS_PROPERTY_ALIGN_ITEMS: _bindgen_ty_3 = 3;
pub const LXB_CSS_PROPERTY_ALIGN_SELF: _bindgen_ty_3 = 4;
pub const LXB_CSS_PROPERTY_ALIGNMENT_BASELINE: _bindgen_ty_3 = 5;
pub const LXB_CSS_PROPERTY_BACKGROUND_COLOR: _bindgen_ty_3 = 6;
pub const LXB_CSS_PROPERTY_BASELINE_SHIFT: _bindgen_ty_3 = 7;
pub const LXB_CSS_PROPERTY_BASELINE_SOURCE: _bindgen_ty_3 = 8;
pub const LXB_CSS_PROPERTY_BORDER: _bindgen_ty_3 = 9;
pub const LXB_CSS_PROPERTY_BORDER_BOTTOM: _bindgen_ty_3 = 10;
pub const LXB_CSS_PROPERTY_BORDER_BOTTOM_COLOR: _bindgen_ty_3 = 11;
pub const LXB_CSS_PROPERTY_BORDER_LEFT: _bindgen_ty_3 = 12;
pub const LXB_CSS_PROPERTY_BORDER_LEFT_COLOR: _bindgen_ty_3 = 13;
pub const LXB_CSS_PROPERTY_BORDER_RIGHT: _bindgen_ty_3 = 14;
pub const LXB_CSS_PROPERTY_BORDER_RIGHT_COLOR: _bindgen_ty_3 = 15;
pub const LXB_CSS_PROPERTY_BORDER_TOP: _bindgen_ty_3 = 16;
pub const LXB_CSS_PROPERTY_BORDER_TOP_COLOR: _bindgen_ty_3 = 17;
pub const LXB_CSS_PROPERTY_BOTTOM: _bindgen_ty_3 = 18;
pub const LXB_CSS_PROPERTY_BOX_SIZING: _bindgen_ty_3 = 19;
pub const LXB_CSS_PROPERTY_CLEAR: _bindgen_ty_3 = 20;
pub const LXB_CSS_PROPERTY_COLOR: _bindgen_ty_3 = 21;
pub const LXB_CSS_PROPERTY_DIRECTION: _bindgen_ty_3 = 22;
pub const LXB_CSS_PROPERTY_DISPLAY: _bindgen_ty_3 = 23;
pub const LXB_CSS_PROPERTY_DOMINANT_BASELINE: _bindgen_ty_3 = 24;
pub const LXB_CSS_PROPERTY_FLEX: _bindgen_ty_3 = 25;
pub const LXB_CSS_PROPERTY_FLEX_BASIS: _bindgen_ty_3 = 26;
pub const LXB_CSS_PROPERTY_FLEX_DIRECTION: _bindgen_ty_3 = 27;
pub const LXB_CSS_PROPERTY_FLEX_FLOW: _bindgen_ty_3 = 28;
pub const LXB_CSS_PROPERTY_FLEX_GROW: _bindgen_ty_3 = 29;
pub const LXB_CSS_PROPERTY_FLEX_SHRINK: _bindgen_ty_3 = 30;
pub const LXB_CSS_PROPERTY_FLEX_WRAP: _bindgen_ty_3 = 31;
pub const LXB_CSS_PROPERTY_FLOAT: _bindgen_ty_3 = 32;
pub const LXB_CSS_PROPERTY_FLOAT_DEFER: _bindgen_ty_3 = 33;
pub const LXB_CSS_PROPERTY_FLOAT_OFFSET: _bindgen_ty_3 = 34;
pub const LXB_CSS_PROPERTY_FLOAT_REFERENCE: _bindgen_ty_3 = 35;
pub const LXB_CSS_PROPERTY_FONT_FAMILY: _bindgen_ty_3 = 36;
pub const LXB_CSS_PROPERTY_FONT_SIZE: _bindgen_ty_3 = 37;
pub const LXB_CSS_PROPERTY_FONT_STRETCH: _bindgen_ty_3 = 38;
pub const LXB_CSS_PROPERTY_FONT_STYLE: _bindgen_ty_3 = 39;
pub const LXB_CSS_PROPERTY_FONT_WEIGHT: _bindgen_ty_3 = 40;
pub const LXB_CSS_PROPERTY_HANGING_PUNCTUATION: _bindgen_ty_3 = 41;
pub const LXB_CSS_PROPERTY_HEIGHT: _bindgen_ty_3 = 42;
pub const LXB_CSS_PROPERTY_HYPHENS: _bindgen_ty_3 = 43;
pub const LXB_CSS_PROPERTY_INSET_BLOCK_END: _bindgen_ty_3 = 44;
pub const LXB_CSS_PROPERTY_INSET_BLOCK_START: _bindgen_ty_3 = 45;
pub const LXB_CSS_PROPERTY_INSET_INLINE_END: _bindgen_ty_3 = 46;
pub const LXB_CSS_PROPERTY_INSET_INLINE_START: _bindgen_ty_3 = 47;
pub const LXB_CSS_PROPERTY_JUSTIFY_CONTENT: _bindgen_ty_3 = 48;
pub const LXB_CSS_PROPERTY_LEFT: _bindgen_ty_3 = 49;
pub const LXB_CSS_PROPERTY_LETTER_SPACING: _bindgen_ty_3 = 50;
pub const LXB_CSS_PROPERTY_LINE_BREAK: _bindgen_ty_3 = 51;
pub const LXB_CSS_PROPERTY_LINE_HEIGHT: _bindgen_ty_3 = 52;
pub const LXB_CSS_PROPERTY_MARGIN: _bindgen_ty_3 = 53;
pub const LXB_CSS_PROPERTY_MARGIN_BOTTOM: _bindgen_ty_3 = 54;
pub const LXB_CSS_PROPERTY_MARGIN_LEFT: _bindgen_ty_3 = 55;
pub const LXB_CSS_PROPERTY_MARGIN_RIGHT: _bindgen_ty_3 = 56;
pub const LXB_CSS_PROPERTY_MARGIN_TOP: _bindgen_ty_3 = 57;
pub const LXB_CSS_PROPERTY_MAX_HEIGHT: _bindgen_ty_3 = 58;
pub const LXB_CSS_PROPERTY_MAX_WIDTH: _bindgen_ty_3 = 59;
pub const LXB_CSS_PROPERTY_MIN_HEIGHT: _bindgen_ty_3 = 60;
pub const LXB_CSS_PROPERTY_MIN_WIDTH: _bindgen_ty_3 = 61;
pub const LXB_CSS_PROPERTY_OPACITY: _bindgen_ty_3 = 62;
pub const LXB_CSS_PROPERTY_ORDER: _bindgen_ty_3 = 63;
pub const LXB_CSS_PROPERTY_OVERFLOW_BLOCK: _bindgen_ty_3 = 64;
pub const LXB_CSS_PROPERTY_OVERFLOW_INLINE: _bindgen_ty_3 = 65;
pub const LXB_CSS_PROPERTY_OVERFLOW_WRAP: _bindgen_ty_3 = 66;
pub const LXB_CSS_PROPERTY_OVERFLOW_X: _bindgen_ty_3 = 67;
pub const LXB_CSS_PROPERTY_OVERFLOW_Y: _bindgen_ty_3 = 68;
pub const LXB_CSS_PROPERTY_PADDING: _bindgen_ty_3 = 69;
pub const LXB_CSS_PROPERTY_PADDING_BOTTOM: _bindgen_ty_3 = 70;
pub const LXB_CSS_PROPERTY_PADDING_LEFT: _bindgen_ty_3 = 71;
pub const LXB_CSS_PROPERTY_PADDING_RIGHT: _bindgen_ty_3 = 72;
pub const LXB_CSS_PROPERTY_PADDING_TOP: _bindgen_ty_3 = 73;
pub const LXB_CSS_PROPERTY_POSITION: _bindgen_ty_3 = 74;
pub const LXB_CSS_PROPERTY_RIGHT: _bindgen_ty_3 = 75;
pub const LXB_CSS_PROPERTY_TAB_SIZE: _bindgen_ty_3 = 76;
pub const LXB_CSS_PROPERTY_TEXT_ALIGN: _bindgen_ty_3 = 77;
pub const LXB_CSS_PROPERTY_TEXT_ALIGN_ALL: _bindgen_ty_3 = 78;
pub const LXB_CSS_PROPERTY_TEXT_ALIGN_LAST: _bindgen_ty_3 = 79;
pub const LXB_CSS_PROPERTY_TEXT_COMBINE_UPRIGHT: _bindgen_ty_3 = 80;
pub const LXB_CSS_PROPERTY_TEXT_DECORATION: _bindgen_ty_3 = 81;
pub const LXB_CSS_PROPERTY_TEXT_DECORATION_COLOR: _bindgen_ty_3 = 82;
pub const LXB_CSS_PROPERTY_TEXT_DECORATION_LINE: _bindgen_ty_3 = 83;
pub const LXB_CSS_PROPERTY_TEXT_DECORATION_STYLE: _bindgen_ty_3 = 84;
pub const LXB_CSS_PROPERTY_TEXT_INDENT: _bindgen_ty_3 = 85;
pub const LXB_CSS_PROPERTY_TEXT_JUSTIFY: _bindgen_ty_3 = 86;
pub const LXB_CSS_PROPERTY_TEXT_ORIENTATION: _bindgen_ty_3 = 87;
pub const LXB_CSS_PROPERTY_TEXT_OVERFLOW: _bindgen_ty_3 = 88;
pub const LXB_CSS_PROPERTY_TEXT_TRANSFORM: _bindgen_ty_3 = 89;
pub const LXB_CSS_PROPERTY_TOP: _bindgen_ty_3 = 90;
pub const LXB_CSS_PROPERTY_UNICODE_BIDI: _bindgen_ty_3 = 91;
pub const LXB_CSS_PROPERTY_VERTICAL_ALIGN: _bindgen_ty_3 = 92;
pub const LXB_CSS_PROPERTY_VISIBILITY: _bindgen_ty_3 = 93;
pub const LXB_CSS_PROPERTY_WHITE_SPACE: _bindgen_ty_3 = 94;
pub const LXB_CSS_PROPERTY_WIDTH: _bindgen_ty_3 = 95;
pub const LXB_CSS_PROPERTY_WORD_BREAK: _bindgen_ty_3 = 96;
pub const LXB_CSS_PROPERTY_WORD_SPACING: _bindgen_ty_3 = 97;
pub const LXB_CSS_PROPERTY_WORD_WRAP: _bindgen_ty_3 = 98;
pub const LXB_CSS_PROPERTY_WRAP_FLOW: _bindgen_ty_3 = 99;
pub const LXB_CSS_PROPERTY_WRAP_THROUGH: _bindgen_ty_3 = 100;
pub const LXB_CSS_PROPERTY_WRITING_MODE: _bindgen_ty_3 = 101;
pub const LXB_CSS_PROPERTY_Z_INDEX: _bindgen_ty_3 = 102;
pub const LXB_CSS_PROPERTY__LAST_ENTRY: _bindgen_ty_3 = 103;
pub type _bindgen_ty_3 = cty::c_int;
pub type lxb_css_property_type_t = usize;
pub const LXB_CSS_ALIGN_CONTENT_FLEX_START: _bindgen_ty_4 = 5;
pub const LXB_CSS_ALIGN_CONTENT_FLEX_END: _bindgen_ty_4 = 6;
pub const LXB_CSS_ALIGN_CONTENT_CENTER: _bindgen_ty_4 = 7;
pub const LXB_CSS_ALIGN_CONTENT_SPACE_BETWEEN: _bindgen_ty_4 = 8;
pub const LXB_CSS_ALIGN_CONTENT_SPACE_AROUND: _bindgen_ty_4 = 9;
pub const LXB_CSS_ALIGN_CONTENT_STRETCH: _bindgen_ty_4 = 10;
pub type _bindgen_ty_4 = cty::c_int;
pub type lxb_css_align_content_type_t = cty::c_uint;
pub const LXB_CSS_ALIGN_ITEMS_FLEX_START: _bindgen_ty_5 = 5;
pub const LXB_CSS_ALIGN_ITEMS_FLEX_END: _bindgen_ty_5 = 6;
pub const LXB_CSS_ALIGN_ITEMS_CENTER: _bindgen_ty_5 = 7;
pub const LXB_CSS_ALIGN_ITEMS_BASELINE: _bindgen_ty_5 = 11;
pub const LXB_CSS_ALIGN_ITEMS_STRETCH: _bindgen_ty_5 = 10;
pub type _bindgen_ty_5 = cty::c_int;
pub type lxb_css_align_items_type_t = cty::c_uint;
pub const LXB_CSS_ALIGN_SELF_AUTO: _bindgen_ty_6 = 12;
pub const LXB_CSS_ALIGN_SELF_FLEX_START: _bindgen_ty_6 = 5;
pub const LXB_CSS_ALIGN_SELF_FLEX_END: _bindgen_ty_6 = 6;
pub const LXB_CSS_ALIGN_SELF_CENTER: _bindgen_ty_6 = 7;
pub const LXB_CSS_ALIGN_SELF_BASELINE: _bindgen_ty_6 = 11;
pub const LXB_CSS_ALIGN_SELF_STRETCH: _bindgen_ty_6 = 10;
pub type _bindgen_ty_6 = cty::c_int;
pub type lxb_css_align_self_type_t = cty::c_uint;
pub const LXB_CSS_ALIGNMENT_BASELINE_BASELINE: _bindgen_ty_7 = 11;
pub const LXB_CSS_ALIGNMENT_BASELINE_TEXT_BOTTOM: _bindgen_ty_7 = 13;
pub const LXB_CSS_ALIGNMENT_BASELINE_ALPHABETIC: _bindgen_ty_7 = 14;
pub const LXB_CSS_ALIGNMENT_BASELINE_IDEOGRAPHIC: _bindgen_ty_7 = 15;
pub const LXB_CSS_ALIGNMENT_BASELINE_MIDDLE: _bindgen_ty_7 = 16;
pub const LXB_CSS_ALIGNMENT_BASELINE_CENTRAL: _bindgen_ty_7 = 17;
pub const LXB_CSS_ALIGNMENT_BASELINE_MATHEMATICAL: _bindgen_ty_7 = 18;
pub const LXB_CSS_ALIGNMENT_BASELINE_TEXT_TOP: _bindgen_ty_7 = 19;
pub type _bindgen_ty_7 = cty::c_int;
pub type lxb_css_alignment_baseline_type_t = cty::c_uint;
pub const LXB_CSS_BASELINE_SHIFT__LENGTH: _bindgen_ty_8 = 20;
pub const LXB_CSS_BASELINE_SHIFT__PERCENTAGE: _bindgen_ty_8 = 21;
pub const LXB_CSS_BASELINE_SHIFT_SUB: _bindgen_ty_8 = 22;
pub const LXB_CSS_BASELINE_SHIFT_SUPER: _bindgen_ty_8 = 23;
pub const LXB_CSS_BASELINE_SHIFT_TOP: _bindgen_ty_8 = 24;
pub const LXB_CSS_BASELINE_SHIFT_CENTER: _bindgen_ty_8 = 7;
pub const LXB_CSS_BASELINE_SHIFT_BOTTOM: _bindgen_ty_8 = 25;
pub type _bindgen_ty_8 = cty::c_int;
pub type lxb_css_baseline_shift_type_t = cty::c_uint;
pub const LXB_CSS_BASELINE_SOURCE_AUTO: _bindgen_ty_9 = 12;
pub const LXB_CSS_BASELINE_SOURCE_FIRST: _bindgen_ty_9 = 26;
pub const LXB_CSS_BASELINE_SOURCE_LAST: _bindgen_ty_9 = 27;
pub type _bindgen_ty_9 = cty::c_int;
pub type lxb_css_baseline_source_type_t = cty::c_uint;
pub const LXB_CSS_BORDER_THIN: _bindgen_ty_10 = 28;
pub const LXB_CSS_BORDER_MEDIUM: _bindgen_ty_10 = 29;
pub const LXB_CSS_BORDER_THICK: _bindgen_ty_10 = 30;
pub const LXB_CSS_BORDER_NONE: _bindgen_ty_10 = 31;
pub const LXB_CSS_BORDER_HIDDEN: _bindgen_ty_10 = 32;
pub const LXB_CSS_BORDER_DOTTED: _bindgen_ty_10 = 33;
pub const LXB_CSS_BORDER_DASHED: _bindgen_ty_10 = 34;
pub const LXB_CSS_BORDER_SOLID: _bindgen_ty_10 = 35;
pub const LXB_CSS_BORDER_DOUBLE: _bindgen_ty_10 = 36;
pub const LXB_CSS_BORDER_GROOVE: _bindgen_ty_10 = 37;
pub const LXB_CSS_BORDER_RIDGE: _bindgen_ty_10 = 38;
pub const LXB_CSS_BORDER_INSET: _bindgen_ty_10 = 39;
pub const LXB_CSS_BORDER_OUTSET: _bindgen_ty_10 = 40;
pub const LXB_CSS_BORDER__LENGTH: _bindgen_ty_10 = 20;
pub type _bindgen_ty_10 = cty::c_int;
pub type lxb_css_border_type_t = cty::c_uint;
pub const LXB_CSS_BORDER_BOTTOM_THIN: _bindgen_ty_11 = 28;
pub const LXB_CSS_BORDER_BOTTOM_MEDIUM: _bindgen_ty_11 = 29;
pub const LXB_CSS_BORDER_BOTTOM_THICK: _bindgen_ty_11 = 30;
pub const LXB_CSS_BORDER_BOTTOM_NONE: _bindgen_ty_11 = 31;
pub const LXB_CSS_BORDER_BOTTOM_HIDDEN: _bindgen_ty_11 = 32;
pub const LXB_CSS_BORDER_BOTTOM_DOTTED: _bindgen_ty_11 = 33;
pub const LXB_CSS_BORDER_BOTTOM_DASHED: _bindgen_ty_11 = 34;
pub const LXB_CSS_BORDER_BOTTOM_SOLID: _bindgen_ty_11 = 35;
pub const LXB_CSS_BORDER_BOTTOM_DOUBLE: _bindgen_ty_11 = 36;
pub const LXB_CSS_BORDER_BOTTOM_GROOVE: _bindgen_ty_11 = 37;
pub const LXB_CSS_BORDER_BOTTOM_RIDGE: _bindgen_ty_11 = 38;
pub const LXB_CSS_BORDER_BOTTOM_INSET: _bindgen_ty_11 = 39;
pub const LXB_CSS_BORDER_BOTTOM_OUTSET: _bindgen_ty_11 = 40;
pub const LXB_CSS_BORDER_BOTTOM__LENGTH: _bindgen_ty_11 = 20;
pub type _bindgen_ty_11 = cty::c_int;
pub type lxb_css_border_bottom_type_t = cty::c_uint;
pub const LXB_CSS_BORDER_LEFT_THIN: _bindgen_ty_12 = 28;
pub const LXB_CSS_BORDER_LEFT_MEDIUM: _bindgen_ty_12 = 29;
pub const LXB_CSS_BORDER_LEFT_THICK: _bindgen_ty_12 = 30;
pub const LXB_CSS_BORDER_LEFT_NONE: _bindgen_ty_12 = 31;
pub const LXB_CSS_BORDER_LEFT_HIDDEN: _bindgen_ty_12 = 32;
pub const LXB_CSS_BORDER_LEFT_DOTTED: _bindgen_ty_12 = 33;
pub const LXB_CSS_BORDER_LEFT_DASHED: _bindgen_ty_12 = 34;
pub const LXB_CSS_BORDER_LEFT_SOLID: _bindgen_ty_12 = 35;
pub const LXB_CSS_BORDER_LEFT_DOUBLE: _bindgen_ty_12 = 36;
pub const LXB_CSS_BORDER_LEFT_GROOVE: _bindgen_ty_12 = 37;
pub const LXB_CSS_BORDER_LEFT_RIDGE: _bindgen_ty_12 = 38;
pub const LXB_CSS_BORDER_LEFT_INSET: _bindgen_ty_12 = 39;
pub const LXB_CSS_BORDER_LEFT_OUTSET: _bindgen_ty_12 = 40;
pub const LXB_CSS_BORDER_LEFT__LENGTH: _bindgen_ty_12 = 20;
pub type _bindgen_ty_12 = cty::c_int;
pub type lxb_css_border_left_type_t = cty::c_uint;
pub const LXB_CSS_BORDER_RIGHT_THIN: _bindgen_ty_13 = 28;
pub const LXB_CSS_BORDER_RIGHT_MEDIUM: _bindgen_ty_13 = 29;
pub const LXB_CSS_BORDER_RIGHT_THICK: _bindgen_ty_13 = 30;
pub const LXB_CSS_BORDER_RIGHT_NONE: _bindgen_ty_13 = 31;
pub const LXB_CSS_BORDER_RIGHT_HIDDEN: _bindgen_ty_13 = 32;
pub const LXB_CSS_BORDER_RIGHT_DOTTED: _bindgen_ty_13 = 33;
pub const LXB_CSS_BORDER_RIGHT_DASHED: _bindgen_ty_13 = 34;
pub const LXB_CSS_BORDER_RIGHT_SOLID: _bindgen_ty_13 = 35;
pub const LXB_CSS_BORDER_RIGHT_DOUBLE: _bindgen_ty_13 = 36;
pub const LXB_CSS_BORDER_RIGHT_GROOVE: _bindgen_ty_13 = 37;
pub const LXB_CSS_BORDER_RIGHT_RIDGE: _bindgen_ty_13 = 38;
pub const LXB_CSS_BORDER_RIGHT_INSET: _bindgen_ty_13 = 39;
pub const LXB_CSS_BORDER_RIGHT_OUTSET: _bindgen_ty_13 = 40;
pub const LXB_CSS_BORDER_RIGHT__LENGTH: _bindgen_ty_13 = 20;
pub type _bindgen_ty_13 = cty::c_int;
pub type lxb_css_border_right_type_t = cty::c_uint;
pub const LXB_CSS_BORDER_TOP_THIN: _bindgen_ty_14 = 28;
pub const LXB_CSS_BORDER_TOP_MEDIUM: _bindgen_ty_14 = 29;
pub const LXB_CSS_BORDER_TOP_THICK: _bindgen_ty_14 = 30;
pub const LXB_CSS_BORDER_TOP_NONE: _bindgen_ty_14 = 31;
pub const LXB_CSS_BORDER_TOP_HIDDEN: _bindgen_ty_14 = 32;
pub const LXB_CSS_BORDER_TOP_DOTTED: _bindgen_ty_14 = 33;
pub const LXB_CSS_BORDER_TOP_DASHED: _bindgen_ty_14 = 34;
pub const LXB_CSS_BORDER_TOP_SOLID: _bindgen_ty_14 = 35;
pub const LXB_CSS_BORDER_TOP_DOUBLE: _bindgen_ty_14 = 36;
pub const LXB_CSS_BORDER_TOP_GROOVE: _bindgen_ty_14 = 37;
pub const LXB_CSS_BORDER_TOP_RIDGE: _bindgen_ty_14 = 38;
pub const LXB_CSS_BORDER_TOP_INSET: _bindgen_ty_14 = 39;
pub const LXB_CSS_BORDER_TOP_OUTSET: _bindgen_ty_14 = 40;
pub const LXB_CSS_BORDER_TOP__LENGTH: _bindgen_ty_14 = 20;
pub type _bindgen_ty_14 = cty::c_int;
pub type lxb_css_border_top_type_t = cty::c_uint;
pub const LXB_CSS_BOTTOM_AUTO: _bindgen_ty_15 = 12;
pub const LXB_CSS_BOTTOM__LENGTH: _bindgen_ty_15 = 20;
pub const LXB_CSS_BOTTOM__PERCENTAGE: _bindgen_ty_15 = 21;
pub type _bindgen_ty_15 = cty::c_int;
pub type lxb_css_bottom_type_t = cty::c_uint;
pub const LXB_CSS_BOX_SIZING_CONTENT_BOX: _bindgen_ty_16 = 41;
pub const LXB_CSS_BOX_SIZING_BORDER_BOX: _bindgen_ty_16 = 42;
pub type _bindgen_ty_16 = cty::c_int;
pub type lxb_css_box_sizing_type_t = cty::c_uint;
pub const LXB_CSS_CLEAR_INLINE_START: _bindgen_ty_17 = 43;
pub const LXB_CSS_CLEAR_INLINE_END: _bindgen_ty_17 = 44;
pub const LXB_CSS_CLEAR_BLOCK_START: _bindgen_ty_17 = 45;
pub const LXB_CSS_CLEAR_BLOCK_END: _bindgen_ty_17 = 46;
pub const LXB_CSS_CLEAR_LEFT: _bindgen_ty_17 = 47;
pub const LXB_CSS_CLEAR_RIGHT: _bindgen_ty_17 = 48;
pub const LXB_CSS_CLEAR_TOP: _bindgen_ty_17 = 24;
pub const LXB_CSS_CLEAR_BOTTOM: _bindgen_ty_17 = 25;
pub const LXB_CSS_CLEAR_NONE: _bindgen_ty_17 = 31;
pub type _bindgen_ty_17 = cty::c_int;
pub type lxb_css_clear_type_t = cty::c_uint;
pub const LXB_CSS_COLOR_CURRENTCOLOR: _bindgen_ty_18 = 49;
pub const LXB_CSS_COLOR_TRANSPARENT: _bindgen_ty_18 = 50;
pub const LXB_CSS_COLOR_HEX: _bindgen_ty_18 = 51;
pub const LXB_CSS_COLOR_ALICEBLUE: _bindgen_ty_18 = 52;
pub const LXB_CSS_COLOR_ANTIQUEWHITE: _bindgen_ty_18 = 53;
pub const LXB_CSS_COLOR_AQUA: _bindgen_ty_18 = 54;
pub const LXB_CSS_COLOR_AQUAMARINE: _bindgen_ty_18 = 55;
pub const LXB_CSS_COLOR_AZURE: _bindgen_ty_18 = 56;
pub const LXB_CSS_COLOR_BEIGE: _bindgen_ty_18 = 57;
pub const LXB_CSS_COLOR_BISQUE: _bindgen_ty_18 = 58;
pub const LXB_CSS_COLOR_BLACK: _bindgen_ty_18 = 59;
pub const LXB_CSS_COLOR_BLANCHEDALMOND: _bindgen_ty_18 = 60;
pub const LXB_CSS_COLOR_BLUE: _bindgen_ty_18 = 61;
pub const LXB_CSS_COLOR_BLUEVIOLET: _bindgen_ty_18 = 62;
pub const LXB_CSS_COLOR_BROWN: _bindgen_ty_18 = 63;
pub const LXB_CSS_COLOR_BURLYWOOD: _bindgen_ty_18 = 64;
pub const LXB_CSS_COLOR_CADETBLUE: _bindgen_ty_18 = 65;
pub const LXB_CSS_COLOR_CHARTREUSE: _bindgen_ty_18 = 66;
pub const LXB_CSS_COLOR_CHOCOLATE: _bindgen_ty_18 = 67;
pub const LXB_CSS_COLOR_CORAL: _bindgen_ty_18 = 68;
pub const LXB_CSS_COLOR_CORNFLOWERBLUE: _bindgen_ty_18 = 69;
pub const LXB_CSS_COLOR_CORNSILK: _bindgen_ty_18 = 70;
pub const LXB_CSS_COLOR_CRIMSON: _bindgen_ty_18 = 71;
pub const LXB_CSS_COLOR_CYAN: _bindgen_ty_18 = 72;
pub const LXB_CSS_COLOR_DARKBLUE: _bindgen_ty_18 = 73;
pub const LXB_CSS_COLOR_DARKCYAN: _bindgen_ty_18 = 74;
pub const LXB_CSS_COLOR_DARKGOLDENROD: _bindgen_ty_18 = 75;
pub const LXB_CSS_COLOR_DARKGRAY: _bindgen_ty_18 = 76;
pub const LXB_CSS_COLOR_DARKGREEN: _bindgen_ty_18 = 77;
pub const LXB_CSS_COLOR_DARKGREY: _bindgen_ty_18 = 78;
pub const LXB_CSS_COLOR_DARKKHAKI: _bindgen_ty_18 = 79;
pub const LXB_CSS_COLOR_DARKMAGENTA: _bindgen_ty_18 = 80;
pub const LXB_CSS_COLOR_DARKOLIVEGREEN: _bindgen_ty_18 = 81;
pub const LXB_CSS_COLOR_DARKORANGE: _bindgen_ty_18 = 82;
pub const LXB_CSS_COLOR_DARKORCHID: _bindgen_ty_18 = 83;
pub const LXB_CSS_COLOR_DARKRED: _bindgen_ty_18 = 84;
pub const LXB_CSS_COLOR_DARKSALMON: _bindgen_ty_18 = 85;
pub const LXB_CSS_COLOR_DARKSEAGREEN: _bindgen_ty_18 = 86;
pub const LXB_CSS_COLOR_DARKSLATEBLUE: _bindgen_ty_18 = 87;
pub const LXB_CSS_COLOR_DARKSLATEGRAY: _bindgen_ty_18 = 88;
pub const LXB_CSS_COLOR_DARKSLATEGREY: _bindgen_ty_18 = 89;
pub const LXB_CSS_COLOR_DARKTURQUOISE: _bindgen_ty_18 = 90;
pub const LXB_CSS_COLOR_DARKVIOLET: _bindgen_ty_18 = 91;
pub const LXB_CSS_COLOR_DEEPPINK: _bindgen_ty_18 = 92;
pub const LXB_CSS_COLOR_DEEPSKYBLUE: _bindgen_ty_18 = 93;
pub const LXB_CSS_COLOR_DIMGRAY: _bindgen_ty_18 = 94;
pub const LXB_CSS_COLOR_DIMGREY: _bindgen_ty_18 = 95;
pub const LXB_CSS_COLOR_DODGERBLUE: _bindgen_ty_18 = 96;
pub const LXB_CSS_COLOR_FIREBRICK: _bindgen_ty_18 = 97;
pub const LXB_CSS_COLOR_FLORALWHITE: _bindgen_ty_18 = 98;
pub const LXB_CSS_COLOR_FORESTGREEN: _bindgen_ty_18 = 99;
pub const LXB_CSS_COLOR_FUCHSIA: _bindgen_ty_18 = 100;
pub const LXB_CSS_COLOR_GAINSBORO: _bindgen_ty_18 = 101;
pub const LXB_CSS_COLOR_GHOSTWHITE: _bindgen_ty_18 = 102;
pub const LXB_CSS_COLOR_GOLD: _bindgen_ty_18 = 103;
pub const LXB_CSS_COLOR_GOLDENROD: _bindgen_ty_18 = 104;
pub const LXB_CSS_COLOR_GRAY: _bindgen_ty_18 = 105;
pub const LXB_CSS_COLOR_GREEN: _bindgen_ty_18 = 106;
pub const LXB_CSS_COLOR_GREENYELLOW: _bindgen_ty_18 = 107;
pub const LXB_CSS_COLOR_GREY: _bindgen_ty_18 = 108;
pub const LXB_CSS_COLOR_HONEYDEW: _bindgen_ty_18 = 109;
pub const LXB_CSS_COLOR_HOTPINK: _bindgen_ty_18 = 110;
pub const LXB_CSS_COLOR_INDIANRED: _bindgen_ty_18 = 111;
pub const LXB_CSS_COLOR_INDIGO: _bindgen_ty_18 = 112;
pub const LXB_CSS_COLOR_IVORY: _bindgen_ty_18 = 113;
pub const LXB_CSS_COLOR_KHAKI: _bindgen_ty_18 = 114;
pub const LXB_CSS_COLOR_LAVENDER: _bindgen_ty_18 = 115;
pub const LXB_CSS_COLOR_LAVENDERBLUSH: _bindgen_ty_18 = 116;
pub const LXB_CSS_COLOR_LAWNGREEN: _bindgen_ty_18 = 117;
pub const LXB_CSS_COLOR_LEMONCHIFFON: _bindgen_ty_18 = 118;
pub const LXB_CSS_COLOR_LIGHTBLUE: _bindgen_ty_18 = 119;
pub const LXB_CSS_COLOR_LIGHTCORAL: _bindgen_ty_18 = 120;
pub const LXB_CSS_COLOR_LIGHTCYAN: _bindgen_ty_18 = 121;
pub const LXB_CSS_COLOR_LIGHTGOLDENRODYELLOW: _bindgen_ty_18 = 122;
pub const LXB_CSS_COLOR_LIGHTGRAY: _bindgen_ty_18 = 123;
pub const LXB_CSS_COLOR_LIGHTGREEN: _bindgen_ty_18 = 124;
pub const LXB_CSS_COLOR_LIGHTGREY: _bindgen_ty_18 = 125;
pub const LXB_CSS_COLOR_LIGHTPINK: _bindgen_ty_18 = 126;
pub const LXB_CSS_COLOR_LIGHTSALMON: _bindgen_ty_18 = 127;
pub const LXB_CSS_COLOR_LIGHTSEAGREEN: _bindgen_ty_18 = 128;
pub const LXB_CSS_COLOR_LIGHTSKYBLUE: _bindgen_ty_18 = 129;
pub const LXB_CSS_COLOR_LIGHTSLATEGRAY: _bindgen_ty_18 = 130;
pub const LXB_CSS_COLOR_LIGHTSLATEGREY: _bindgen_ty_18 = 131;
pub const LXB_CSS_COLOR_LIGHTSTEELBLUE: _bindgen_ty_18 = 132;
pub const LXB_CSS_COLOR_LIGHTYELLOW: _bindgen_ty_18 = 133;
pub const LXB_CSS_COLOR_LIME: _bindgen_ty_18 = 134;
pub const LXB_CSS_COLOR_LIMEGREEN: _bindgen_ty_18 = 135;
pub const LXB_CSS_COLOR_LINEN: _bindgen_ty_18 = 136;
pub const LXB_CSS_COLOR_MAGENTA: _bindgen_ty_18 = 137;
pub const LXB_CSS_COLOR_MAROON: _bindgen_ty_18 = 138;
pub const LXB_CSS_COLOR_MEDIUMAQUAMARINE: _bindgen_ty_18 = 139;
pub const LXB_CSS_COLOR_MEDIUMBLUE: _bindgen_ty_18 = 140;
pub const LXB_CSS_COLOR_MEDIUMORCHID: _bindgen_ty_18 = 141;
pub const LXB_CSS_COLOR_MEDIUMPURPLE: _bindgen_ty_18 = 142;
pub const LXB_CSS_COLOR_MEDIUMSEAGREEN: _bindgen_ty_18 = 143;
pub const LXB_CSS_COLOR_MEDIUMSLATEBLUE: _bindgen_ty_18 = 144;
pub const LXB_CSS_COLOR_MEDIUMSPRINGGREEN: _bindgen_ty_18 = 145;
pub const LXB_CSS_COLOR_MEDIUMTURQUOISE: _bindgen_ty_18 = 146;
pub const LXB_CSS_COLOR_MEDIUMVIOLETRED: _bindgen_ty_18 = 147;
pub const LXB_CSS_COLOR_MIDNIGHTBLUE: _bindgen_ty_18 = 148;
pub const LXB_CSS_COLOR_MINTCREAM: _bindgen_ty_18 = 149;
pub const LXB_CSS_COLOR_MISTYROSE: _bindgen_ty_18 = 150;
pub const LXB_CSS_COLOR_MOCCASIN: _bindgen_ty_18 = 151;
pub const LXB_CSS_COLOR_NAVAJOWHITE: _bindgen_ty_18 = 152;
pub const LXB_CSS_COLOR_NAVY: _bindgen_ty_18 = 153;
pub const LXB_CSS_COLOR_OLDLACE: _bindgen_ty_18 = 154;
pub const LXB_CSS_COLOR_OLIVE: _bindgen_ty_18 = 155;
pub const LXB_CSS_COLOR_OLIVEDRAB: _bindgen_ty_18 = 156;
pub const LXB_CSS_COLOR_ORANGE: _bindgen_ty_18 = 157;
pub const LXB_CSS_COLOR_ORANGERED: _bindgen_ty_18 = 158;
pub const LXB_CSS_COLOR_ORCHID: _bindgen_ty_18 = 159;
pub const LXB_CSS_COLOR_PALEGOLDENROD: _bindgen_ty_18 = 160;
pub const LXB_CSS_COLOR_PALEGREEN: _bindgen_ty_18 = 161;
pub const LXB_CSS_COLOR_PALETURQUOISE: _bindgen_ty_18 = 162;
pub const LXB_CSS_COLOR_PALEVIOLETRED: _bindgen_ty_18 = 163;
pub const LXB_CSS_COLOR_PAPAYAWHIP: _bindgen_ty_18 = 164;
pub const LXB_CSS_COLOR_PEACHPUFF: _bindgen_ty_18 = 165;
pub const LXB_CSS_COLOR_PERU: _bindgen_ty_18 = 166;
pub const LXB_CSS_COLOR_PINK: _bindgen_ty_18 = 167;
pub const LXB_CSS_COLOR_PLUM: _bindgen_ty_18 = 168;
pub const LXB_CSS_COLOR_POWDERBLUE: _bindgen_ty_18 = 169;
pub const LXB_CSS_COLOR_PURPLE: _bindgen_ty_18 = 170;
pub const LXB_CSS_COLOR_REBECCAPURPLE: _bindgen_ty_18 = 171;
pub const LXB_CSS_COLOR_RED: _bindgen_ty_18 = 172;
pub const LXB_CSS_COLOR_ROSYBROWN: _bindgen_ty_18 = 173;
pub const LXB_CSS_COLOR_ROYALBLUE: _bindgen_ty_18 = 174;
pub const LXB_CSS_COLOR_SADDLEBROWN: _bindgen_ty_18 = 175;
pub const LXB_CSS_COLOR_SALMON: _bindgen_ty_18 = 176;
pub const LXB_CSS_COLOR_SANDYBROWN: _bindgen_ty_18 = 177;
pub const LXB_CSS_COLOR_SEAGREEN: _bindgen_ty_18 = 178;
pub const LXB_CSS_COLOR_SEASHELL: _bindgen_ty_18 = 179;
pub const LXB_CSS_COLOR_SIENNA: _bindgen_ty_18 = 180;
pub const LXB_CSS_COLOR_SILVER: _bindgen_ty_18 = 181;
pub const LXB_CSS_COLOR_SKYBLUE: _bindgen_ty_18 = 182;
pub const LXB_CSS_COLOR_SLATEBLUE: _bindgen_ty_18 = 183;
pub const LXB_CSS_COLOR_SLATEGRAY: _bindgen_ty_18 = 184;
pub const LXB_CSS_COLOR_SLATEGREY: _bindgen_ty_18 = 185;
pub const LXB_CSS_COLOR_SNOW: _bindgen_ty_18 = 186;
pub const LXB_CSS_COLOR_SPRINGGREEN: _bindgen_ty_18 = 187;
pub const LXB_CSS_COLOR_STEELBLUE: _bindgen_ty_18 = 188;
pub const LXB_CSS_COLOR_TAN: _bindgen_ty_18 = 189;
pub const LXB_CSS_COLOR_TEAL: _bindgen_ty_18 = 190;
pub const LXB_CSS_COLOR_THISTLE: _bindgen_ty_18 = 191;
pub const LXB_CSS_COLOR_TOMATO: _bindgen_ty_18 = 192;
pub const LXB_CSS_COLOR_TURQUOISE: _bindgen_ty_18 = 193;
pub const LXB_CSS_COLOR_VIOLET: _bindgen_ty_18 = 194;
pub const LXB_CSS_COLOR_WHEAT: _bindgen_ty_18 = 195;
pub const LXB_CSS_COLOR_WHITE: _bindgen_ty_18 = 196;
pub const LXB_CSS_COLOR_WHITESMOKE: _bindgen_ty_18 = 197;
pub const LXB_CSS_COLOR_YELLOW: _bindgen_ty_18 = 198;
pub const LXB_CSS_COLOR_YELLOWGREEN: _bindgen_ty_18 = 199;
pub const LXB_CSS_COLOR_CANVAS: _bindgen_ty_18 = 200;
pub const LXB_CSS_COLOR_CANVASTEXT: _bindgen_ty_18 = 201;
pub const LXB_CSS_COLOR_LINKTEXT: _bindgen_ty_18 = 202;
pub const LXB_CSS_COLOR_VISITEDTEXT: _bindgen_ty_18 = 203;
pub const LXB_CSS_COLOR_ACTIVETEXT: _bindgen_ty_18 = 204;
pub const LXB_CSS_COLOR_BUTTONFACE: _bindgen_ty_18 = 205;
pub const LXB_CSS_COLOR_BUTTONTEXT: _bindgen_ty_18 = 206;
pub const LXB_CSS_COLOR_BUTTONBORDER: _bindgen_ty_18 = 207;
pub const LXB_CSS_COLOR_FIELD: _bindgen_ty_18 = 208;
pub const LXB_CSS_COLOR_FIELDTEXT: _bindgen_ty_18 = 209;
pub const LXB_CSS_COLOR_HIGHLIGHT: _bindgen_ty_18 = 210;
pub const LXB_CSS_COLOR_HIGHLIGHTTEXT: _bindgen_ty_18 = 211;
pub const LXB_CSS_COLOR_SELECTEDITEM: _bindgen_ty_18 = 212;
pub const LXB_CSS_COLOR_SELECTEDITEMTEXT: _bindgen_ty_18 = 213;
pub const LXB_CSS_COLOR_MARK: _bindgen_ty_18 = 214;
pub const LXB_CSS_COLOR_MARKTEXT: _bindgen_ty_18 = 215;
pub const LXB_CSS_COLOR_GRAYTEXT: _bindgen_ty_18 = 216;
pub const LXB_CSS_COLOR_ACCENTCOLOR: _bindgen_ty_18 = 217;
pub const LXB_CSS_COLOR_ACCENTCOLORTEXT: _bindgen_ty_18 = 218;
pub const LXB_CSS_COLOR_RGB: _bindgen_ty_18 = 219;
pub const LXB_CSS_COLOR_RGBA: _bindgen_ty_18 = 220;
pub const LXB_CSS_COLOR_HSL: _bindgen_ty_18 = 221;
pub const LXB_CSS_COLOR_HSLA: _bindgen_ty_18 = 222;
pub const LXB_CSS_COLOR_HWB: _bindgen_ty_18 = 223;
pub const LXB_CSS_COLOR_LAB: _bindgen_ty_18 = 224;
pub const LXB_CSS_COLOR_LCH: _bindgen_ty_18 = 225;
pub const LXB_CSS_COLOR_OKLAB: _bindgen_ty_18 = 226;
pub const LXB_CSS_COLOR_OKLCH: _bindgen_ty_18 = 227;
pub const LXB_CSS_COLOR_COLOR: _bindgen_ty_18 = 228;
pub type _bindgen_ty_18 = cty::c_int;
pub type lxb_css_color_type_t = cty::c_uint;
pub const LXB_CSS_DIRECTION_LTR: _bindgen_ty_19 = 229;
pub const LXB_CSS_DIRECTION_RTL: _bindgen_ty_19 = 230;
pub type _bindgen_ty_19 = cty::c_int;
pub type lxb_css_direction_type_t = cty::c_uint;
pub const LXB_CSS_DISPLAY_BLOCK: _bindgen_ty_20 = 231;
pub const LXB_CSS_DISPLAY_INLINE: _bindgen_ty_20 = 232;
pub const LXB_CSS_DISPLAY_RUN_IN: _bindgen_ty_20 = 233;
pub const LXB_CSS_DISPLAY_FLOW: _bindgen_ty_20 = 234;
pub const LXB_CSS_DISPLAY_FLOW_ROOT: _bindgen_ty_20 = 235;
pub const LXB_CSS_DISPLAY_TABLE: _bindgen_ty_20 = 236;
pub const LXB_CSS_DISPLAY_FLEX: _bindgen_ty_20 = 237;
pub const LXB_CSS_DISPLAY_GRID: _bindgen_ty_20 = 238;
pub const LXB_CSS_DISPLAY_RUBY: _bindgen_ty_20 = 239;
pub const LXB_CSS_DISPLAY_LIST_ITEM: _bindgen_ty_20 = 240;
pub const LXB_CSS_DISPLAY_TABLE_ROW_GROUP: _bindgen_ty_20 = 241;
pub const LXB_CSS_DISPLAY_TABLE_HEADER_GROUP: _bindgen_ty_20 = 242;
pub const LXB_CSS_DISPLAY_TABLE_FOOTER_GROUP: _bindgen_ty_20 = 243;
pub const LXB_CSS_DISPLAY_TABLE_ROW: _bindgen_ty_20 = 244;
pub const LXB_CSS_DISPLAY_TABLE_CELL: _bindgen_ty_20 = 245;
pub const LXB_CSS_DISPLAY_TABLE_COLUMN_GROUP: _bindgen_ty_20 = 246;
pub const LXB_CSS_DISPLAY_TABLE_COLUMN: _bindgen_ty_20 = 247;
pub const LXB_CSS_DISPLAY_TABLE_CAPTION: _bindgen_ty_20 = 248;
pub const LXB_CSS_DISPLAY_RUBY_BASE: _bindgen_ty_20 = 249;
pub const LXB_CSS_DISPLAY_RUBY_TEXT: _bindgen_ty_20 = 250;
pub const LXB_CSS_DISPLAY_RUBY_BASE_CONTAINER: _bindgen_ty_20 = 251;
pub const LXB_CSS_DISPLAY_RUBY_TEXT_CONTAINER: _bindgen_ty_20 = 252;
pub const LXB_CSS_DISPLAY_CONTENTS: _bindgen_ty_20 = 253;
pub const LXB_CSS_DISPLAY_NONE: _bindgen_ty_20 = 31;
pub const LXB_CSS_DISPLAY_INLINE_BLOCK: _bindgen_ty_20 = 254;
pub const LXB_CSS_DISPLAY_INLINE_TABLE: _bindgen_ty_20 = 255;
pub const LXB_CSS_DISPLAY_INLINE_FLEX: _bindgen_ty_20 = 256;
pub const LXB_CSS_DISPLAY_INLINE_GRID: _bindgen_ty_20 = 257;
pub type _bindgen_ty_20 = cty::c_int;
pub type lxb_css_display_type_t = cty::c_uint;
pub const LXB_CSS_DOMINANT_BASELINE_AUTO: _bindgen_ty_21 = 12;
pub const LXB_CSS_DOMINANT_BASELINE_TEXT_BOTTOM: _bindgen_ty_21 = 13;
pub const LXB_CSS_DOMINANT_BASELINE_ALPHABETIC: _bindgen_ty_21 = 14;
pub const LXB_CSS_DOMINANT_BASELINE_IDEOGRAPHIC: _bindgen_ty_21 = 15;
pub const LXB_CSS_DOMINANT_BASELINE_MIDDLE: _bindgen_ty_21 = 16;
pub const LXB_CSS_DOMINANT_BASELINE_CENTRAL: _bindgen_ty_21 = 17;
pub const LXB_CSS_DOMINANT_BASELINE_MATHEMATICAL: _bindgen_ty_21 = 18;
pub const LXB_CSS_DOMINANT_BASELINE_HANGING: _bindgen_ty_21 = 258;
pub const LXB_CSS_DOMINANT_BASELINE_TEXT_TOP: _bindgen_ty_21 = 19;
pub type _bindgen_ty_21 = cty::c_int;
pub type lxb_css_dominant_baseline_type_t = cty::c_uint;
pub const LXB_CSS_FLEX_NONE: _bindgen_ty_22 = 31;
pub type _bindgen_ty_22 = cty::c_int;
pub type lxb_css_flex_type_t = cty::c_uint;
pub const LXB_CSS_FLEX_BASIS_CONTENT: _bindgen_ty_23 = 259;
pub type _bindgen_ty_23 = cty::c_int;
pub type lxb_css_flex_basis_type_t = cty::c_uint;
pub const LXB_CSS_FLEX_DIRECTION_ROW: _bindgen_ty_24 = 260;
pub const LXB_CSS_FLEX_DIRECTION_ROW_REVERSE: _bindgen_ty_24 = 261;
pub const LXB_CSS_FLEX_DIRECTION_COLUMN: _bindgen_ty_24 = 262;
pub const LXB_CSS_FLEX_DIRECTION_COLUMN_REVERSE: _bindgen_ty_24 = 263;
pub type _bindgen_ty_24 = cty::c_int;
pub type lxb_css_flex_direction_type_t = cty::c_uint;
pub const LXB_CSS_FLEX_GROW__NUMBER: _bindgen_ty_25 = 264;
pub type _bindgen_ty_25 = cty::c_int;
pub type lxb_css_flex_grow_type_t = cty::c_uint;
pub const LXB_CSS_FLEX_SHRINK__NUMBER: _bindgen_ty_26 = 264;
pub type _bindgen_ty_26 = cty::c_int;
pub type lxb_css_flex_shrink_type_t = cty::c_uint;
pub const LXB_CSS_FLEX_WRAP_NOWRAP: _bindgen_ty_27 = 265;
pub const LXB_CSS_FLEX_WRAP_WRAP: _bindgen_ty_27 = 266;
pub const LXB_CSS_FLEX_WRAP_WRAP_REVERSE: _bindgen_ty_27 = 267;
pub type _bindgen_ty_27 = cty::c_int;
pub type lxb_css_flex_wrap_type_t = cty::c_uint;
pub const LXB_CSS_FLOAT_BLOCK_START: _bindgen_ty_28 = 45;
pub const LXB_CSS_FLOAT_BLOCK_END: _bindgen_ty_28 = 46;
pub const LXB_CSS_FLOAT_INLINE_START: _bindgen_ty_28 = 43;
pub const LXB_CSS_FLOAT_INLINE_END: _bindgen_ty_28 = 44;
pub const LXB_CSS_FLOAT_SNAP_BLOCK: _bindgen_ty_28 = 268;
pub const LXB_CSS_FLOAT_START: _bindgen_ty_28 = 269;
pub const LXB_CSS_FLOAT_END: _bindgen_ty_28 = 270;
pub const LXB_CSS_FLOAT_NEAR: _bindgen_ty_28 = 271;
pub const LXB_CSS_FLOAT_SNAP_INLINE: _bindgen_ty_28 = 272;
pub const LXB_CSS_FLOAT_LEFT: _bindgen_ty_28 = 47;
pub const LXB_CSS_FLOAT_RIGHT: _bindgen_ty_28 = 48;
pub const LXB_CSS_FLOAT_TOP: _bindgen_ty_28 = 24;
pub const LXB_CSS_FLOAT_BOTTOM: _bindgen_ty_28 = 25;
pub const LXB_CSS_FLOAT_NONE: _bindgen_ty_28 = 31;
pub type _bindgen_ty_28 = cty::c_int;
pub type lxb_css_float_type_t = cty::c_uint;
pub const LXB_CSS_FLOAT_DEFER__INTEGER: _bindgen_ty_29 = 273;
pub const LXB_CSS_FLOAT_DEFER_LAST: _bindgen_ty_29 = 27;
pub const LXB_CSS_FLOAT_DEFER_NONE: _bindgen_ty_29 = 31;
pub type _bindgen_ty_29 = cty::c_int;
pub type lxb_css_float_defer_type_t = cty::c_uint;
pub const LXB_CSS_FLOAT_OFFSET__LENGTH: _bindgen_ty_30 = 20;
pub const LXB_CSS_FLOAT_OFFSET__PERCENTAGE: _bindgen_ty_30 = 21;
pub type _bindgen_ty_30 = cty::c_int;
pub type lxb_css_float_offset_type_t = cty::c_uint;
pub const LXB_CSS_FLOAT_REFERENCE_INLINE: _bindgen_ty_31 = 232;
pub const LXB_CSS_FLOAT_REFERENCE_COLUMN: _bindgen_ty_31 = 262;
pub const LXB_CSS_FLOAT_REFERENCE_REGION: _bindgen_ty_31 = 274;
pub const LXB_CSS_FLOAT_REFERENCE_PAGE: _bindgen_ty_31 = 275;
pub type _bindgen_ty_31 = cty::c_int;
pub type lxb_css_float_reference_type_t = cty::c_uint;
pub const LXB_CSS_FONT_FAMILY_SERIF: _bindgen_ty_32 = 276;
pub const LXB_CSS_FONT_FAMILY_SANS_SERIF: _bindgen_ty_32 = 277;
pub const LXB_CSS_FONT_FAMILY_CURSIVE: _bindgen_ty_32 = 278;
pub const LXB_CSS_FONT_FAMILY_FANTASY: _bindgen_ty_32 = 279;
pub const LXB_CSS_FONT_FAMILY_MONOSPACE: _bindgen_ty_32 = 280;
pub const LXB_CSS_FONT_FAMILY_SYSTEM_UI: _bindgen_ty_32 = 281;
pub const LXB_CSS_FONT_FAMILY_EMOJI: _bindgen_ty_32 = 282;
pub const LXB_CSS_FONT_FAMILY_MATH: _bindgen_ty_32 = 283;
pub const LXB_CSS_FONT_FAMILY_FANGSONG: _bindgen_ty_32 = 284;
pub const LXB_CSS_FONT_FAMILY_UI_SERIF: _bindgen_ty_32 = 285;
pub const LXB_CSS_FONT_FAMILY_UI_SANS_SERIF: _bindgen_ty_32 = 286;
pub const LXB_CSS_FONT_FAMILY_UI_MONOSPACE: _bindgen_ty_32 = 287;
pub const LXB_CSS_FONT_FAMILY_UI_ROUNDED: _bindgen_ty_32 = 288;
pub type _bindgen_ty_32 = cty::c_int;
pub type lxb_css_font_family_type_t = cty::c_uint;
pub const LXB_CSS_FONT_SIZE_XX_SMALL: _bindgen_ty_33 = 289;
pub const LXB_CSS_FONT_SIZE_X_SMALL: _bindgen_ty_33 = 290;
pub const LXB_CSS_FONT_SIZE_SMALL: _bindgen_ty_33 = 291;
pub const LXB_CSS_FONT_SIZE_MEDIUM: _bindgen_ty_33 = 29;
pub const LXB_CSS_FONT_SIZE_LARGE: _bindgen_ty_33 = 292;
pub const LXB_CSS_FONT_SIZE_X_LARGE: _bindgen_ty_33 = 293;
pub const LXB_CSS_FONT_SIZE_XX_LARGE: _bindgen_ty_33 = 294;
pub const LXB_CSS_FONT_SIZE_XXX_LARGE: _bindgen_ty_33 = 295;
pub const LXB_CSS_FONT_SIZE_LARGER: _bindgen_ty_33 = 296;
pub const LXB_CSS_FONT_SIZE_SMALLER: _bindgen_ty_33 = 297;
pub const LXB_CSS_FONT_SIZE_MATH: _bindgen_ty_33 = 283;
pub const LXB_CSS_FONT_SIZE__LENGTH: _bindgen_ty_33 = 20;
pub type _bindgen_ty_33 = cty::c_int;
pub type lxb_css_font_size_type_t = cty::c_uint;
pub const LXB_CSS_FONT_STRETCH_NORMAL: _bindgen_ty_34 = 298;
pub const LXB_CSS_FONT_STRETCH__PERCENTAGE: _bindgen_ty_34 = 21;
pub const LXB_CSS_FONT_STRETCH_ULTRA_CONDENSED: _bindgen_ty_34 = 299;
pub const LXB_CSS_FONT_STRETCH_EXTRA_CONDENSED: _bindgen_ty_34 = 300;
pub const LXB_CSS_FONT_STRETCH_CONDENSED: _bindgen_ty_34 = 301;
pub const LXB_CSS_FONT_STRETCH_SEMI_CONDENSED: _bindgen_ty_34 = 302;
pub const LXB_CSS_FONT_STRETCH_SEMI_EXPANDED: _bindgen_ty_34 = 303;
pub const LXB_CSS_FONT_STRETCH_EXPANDED: _bindgen_ty_34 = 304;
pub const LXB_CSS_FONT_STRETCH_EXTRA_EXPANDED: _bindgen_ty_34 = 305;
pub const LXB_CSS_FONT_STRETCH_ULTRA_EXPANDED: _bindgen_ty_34 = 306;
pub type _bindgen_ty_34 = cty::c_int;
pub type lxb_css_font_stretch_type_t = cty::c_uint;
pub const LXB_CSS_FONT_STYLE_NORMAL: _bindgen_ty_35 = 298;
pub const LXB_CSS_FONT_STYLE_ITALIC: _bindgen_ty_35 = 307;
pub const LXB_CSS_FONT_STYLE_OBLIQUE: _bindgen_ty_35 = 308;
pub type _bindgen_ty_35 = cty::c_int;
pub type lxb_css_font_style_type_t = cty::c_uint;
pub const LXB_CSS_FONT_WEIGHT_NORMAL: _bindgen_ty_36 = 298;
pub const LXB_CSS_FONT_WEIGHT_BOLD: _bindgen_ty_36 = 309;
pub const LXB_CSS_FONT_WEIGHT__NUMBER: _bindgen_ty_36 = 264;
pub const LXB_CSS_FONT_WEIGHT_BOLDER: _bindgen_ty_36 = 310;
pub const LXB_CSS_FONT_WEIGHT_LIGHTER: _bindgen_ty_36 = 311;
pub type _bindgen_ty_36 = cty::c_int;
pub type lxb_css_font_weight_type_t = cty::c_uint;
pub const LXB_CSS_HANGING_PUNCTUATION_NONE: _bindgen_ty_37 = 31;
pub const LXB_CSS_HANGING_PUNCTUATION_FIRST: _bindgen_ty_37 = 26;
pub const LXB_CSS_HANGING_PUNCTUATION_FORCE_END: _bindgen_ty_37 = 312;
pub const LXB_CSS_HANGING_PUNCTUATION_ALLOW_END: _bindgen_ty_37 = 313;
pub const LXB_CSS_HANGING_PUNCTUATION_LAST: _bindgen_ty_37 = 27;
pub type _bindgen_ty_37 = cty::c_int;
pub type lxb_css_hanging_punctuation_type_t = cty::c_uint;
pub const LXB_CSS_HEIGHT_AUTO: _bindgen_ty_38 = 12;
pub const LXB_CSS_HEIGHT_MIN_CONTENT: _bindgen_ty_38 = 314;
pub const LXB_CSS_HEIGHT_MAX_CONTENT: _bindgen_ty_38 = 315;
pub const LXB_CSS_HEIGHT__LENGTH: _bindgen_ty_38 = 20;
pub const LXB_CSS_HEIGHT__PERCENTAGE: _bindgen_ty_38 = 21;
pub const LXB_CSS_HEIGHT__NUMBER: _bindgen_ty_38 = 264;
pub const LXB_CSS_HEIGHT__ANGLE: _bindgen_ty_38 = 316;
pub type _bindgen_ty_38 = cty::c_int;
pub type lxb_css_height_type_t = cty::c_uint;
pub const LXB_CSS_HYPHENS_NONE: _bindgen_ty_39 = 31;
pub const LXB_CSS_HYPHENS_MANUAL: _bindgen_ty_39 = 317;
pub const LXB_CSS_HYPHENS_AUTO: _bindgen_ty_39 = 12;
pub type _bindgen_ty_39 = cty::c_int;
pub type lxb_css_hyphens_type_t = cty::c_uint;
pub const LXB_CSS_INSET_BLOCK_END_AUTO: _bindgen_ty_40 = 12;
pub const LXB_CSS_INSET_BLOCK_END__LENGTH: _bindgen_ty_40 = 20;
pub const LXB_CSS_INSET_BLOCK_END__PERCENTAGE: _bindgen_ty_40 = 21;
pub type _bindgen_ty_40 = cty::c_int;
pub type lxb_css_inset_block_end_type_t = cty::c_uint;
pub const LXB_CSS_INSET_BLOCK_START_AUTO: _bindgen_ty_41 = 12;
pub const LXB_CSS_INSET_BLOCK_START__LENGTH: _bindgen_ty_41 = 20;
pub const LXB_CSS_INSET_BLOCK_START__PERCENTAGE: _bindgen_ty_41 = 21;
pub type _bindgen_ty_41 = cty::c_int;
pub type lxb_css_inset_block_start_type_t = cty::c_uint;
pub const LXB_CSS_INSET_INLINE_END_AUTO: _bindgen_ty_42 = 12;
pub const LXB_CSS_INSET_INLINE_END__LENGTH: _bindgen_ty_42 = 20;
pub const LXB_CSS_INSET_INLINE_END__PERCENTAGE: _bindgen_ty_42 = 21;
pub type _bindgen_ty_42 = cty::c_int;
pub type lxb_css_inset_inline_end_type_t = cty::c_uint;
pub const LXB_CSS_INSET_INLINE_START_AUTO: _bindgen_ty_43 = 12;
pub const LXB_CSS_INSET_INLINE_START__LENGTH: _bindgen_ty_43 = 20;
pub const LXB_CSS_INSET_INLINE_START__PERCENTAGE: _bindgen_ty_43 = 21;
pub type _bindgen_ty_43 = cty::c_int;
pub type lxb_css_inset_inline_start_type_t = cty::c_uint;
pub const LXB_CSS_JUSTIFY_CONTENT_FLEX_START: _bindgen_ty_44 = 5;
pub const LXB_CSS_JUSTIFY_CONTENT_FLEX_END: _bindgen_ty_44 = 6;
pub const LXB_CSS_JUSTIFY_CONTENT_CENTER: _bindgen_ty_44 = 7;
pub const LXB_CSS_JUSTIFY_CONTENT_SPACE_BETWEEN: _bindgen_ty_44 = 8;
pub const LXB_CSS_JUSTIFY_CONTENT_SPACE_AROUND: _bindgen_ty_44 = 9;
pub type _bindgen_ty_44 = cty::c_int;
pub type lxb_css_justify_content_type_t = cty::c_uint;
pub const LXB_CSS_LEFT_AUTO: _bindgen_ty_45 = 12;
pub const LXB_CSS_LEFT__LENGTH: _bindgen_ty_45 = 20;
pub const LXB_CSS_LEFT__PERCENTAGE: _bindgen_ty_45 = 21;
pub type _bindgen_ty_45 = cty::c_int;
pub type lxb_css_left_type_t = cty::c_uint;
pub const LXB_CSS_LETTER_SPACING_NORMAL: _bindgen_ty_46 = 298;
pub const LXB_CSS_LETTER_SPACING__LENGTH: _bindgen_ty_46 = 20;
pub type _bindgen_ty_46 = cty::c_int;
pub type lxb_css_letter_spacing_type_t = cty::c_uint;
pub const LXB_CSS_LINE_BREAK_AUTO: _bindgen_ty_47 = 12;
pub const LXB_CSS_LINE_BREAK_LOOSE: _bindgen_ty_47 = 318;
pub const LXB_CSS_LINE_BREAK_NORMAL: _bindgen_ty_47 = 298;
pub const LXB_CSS_LINE_BREAK_STRICT: _bindgen_ty_47 = 319;
pub const LXB_CSS_LINE_BREAK_ANYWHERE: _bindgen_ty_47 = 320;
pub type _bindgen_ty_47 = cty::c_int;
pub type lxb_css_line_break_type_t = cty::c_uint;
pub const LXB_CSS_LINE_HEIGHT_NORMAL: _bindgen_ty_48 = 298;
pub const LXB_CSS_LINE_HEIGHT__NUMBER: _bindgen_ty_48 = 264;
pub const LXB_CSS_LINE_HEIGHT__LENGTH: _bindgen_ty_48 = 20;
pub const LXB_CSS_LINE_HEIGHT__PERCENTAGE: _bindgen_ty_48 = 21;
pub type _bindgen_ty_48 = cty::c_int;
pub type lxb_css_line_height_type_t = cty::c_uint;
pub const LXB_CSS_MARGIN_AUTO: _bindgen_ty_49 = 12;
pub const LXB_CSS_MARGIN__LENGTH: _bindgen_ty_49 = 20;
pub const LXB_CSS_MARGIN__PERCENTAGE: _bindgen_ty_49 = 21;
pub type _bindgen_ty_49 = cty::c_int;
pub type lxb_css_margin_type_t = cty::c_uint;
pub const LXB_CSS_MARGIN_BOTTOM_AUTO: _bindgen_ty_50 = 12;
pub const LXB_CSS_MARGIN_BOTTOM__LENGTH: _bindgen_ty_50 = 20;
pub const LXB_CSS_MARGIN_BOTTOM__PERCENTAGE: _bindgen_ty_50 = 21;
pub type _bindgen_ty_50 = cty::c_int;
pub type lxb_css_margin_bottom_type_t = cty::c_uint;
pub const LXB_CSS_MARGIN_LEFT_AUTO: _bindgen_ty_51 = 12;
pub const LXB_CSS_MARGIN_LEFT__LENGTH: _bindgen_ty_51 = 20;
pub const LXB_CSS_MARGIN_LEFT__PERCENTAGE: _bindgen_ty_51 = 21;
pub type _bindgen_ty_51 = cty::c_int;
pub type lxb_css_margin_left_type_t = cty::c_uint;
pub const LXB_CSS_MARGIN_RIGHT_AUTO: _bindgen_ty_52 = 12;
pub const LXB_CSS_MARGIN_RIGHT__LENGTH: _bindgen_ty_52 = 20;
pub const LXB_CSS_MARGIN_RIGHT__PERCENTAGE: _bindgen_ty_52 = 21;
pub type _bindgen_ty_52 = cty::c_int;
pub type lxb_css_margin_right_type_t = cty::c_uint;
pub const LXB_CSS_MARGIN_TOP_AUTO: _bindgen_ty_53 = 12;
pub const LXB_CSS_MARGIN_TOP__LENGTH: _bindgen_ty_53 = 20;
pub const LXB_CSS_MARGIN_TOP__PERCENTAGE: _bindgen_ty_53 = 21;
pub type _bindgen_ty_53 = cty::c_int;
pub type lxb_css_margin_top_type_t = cty::c_uint;
pub const LXB_CSS_MAX_HEIGHT_NONE: _bindgen_ty_54 = 31;
pub const LXB_CSS_MAX_HEIGHT_MIN_CONTENT: _bindgen_ty_54 = 314;
pub const LXB_CSS_MAX_HEIGHT_MAX_CONTENT: _bindgen_ty_54 = 315;
pub const LXB_CSS_MAX_HEIGHT__LENGTH: _bindgen_ty_54 = 20;
pub const LXB_CSS_MAX_HEIGHT__PERCENTAGE: _bindgen_ty_54 = 21;
pub const LXB_CSS_MAX_HEIGHT__NUMBER: _bindgen_ty_54 = 264;
pub const LXB_CSS_MAX_HEIGHT__ANGLE: _bindgen_ty_54 = 316;
pub type _bindgen_ty_54 = cty::c_int;
pub type lxb_css_max_height_type_t = cty::c_uint;
pub const LXB_CSS_MAX_WIDTH_NONE: _bindgen_ty_55 = 31;
pub const LXB_CSS_MAX_WIDTH_MIN_CONTENT: _bindgen_ty_55 = 314;
pub const LXB_CSS_MAX_WIDTH_MAX_CONTENT: _bindgen_ty_55 = 315;
pub const LXB_CSS_MAX_WIDTH__LENGTH: _bindgen_ty_55 = 20;
pub const LXB_CSS_MAX_WIDTH__PERCENTAGE: _bindgen_ty_55 = 21;
pub const LXB_CSS_MAX_WIDTH__NUMBER: _bindgen_ty_55 = 264;
pub const LXB_CSS_MAX_WIDTH__ANGLE: _bindgen_ty_55 = 316;
pub type _bindgen_ty_55 = cty::c_int;
pub type lxb_css_max_width_type_t = cty::c_uint;
pub const LXB_CSS_MIN_HEIGHT_AUTO: _bindgen_ty_56 = 12;
pub const LXB_CSS_MIN_HEIGHT_MIN_CONTENT: _bindgen_ty_56 = 314;
pub const LXB_CSS_MIN_HEIGHT_MAX_CONTENT: _bindgen_ty_56 = 315;
pub const LXB_CSS_MIN_HEIGHT__LENGTH: _bindgen_ty_56 = 20;
pub const LXB_CSS_MIN_HEIGHT__PERCENTAGE: _bindgen_ty_56 = 21;
pub const LXB_CSS_MIN_HEIGHT__NUMBER: _bindgen_ty_56 = 264;
pub const LXB_CSS_MIN_HEIGHT__ANGLE: _bindgen_ty_56 = 316;
pub type _bindgen_ty_56 = cty::c_int;
pub type lxb_css_min_height_type_t = cty::c_uint;
pub const LXB_CSS_MIN_WIDTH_AUTO: _bindgen_ty_57 = 12;
pub const LXB_CSS_MIN_WIDTH_MIN_CONTENT: _bindgen_ty_57 = 314;
pub const LXB_CSS_MIN_WIDTH_MAX_CONTENT: _bindgen_ty_57 = 315;
pub const LXB_CSS_MIN_WIDTH__LENGTH: _bindgen_ty_57 = 20;
pub const LXB_CSS_MIN_WIDTH__PERCENTAGE: _bindgen_ty_57 = 21;
pub const LXB_CSS_MIN_WIDTH__NUMBER: _bindgen_ty_57 = 264;
pub const LXB_CSS_MIN_WIDTH__ANGLE: _bindgen_ty_57 = 316;
pub type _bindgen_ty_57 = cty::c_int;
pub type lxb_css_min_width_type_t = cty::c_uint;
pub const LXB_CSS_OPACITY__NUMBER: _bindgen_ty_58 = 264;
pub const LXB_CSS_OPACITY__PERCENTAGE: _bindgen_ty_58 = 21;
pub type _bindgen_ty_58 = cty::c_int;
pub type lxb_css_opacity_type_t = cty::c_uint;
pub const LXB_CSS_ORDER__INTEGER: _bindgen_ty_59 = 273;
pub type _bindgen_ty_59 = cty::c_int;
pub type lxb_css_order_type_t = cty::c_uint;
pub const LXB_CSS_OVERFLOW_BLOCK_VISIBLE: _bindgen_ty_60 = 321;
pub const LXB_CSS_OVERFLOW_BLOCK_HIDDEN: _bindgen_ty_60 = 32;
pub const LXB_CSS_OVERFLOW_BLOCK_CLIP: _bindgen_ty_60 = 322;
pub const LXB_CSS_OVERFLOW_BLOCK_SCROLL: _bindgen_ty_60 = 323;
pub const LXB_CSS_OVERFLOW_BLOCK_AUTO: _bindgen_ty_60 = 12;
pub type _bindgen_ty_60 = cty::c_int;
pub type lxb_css_overflow_block_type_t = cty::c_uint;
pub const LXB_CSS_OVERFLOW_INLINE_VISIBLE: _bindgen_ty_61 = 321;
pub const LXB_CSS_OVERFLOW_INLINE_HIDDEN: _bindgen_ty_61 = 32;
pub const LXB_CSS_OVERFLOW_INLINE_CLIP: _bindgen_ty_61 = 322;
pub const LXB_CSS_OVERFLOW_INLINE_SCROLL: _bindgen_ty_61 = 323;
pub const LXB_CSS_OVERFLOW_INLINE_AUTO: _bindgen_ty_61 = 12;
pub type _bindgen_ty_61 = cty::c_int;
pub type lxb_css_overflow_inline_type_t = cty::c_uint;
pub const LXB_CSS_OVERFLOW_WRAP_NORMAL: _bindgen_ty_62 = 298;
pub const LXB_CSS_OVERFLOW_WRAP_BREAK_WORD: _bindgen_ty_62 = 324;
pub const LXB_CSS_OVERFLOW_WRAP_ANYWHERE: _bindgen_ty_62 = 320;
pub type _bindgen_ty_62 = cty::c_int;
pub type lxb_css_overflow_wrap_type_t = cty::c_uint;
pub const LXB_CSS_OVERFLOW_X_VISIBLE: _bindgen_ty_63 = 321;
pub const LXB_CSS_OVERFLOW_X_HIDDEN: _bindgen_ty_63 = 32;
pub const LXB_CSS_OVERFLOW_X_CLIP: _bindgen_ty_63 = 322;
pub const LXB_CSS_OVERFLOW_X_SCROLL: _bindgen_ty_63 = 323;
pub const LXB_CSS_OVERFLOW_X_AUTO: _bindgen_ty_63 = 12;
pub type _bindgen_ty_63 = cty::c_int;
pub type lxb_css_overflow_x_type_t = cty::c_uint;
pub const LXB_CSS_OVERFLOW_Y_VISIBLE: _bindgen_ty_64 = 321;
pub const LXB_CSS_OVERFLOW_Y_HIDDEN: _bindgen_ty_64 = 32;
pub const LXB_CSS_OVERFLOW_Y_CLIP: _bindgen_ty_64 = 322;
pub const LXB_CSS_OVERFLOW_Y_SCROLL: _bindgen_ty_64 = 323;
pub const LXB_CSS_OVERFLOW_Y_AUTO: _bindgen_ty_64 = 12;
pub type _bindgen_ty_64 = cty::c_int;
pub type lxb_css_overflow_y_type_t = cty::c_uint;
pub const LXB_CSS_PADDING_AUTO: _bindgen_ty_65 = 12;
pub const LXB_CSS_PADDING__LENGTH: _bindgen_ty_65 = 20;
pub const LXB_CSS_PADDING__PERCENTAGE: _bindgen_ty_65 = 21;
pub type _bindgen_ty_65 = cty::c_int;
pub type lxb_css_padding_type_t = cty::c_uint;
pub const LXB_CSS_PADDING_BOTTOM_AUTO: _bindgen_ty_66 = 12;
pub const LXB_CSS_PADDING_BOTTOM__LENGTH: _bindgen_ty_66 = 20;
pub const LXB_CSS_PADDING_BOTTOM__PERCENTAGE: _bindgen_ty_66 = 21;
pub type _bindgen_ty_66 = cty::c_int;
pub type lxb_css_padding_bottom_type_t = cty::c_uint;
pub const LXB_CSS_PADDING_LEFT_AUTO: _bindgen_ty_67 = 12;
pub const LXB_CSS_PADDING_LEFT__LENGTH: _bindgen_ty_67 = 20;
pub const LXB_CSS_PADDING_LEFT__PERCENTAGE: _bindgen_ty_67 = 21;
pub type _bindgen_ty_67 = cty::c_int;
pub type lxb_css_padding_left_type_t = cty::c_uint;
pub const LXB_CSS_PADDING_RIGHT_AUTO: _bindgen_ty_68 = 12;
pub const LXB_CSS_PADDING_RIGHT__LENGTH: _bindgen_ty_68 = 20;
pub const LXB_CSS_PADDING_RIGHT__PERCENTAGE: _bindgen_ty_68 = 21;
pub type _bindgen_ty_68 = cty::c_int;
pub type lxb_css_padding_right_type_t = cty::c_uint;
pub const LXB_CSS_PADDING_TOP_AUTO: _bindgen_ty_69 = 12;
pub const LXB_CSS_PADDING_TOP__LENGTH: _bindgen_ty_69 = 20;
pub const LXB_CSS_PADDING_TOP__PERCENTAGE: _bindgen_ty_69 = 21;
pub type _bindgen_ty_69 = cty::c_int;
pub type lxb_css_padding_top_type_t = cty::c_uint;
pub const LXB_CSS_POSITION_STATIC: _bindgen_ty_70 = 325;
pub const LXB_CSS_POSITION_RELATIVE: _bindgen_ty_70 = 326;
pub const LXB_CSS_POSITION_ABSOLUTE: _bindgen_ty_70 = 327;
pub const LXB_CSS_POSITION_STICKY: _bindgen_ty_70 = 328;
pub const LXB_CSS_POSITION_FIXED: _bindgen_ty_70 = 329;
pub type _bindgen_ty_70 = cty::c_int;
pub type lxb_css_position_type_t = cty::c_uint;
pub const LXB_CSS_RIGHT_AUTO: _bindgen_ty_71 = 12;
pub const LXB_CSS_RIGHT__LENGTH: _bindgen_ty_71 = 20;
pub const LXB_CSS_RIGHT__PERCENTAGE: _bindgen_ty_71 = 21;
pub type _bindgen_ty_71 = cty::c_int;
pub type lxb_css_right_type_t = cty::c_uint;
pub const LXB_CSS_TAB_SIZE__NUMBER: _bindgen_ty_72 = 264;
pub const LXB_CSS_TAB_SIZE__LENGTH: _bindgen_ty_72 = 20;
pub type _bindgen_ty_72 = cty::c_int;
pub type lxb_css_tab_size_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_ALIGN_START: _bindgen_ty_73 = 269;
pub const LXB_CSS_TEXT_ALIGN_END: _bindgen_ty_73 = 270;
pub const LXB_CSS_TEXT_ALIGN_LEFT: _bindgen_ty_73 = 47;
pub const LXB_CSS_TEXT_ALIGN_RIGHT: _bindgen_ty_73 = 48;
pub const LXB_CSS_TEXT_ALIGN_CENTER: _bindgen_ty_73 = 7;
pub const LXB_CSS_TEXT_ALIGN_JUSTIFY: _bindgen_ty_73 = 330;
pub const LXB_CSS_TEXT_ALIGN_MATCH_PARENT: _bindgen_ty_73 = 331;
pub const LXB_CSS_TEXT_ALIGN_JUSTIFY_ALL: _bindgen_ty_73 = 332;
pub type _bindgen_ty_73 = cty::c_int;
pub type lxb_css_text_align_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_ALIGN_ALL_START: _bindgen_ty_74 = 269;
pub const LXB_CSS_TEXT_ALIGN_ALL_END: _bindgen_ty_74 = 270;
pub const LXB_CSS_TEXT_ALIGN_ALL_LEFT: _bindgen_ty_74 = 47;
pub const LXB_CSS_TEXT_ALIGN_ALL_RIGHT: _bindgen_ty_74 = 48;
pub const LXB_CSS_TEXT_ALIGN_ALL_CENTER: _bindgen_ty_74 = 7;
pub const LXB_CSS_TEXT_ALIGN_ALL_JUSTIFY: _bindgen_ty_74 = 330;
pub const LXB_CSS_TEXT_ALIGN_ALL_MATCH_PARENT: _bindgen_ty_74 = 331;
pub type _bindgen_ty_74 = cty::c_int;
pub type lxb_css_text_align_all_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_ALIGN_LAST_AUTO: _bindgen_ty_75 = 12;
pub const LXB_CSS_TEXT_ALIGN_LAST_START: _bindgen_ty_75 = 269;
pub const LXB_CSS_TEXT_ALIGN_LAST_END: _bindgen_ty_75 = 270;
pub const LXB_CSS_TEXT_ALIGN_LAST_LEFT: _bindgen_ty_75 = 47;
pub const LXB_CSS_TEXT_ALIGN_LAST_RIGHT: _bindgen_ty_75 = 48;
pub const LXB_CSS_TEXT_ALIGN_LAST_CENTER: _bindgen_ty_75 = 7;
pub const LXB_CSS_TEXT_ALIGN_LAST_JUSTIFY: _bindgen_ty_75 = 330;
pub const LXB_CSS_TEXT_ALIGN_LAST_MATCH_PARENT: _bindgen_ty_75 = 331;
pub type _bindgen_ty_75 = cty::c_int;
pub type lxb_css_text_align_last_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_COMBINE_UPRIGHT_NONE: _bindgen_ty_76 = 31;
pub const LXB_CSS_TEXT_COMBINE_UPRIGHT_ALL: _bindgen_ty_76 = 333;
pub const LXB_CSS_TEXT_COMBINE_UPRIGHT_DIGITS: _bindgen_ty_76 = 334;
pub type _bindgen_ty_76 = cty::c_int;
pub type lxb_css_text_combine_upright_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_DECORATION_LINE_NONE: _bindgen_ty_77 = 31;
pub const LXB_CSS_TEXT_DECORATION_LINE_UNDERLINE: _bindgen_ty_77 = 335;
pub const LXB_CSS_TEXT_DECORATION_LINE_OVERLINE: _bindgen_ty_77 = 336;
pub const LXB_CSS_TEXT_DECORATION_LINE_LINE_THROUGH: _bindgen_ty_77 = 337;
pub const LXB_CSS_TEXT_DECORATION_LINE_BLINK: _bindgen_ty_77 = 338;
pub type _bindgen_ty_77 = cty::c_int;
pub type lxb_css_text_decoration_line_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_DECORATION_STYLE_SOLID: _bindgen_ty_78 = 35;
pub const LXB_CSS_TEXT_DECORATION_STYLE_DOUBLE: _bindgen_ty_78 = 36;
pub const LXB_CSS_TEXT_DECORATION_STYLE_DOTTED: _bindgen_ty_78 = 33;
pub const LXB_CSS_TEXT_DECORATION_STYLE_DASHED: _bindgen_ty_78 = 34;
pub const LXB_CSS_TEXT_DECORATION_STYLE_WAVY: _bindgen_ty_78 = 339;
pub type _bindgen_ty_78 = cty::c_int;
pub type lxb_css_text_decoration_style_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_INDENT__LENGTH: _bindgen_ty_79 = 20;
pub const LXB_CSS_TEXT_INDENT__PERCENTAGE: _bindgen_ty_79 = 21;
pub const LXB_CSS_TEXT_INDENT_HANGING: _bindgen_ty_79 = 258;
pub const LXB_CSS_TEXT_INDENT_EACH_LINE: _bindgen_ty_79 = 340;
pub type _bindgen_ty_79 = cty::c_int;
pub type lxb_css_text_indent_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_JUSTIFY_AUTO: _bindgen_ty_80 = 12;
pub const LXB_CSS_TEXT_JUSTIFY_NONE: _bindgen_ty_80 = 31;
pub const LXB_CSS_TEXT_JUSTIFY_INTER_WORD: _bindgen_ty_80 = 341;
pub const LXB_CSS_TEXT_JUSTIFY_INTER_CHARACTER: _bindgen_ty_80 = 342;
pub type _bindgen_ty_80 = cty::c_int;
pub type lxb_css_text_justify_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_ORIENTATION_MIXED: _bindgen_ty_81 = 343;
pub const LXB_CSS_TEXT_ORIENTATION_UPRIGHT: _bindgen_ty_81 = 344;
pub const LXB_CSS_TEXT_ORIENTATION_SIDEWAYS: _bindgen_ty_81 = 345;
pub type _bindgen_ty_81 = cty::c_int;
pub type lxb_css_text_orientation_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_OVERFLOW_CLIP: _bindgen_ty_82 = 322;
pub const LXB_CSS_TEXT_OVERFLOW_ELLIPSIS: _bindgen_ty_82 = 346;
pub type _bindgen_ty_82 = cty::c_int;
pub type lxb_css_text_overflow_type_t = cty::c_uint;
pub const LXB_CSS_TEXT_TRANSFORM_NONE: _bindgen_ty_83 = 31;
pub const LXB_CSS_TEXT_TRANSFORM_CAPITALIZE: _bindgen_ty_83 = 347;
pub const LXB_CSS_TEXT_TRANSFORM_UPPERCASE: _bindgen_ty_83 = 348;
pub const LXB_CSS_TEXT_TRANSFORM_LOWERCASE: _bindgen_ty_83 = 349;
pub const LXB_CSS_TEXT_TRANSFORM_FULL_WIDTH: _bindgen_ty_83 = 350;
pub const LXB_CSS_TEXT_TRANSFORM_FULL_SIZE_KANA: _bindgen_ty_83 = 351;
pub type _bindgen_ty_83 = cty::c_int;
pub type lxb_css_text_transform_type_t = cty::c_uint;
pub const LXB_CSS_TOP_AUTO: _bindgen_ty_84 = 12;
pub const LXB_CSS_TOP__LENGTH: _bindgen_ty_84 = 20;
pub const LXB_CSS_TOP__PERCENTAGE: _bindgen_ty_84 = 21;
pub type _bindgen_ty_84 = cty::c_int;
pub type lxb_css_top_type_t = cty::c_uint;
pub const LXB_CSS_UNICODE_BIDI_NORMAL: _bindgen_ty_85 = 298;
pub const LXB_CSS_UNICODE_BIDI_EMBED: _bindgen_ty_85 = 352;
pub const LXB_CSS_UNICODE_BIDI_ISOLATE: _bindgen_ty_85 = 353;
pub const LXB_CSS_UNICODE_BIDI_BIDI_OVERRIDE: _bindgen_ty_85 = 354;
pub const LXB_CSS_UNICODE_BIDI_ISOLATE_OVERRIDE: _bindgen_ty_85 = 355;
pub const LXB_CSS_UNICODE_BIDI_PLAINTEXT: _bindgen_ty_85 = 356;
pub type _bindgen_ty_85 = cty::c_int;
pub type lxb_css_unicode_bidi_type_t = cty::c_uint;
pub const LXB_CSS_VERTICAL_ALIGN_FIRST: _bindgen_ty_86 = 26;
pub const LXB_CSS_VERTICAL_ALIGN_LAST: _bindgen_ty_86 = 27;
pub type _bindgen_ty_86 = cty::c_int;
pub type lxb_css_vertical_align_type_t = cty::c_uint;
pub const LXB_CSS_VISIBILITY_VISIBLE: _bindgen_ty_87 = 321;
pub const LXB_CSS_VISIBILITY_HIDDEN: _bindgen_ty_87 = 32;
pub const LXB_CSS_VISIBILITY_COLLAPSE: _bindgen_ty_87 = 357;
pub type _bindgen_ty_87 = cty::c_int;
pub type lxb_css_visibility_type_t = cty::c_uint;
pub const LXB_CSS_WHITE_SPACE_NORMAL: _bindgen_ty_88 = 298;
pub const LXB_CSS_WHITE_SPACE_PRE: _bindgen_ty_88 = 358;
pub const LXB_CSS_WHITE_SPACE_NOWRAP: _bindgen_ty_88 = 265;
pub const LXB_CSS_WHITE_SPACE_PRE_WRAP: _bindgen_ty_88 = 359;
pub const LXB_CSS_WHITE_SPACE_BREAK_SPACES: _bindgen_ty_88 = 360;
pub const LXB_CSS_WHITE_SPACE_PRE_LINE: _bindgen_ty_88 = 361;
pub type _bindgen_ty_88 = cty::c_int;
pub type lxb_css_white_space_type_t = cty::c_uint;
pub const LXB_CSS_WIDTH_AUTO: _bindgen_ty_89 = 12;
pub const LXB_CSS_WIDTH_MIN_CONTENT: _bindgen_ty_89 = 314;
pub const LXB_CSS_WIDTH_MAX_CONTENT: _bindgen_ty_89 = 315;
pub const LXB_CSS_WIDTH__LENGTH: _bindgen_ty_89 = 20;
pub const LXB_CSS_WIDTH__PERCENTAGE: _bindgen_ty_89 = 21;
pub const LXB_CSS_WIDTH__NUMBER: _bindgen_ty_89 = 264;
pub const LXB_CSS_WIDTH__ANGLE: _bindgen_ty_89 = 316;
pub type _bindgen_ty_89 = cty::c_int;
pub type lxb_css_width_type_t = cty::c_uint;
pub const LXB_CSS_WORD_BREAK_NORMAL: _bindgen_ty_90 = 298;
pub const LXB_CSS_WORD_BREAK_KEEP_ALL: _bindgen_ty_90 = 362;
pub const LXB_CSS_WORD_BREAK_BREAK_ALL: _bindgen_ty_90 = 363;
pub const LXB_CSS_WORD_BREAK_BREAK_WORD: _bindgen_ty_90 = 324;
pub type _bindgen_ty_90 = cty::c_int;
pub type lxb_css_word_break_type_t = cty::c_uint;
pub const LXB_CSS_WORD_SPACING_NORMAL: _bindgen_ty_91 = 298;
pub const LXB_CSS_WORD_SPACING__LENGTH: _bindgen_ty_91 = 20;
pub type _bindgen_ty_91 = cty::c_int;
pub type lxb_css_word_spacing_type_t = cty::c_uint;
pub const LXB_CSS_WORD_WRAP_NORMAL: _bindgen_ty_92 = 298;
pub const LXB_CSS_WORD_WRAP_BREAK_WORD: _bindgen_ty_92 = 324;
pub const LXB_CSS_WORD_WRAP_ANYWHERE: _bindgen_ty_92 = 320;
pub type _bindgen_ty_92 = cty::c_int;
pub type lxb_css_word_wrap_type_t = cty::c_uint;
pub const LXB_CSS_WRAP_FLOW_AUTO: _bindgen_ty_93 = 12;
pub const LXB_CSS_WRAP_FLOW_BOTH: _bindgen_ty_93 = 364;
pub const LXB_CSS_WRAP_FLOW_START: _bindgen_ty_93 = 269;
pub const LXB_CSS_WRAP_FLOW_END: _bindgen_ty_93 = 270;
pub const LXB_CSS_WRAP_FLOW_MINIMUM: _bindgen_ty_93 = 365;
pub const LXB_CSS_WRAP_FLOW_MAXIMUM: _bindgen_ty_93 = 366;
pub const LXB_CSS_WRAP_FLOW_CLEAR: _bindgen_ty_93 = 367;
pub type _bindgen_ty_93 = cty::c_int;
pub type lxb_css_wrap_flow_type_t = cty::c_uint;
pub const LXB_CSS_WRAP_THROUGH_WRAP: _bindgen_ty_94 = 266;
pub const LXB_CSS_WRAP_THROUGH_NONE: _bindgen_ty_94 = 31;
pub type _bindgen_ty_94 = cty::c_int;
pub type lxb_css_wrap_through_type_t = cty::c_uint;
pub const LXB_CSS_WRITING_MODE_HORIZONTAL_TB: _bindgen_ty_95 = 368;
pub const LXB_CSS_WRITING_MODE_VERTICAL_RL: _bindgen_ty_95 = 369;
pub const LXB_CSS_WRITING_MODE_VERTICAL_LR: _bindgen_ty_95 = 370;
pub const LXB_CSS_WRITING_MODE_SIDEWAYS_RL: _bindgen_ty_95 = 371;
pub const LXB_CSS_WRITING_MODE_SIDEWAYS_LR: _bindgen_ty_95 = 372;
pub type _bindgen_ty_95 = cty::c_int;
pub type lxb_css_writing_mode_type_t = cty::c_uint;
pub const LXB_CSS_Z_INDEX_AUTO: _bindgen_ty_96 = 12;
pub const LXB_CSS_Z_INDEX__INTEGER: _bindgen_ty_96 = 273;
pub type _bindgen_ty_96 = cty::c_int;
pub type lxb_css_z_index_type_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_property__undef_t {
    pub type_: lxb_css_property_type_t,
    pub value: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property__undef_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property__undef_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property__undef_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_property__undef_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property__undef_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property__undef_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property__undef_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property__undef_t),
            "::",
            stringify!(value)
        )
    );
}
impl Default for lxb_css_property__undef_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_property__custom_t {
    pub name: lexbor_str_t,
    pub value: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property__custom_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property__custom_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property__custom_t>(),
        32usize,
        concat!("Size of: ", stringify!(lxb_css_property__custom_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property__custom_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property__custom_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property__custom_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property__custom_t),
            "::",
            stringify!(value)
        )
    );
}
impl Default for lxb_css_property__custom_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_display_t {
    pub a: lxb_css_display_type_t,
    pub b: lxb_css_display_type_t,
    pub c: lxb_css_display_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_display_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_display_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_display_t>(),
        12usize,
        concat!("Size of: ", stringify!(lxb_css_property_display_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_display_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_display_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_display_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_display_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_display_t),
            "::",
            stringify!(c)
        )
    );
}
pub type lxb_css_property_order_t = lxb_css_value_integer_type_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_visibility_t {
    pub type_: lxb_css_visibility_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_visibility_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_visibility_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_visibility_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_visibility_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_visibility_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_visibility_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_visibility_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type lxb_css_property_width_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_height_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_min_width_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_min_height_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_max_width_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_max_height_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_margin_top_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_margin_right_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_margin_bottom_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_margin_left_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_padding_top_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_padding_right_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_padding_bottom_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_padding_left_t = lxb_css_value_length_percentage_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_box_sizing_t {
    pub type_: lxb_css_box_sizing_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_box_sizing_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_box_sizing_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_box_sizing_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_box_sizing_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_box_sizing_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_box_sizing_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_box_sizing_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_margin_t {
    pub top: lxb_css_property_margin_top_t,
    pub right: lxb_css_property_margin_right_t,
    pub bottom: lxb_css_property_margin_bottom_t,
    pub left: lxb_css_property_margin_left_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_margin_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_margin_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_margin_t>(),
        96usize,
        concat!("Size of: ", stringify!(lxb_css_property_margin_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_margin_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_margin_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_margin_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_margin_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_margin_t),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_margin_t),
            "::",
            stringify!(left)
        )
    );
}
impl Default for lxb_css_property_margin_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_padding_t {
    pub top: lxb_css_property_padding_top_t,
    pub right: lxb_css_property_padding_right_t,
    pub bottom: lxb_css_property_padding_bottom_t,
    pub left: lxb_css_property_padding_left_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_padding_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_padding_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_padding_t>(),
        96usize,
        concat!("Size of: ", stringify!(lxb_css_property_padding_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_padding_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_padding_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_padding_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_padding_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_padding_t),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_padding_t),
            "::",
            stringify!(left)
        )
    );
}
impl Default for lxb_css_property_padding_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_border_t {
    pub style: lxb_css_value_type_t,
    pub width: lxb_css_value_length_type_t,
    pub color: lxb_css_value_color_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_border_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_border_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_border_t>(),
        144usize,
        concat!("Size of: ", stringify!(lxb_css_property_border_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_border_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_border_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_border_t),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_border_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_border_t),
            "::",
            stringify!(color)
        )
    );
}
impl Default for lxb_css_property_border_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_property_border_top_t = lxb_css_property_border_t;
pub type lxb_css_property_border_right_t = lxb_css_property_border_t;
pub type lxb_css_property_border_bottom_t = lxb_css_property_border_t;
pub type lxb_css_property_border_left_t = lxb_css_property_border_t;
pub type lxb_css_property_border_top_color_t = lxb_css_value_color_t;
pub type lxb_css_property_border_right_color_t = lxb_css_value_color_t;
pub type lxb_css_property_border_bottom_color_t = lxb_css_value_color_t;
pub type lxb_css_property_border_left_color_t = lxb_css_value_color_t;
pub type lxb_css_property_background_color_t = lxb_css_value_color_t;
pub type lxb_css_property_color_t = lxb_css_value_color_t;
pub type lxb_css_property_opacity_t = lxb_css_value_number_percentage_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_position_t {
    pub type_: lxb_css_position_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_position_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_position_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_position_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_position_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_position_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_position_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_position_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type lxb_css_property_top_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_right_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_bottom_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_left_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_inset_block_start_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_inset_inline_start_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_inset_block_end_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_inset_inline_end_t = lxb_css_value_length_percentage_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_transform_t {
    pub type_case: lxb_css_text_transform_type_t,
    pub full_width: lxb_css_text_transform_type_t,
    pub full_size_kana: lxb_css_text_transform_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_transform_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_transform_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_transform_t>(),
        12usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_transform_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_transform_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_transform_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_case) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_transform_t),
            "::",
            stringify!(type_case)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).full_width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_transform_t),
            "::",
            stringify!(full_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).full_size_kana) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_transform_t),
            "::",
            stringify!(full_size_kana)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_align_t {
    pub type_: lxb_css_text_align_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_align_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_align_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_align_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_text_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_align_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_align_all_t {
    pub type_: lxb_css_text_align_all_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_align_all_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_align_all_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_align_all_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_align_all_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_align_all_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_align_all_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_align_all_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_align_last_t {
    pub type_: lxb_css_text_align_last_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_align_last_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_align_last_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_align_last_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_align_last_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_align_last_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_align_last_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_align_last_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_justify_t {
    pub type_: lxb_css_text_justify_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_justify_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_justify_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_justify_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_justify_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_justify_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_text_justify_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_justify_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_text_indent_t {
    pub length: lxb_css_value_length_percentage_t,
    pub type_: lxb_css_text_indent_type_t,
    pub hanging: lxb_css_text_indent_type_t,
    pub each_line: lxb_css_text_indent_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_indent_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_indent_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_indent_t>(),
        40usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_indent_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_indent_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_text_indent_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_indent_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_indent_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hanging) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_indent_t),
            "::",
            stringify!(hanging)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).each_line) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_indent_t),
            "::",
            stringify!(each_line)
        )
    );
}
impl Default for lxb_css_property_text_indent_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_white_space_t {
    pub type_: lxb_css_white_space_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_white_space_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_white_space_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_white_space_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_white_space_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_white_space_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_white_space_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_white_space_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type lxb_css_property_tab_size_t = lxb_css_value_number_length_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_word_break_t {
    pub type_: lxb_css_word_break_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_word_break_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_word_break_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_word_break_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_word_break_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_word_break_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_word_break_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_word_break_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_line_break_t {
    pub type_: lxb_css_line_break_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_line_break_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_line_break_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_line_break_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_line_break_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_line_break_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_line_break_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_line_break_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_hyphens_t {
    pub type_: lxb_css_hyphens_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_hyphens_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_hyphens_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_hyphens_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_hyphens_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_hyphens_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_hyphens_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_hyphens_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_overflow_wrap_t {
    pub type_: lxb_css_overflow_wrap_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_overflow_wrap_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_overflow_wrap_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_overflow_wrap_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_overflow_wrap_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_overflow_wrap_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_overflow_wrap_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_overflow_wrap_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_word_wrap_t {
    pub type_: lxb_css_word_wrap_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_word_wrap_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_word_wrap_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_word_wrap_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_word_wrap_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_word_wrap_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_word_wrap_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_word_wrap_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type lxb_css_property_word_spacing_t = lxb_css_value_length_type_t;
pub type lxb_css_property_letter_spacing_t = lxb_css_value_length_type_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_hanging_punctuation_t {
    pub type_first: lxb_css_hanging_punctuation_type_t,
    pub force_allow: lxb_css_hanging_punctuation_type_t,
    pub last: lxb_css_hanging_punctuation_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_hanging_punctuation_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_hanging_punctuation_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_hanging_punctuation_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_property_hanging_punctuation_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_hanging_punctuation_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_hanging_punctuation_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_hanging_punctuation_t),
            "::",
            stringify!(type_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).force_allow) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_hanging_punctuation_t),
            "::",
            stringify!(force_allow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_hanging_punctuation_t),
            "::",
            stringify!(last)
        )
    );
}
pub type lxb_css_property_family_name_t = lxb_css_property_family_name;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_family_name {
    pub generic: bool,
    pub u: lxb_css_property_family_name__bindgen_ty_1,
    pub next: *mut lxb_css_property_family_name_t,
    pub prev: *mut lxb_css_property_family_name_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_property_family_name__bindgen_ty_1 {
    pub type_: lxb_css_font_family_type_t,
    pub str_: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_family_name__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_family_name__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_family_name__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_property_family_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_family_name__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_family_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_family_name__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_family_name__bindgen_ty_1),
            "::",
            stringify!(str_)
        )
    );
}
impl Default for lxb_css_property_family_name__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_property_family_name() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_family_name> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_family_name>(),
        40usize,
        concat!("Size of: ", stringify!(lxb_css_property_family_name))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_family_name>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_family_name))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_family_name),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_family_name),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_family_name),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_family_name),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for lxb_css_property_family_name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_property_font_family_t {
    pub first: *mut lxb_css_property_family_name_t,
    pub last: *mut lxb_css_property_family_name_t,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_property_font_family_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_font_family_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_font_family_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_property_font_family_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_font_family_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_font_family_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_font_family_t),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_font_family_t),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_font_family_t),
            "::",
            stringify!(count)
        )
    );
}
impl Default for lxb_css_property_font_family_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_property_font_weight_t = lxb_css_value_number_type_t;
pub type lxb_css_property_font_stretch_t = lxb_css_value_percentage_type_t;
pub type lxb_css_property_font_style_t = lxb_css_value_angle_type_t;
pub type lxb_css_property_font_size_t = lxb_css_value_length_percentage_type_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_float_reference_t {
    pub type_: lxb_css_float_reference_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_float_reference_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_float_reference_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_float_reference_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_float_reference_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_float_reference_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_float_reference_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_float_reference_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_property_float_t {
    pub type_: lxb_css_float_type_t,
    pub length: lxb_css_value_length_type_t,
    pub snap_type: lxb_css_float_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_float_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_float_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_float_t>(),
        40usize,
        concat!("Size of: ", stringify!(lxb_css_property_float_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_float_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_float_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_float_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_float_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snap_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_float_t),
            "::",
            stringify!(snap_type)
        )
    );
}
impl Default for lxb_css_property_float_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_clear_t {
    pub type_: lxb_css_clear_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_clear_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_clear_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_clear_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_clear_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_clear_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_clear_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_clear_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type lxb_css_property_float_offset_t = lxb_css_value_length_percentage_t;
pub type lxb_css_property_float_defer_t = lxb_css_value_integer_type_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_wrap_flow_t {
    pub type_: lxb_css_wrap_flow_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_wrap_flow_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_wrap_flow_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_wrap_flow_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_wrap_flow_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_wrap_flow_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_wrap_flow_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_wrap_flow_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_wrap_through_t {
    pub type_: lxb_css_wrap_through_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_wrap_through_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_wrap_through_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_wrap_through_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_wrap_through_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_wrap_through_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_wrap_through_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_wrap_through_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_flex_direction_t {
    pub type_: lxb_css_flex_direction_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_flex_direction_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_flex_direction_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_flex_direction_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_flex_direction_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_flex_direction_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_flex_direction_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_direction_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_flex_wrap_t {
    pub type_: lxb_css_flex_wrap_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_flex_wrap_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_flex_wrap_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_flex_wrap_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_flex_wrap_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_flex_wrap_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_flex_wrap_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_wrap_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_flex_flow_t {
    pub type_direction: lxb_css_flex_direction_type_t,
    pub wrap: lxb_css_flex_wrap_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_flex_flow_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_flex_flow_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_flex_flow_t>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_property_flex_flow_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_flex_flow_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_flex_flow_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_direction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_flow_t),
            "::",
            stringify!(type_direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_flow_t),
            "::",
            stringify!(wrap)
        )
    );
}
pub type lxb_css_property_flex_grow_t = lxb_css_value_number_type_t;
pub type lxb_css_property_flex_shrink_t = lxb_css_value_number_type_t;
pub type lxb_css_property_flex_basis_t = lxb_css_property_width_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_flex_t {
    pub type_: lxb_css_flex_type_t,
    pub grow: lxb_css_property_flex_grow_t,
    pub shrink: lxb_css_property_flex_shrink_t,
    pub basis: lxb_css_property_flex_basis_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_flex_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_flex_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_flex_t>(),
        80usize,
        concat!("Size of: ", stringify!(lxb_css_property_flex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_flex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_property_flex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grow) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_t),
            "::",
            stringify!(grow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shrink) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_t),
            "::",
            stringify!(shrink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).basis) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_flex_t),
            "::",
            stringify!(basis)
        )
    );
}
impl Default for lxb_css_property_flex_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_justify_content_t {
    pub type_: lxb_css_justify_content_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_justify_content_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_justify_content_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_justify_content_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_justify_content_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_justify_content_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_justify_content_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_justify_content_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_align_items_t {
    pub type_: lxb_css_align_items_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_align_items_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_align_items_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_align_items_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_align_items_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_align_items_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_align_items_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_align_items_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_align_self_t {
    pub type_: lxb_css_align_self_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_align_self_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_align_self_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_align_self_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_align_self_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_align_self_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_align_self_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_align_self_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_align_content_t {
    pub type_: lxb_css_align_content_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_align_content_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_align_content_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_align_content_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_align_content_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_align_content_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_align_content_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_align_content_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_dominant_baseline_t {
    pub type_: lxb_css_dominant_baseline_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_dominant_baseline_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_dominant_baseline_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_dominant_baseline_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_property_dominant_baseline_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_dominant_baseline_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_dominant_baseline_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_dominant_baseline_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_baseline_source_t {
    pub type_: lxb_css_baseline_source_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_baseline_source_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_baseline_source_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_baseline_source_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_baseline_source_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_baseline_source_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_baseline_source_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_baseline_source_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_alignment_baseline_t {
    pub type_: lxb_css_alignment_baseline_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_alignment_baseline_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_alignment_baseline_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_alignment_baseline_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_property_alignment_baseline_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_alignment_baseline_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_alignment_baseline_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_alignment_baseline_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type lxb_css_property_baseline_shift_t = lxb_css_value_length_percentage_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_vertical_align_t {
    pub type_: lxb_css_vertical_align_type_t,
    pub alignment: lxb_css_property_alignment_baseline_t,
    pub shift: lxb_css_property_baseline_shift_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_vertical_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_vertical_align_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_vertical_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(lxb_css_property_vertical_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_vertical_align_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_vertical_align_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_vertical_align_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_vertical_align_t),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_vertical_align_t),
            "::",
            stringify!(shift)
        )
    );
}
impl Default for lxb_css_property_vertical_align_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_property_line_height_t = lxb_css_value_number_length_percentage_t;
pub type lxb_css_property_z_index_t = lxb_css_value_integer_type_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_direction_t {
    pub type_: lxb_css_direction_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_direction_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_direction_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_direction_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_direction_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_direction_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_direction_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_direction_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_unicode_bidi_t {
    pub type_: lxb_css_unicode_bidi_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_unicode_bidi_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_unicode_bidi_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_unicode_bidi_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_unicode_bidi_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_unicode_bidi_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_unicode_bidi_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_unicode_bidi_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_writing_mode_t {
    pub type_: lxb_css_writing_mode_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_writing_mode_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_writing_mode_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_writing_mode_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_writing_mode_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_writing_mode_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_writing_mode_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_writing_mode_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_orientation_t {
    pub type_: lxb_css_text_orientation_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_orientation_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_orientation_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_orientation_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_orientation_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_orientation_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_orientation_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_orientation_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_combine_upright_t {
    pub type_: lxb_css_text_combine_upright_type_t,
    pub digits: lxb_css_value_integer_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_combine_upright_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_combine_upright_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_combine_upright_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_property_text_combine_upright_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_combine_upright_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_combine_upright_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_combine_upright_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).digits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_combine_upright_t),
            "::",
            stringify!(digits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_overflow_x_t {
    pub type_: lxb_css_overflow_x_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_overflow_x_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_overflow_x_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_overflow_x_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_overflow_x_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_overflow_x_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_overflow_x_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_overflow_x_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_overflow_y_t {
    pub type_: lxb_css_overflow_y_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_overflow_y_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_overflow_y_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_overflow_y_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_overflow_y_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_overflow_y_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_property_overflow_y_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_overflow_y_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_overflow_block_t {
    pub type_: lxb_css_overflow_block_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_overflow_block_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_overflow_block_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_overflow_block_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_overflow_block_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_overflow_block_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_overflow_block_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_overflow_block_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_overflow_inline_t {
    pub type_: lxb_css_overflow_inline_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_overflow_inline_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_overflow_inline_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_overflow_inline_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_overflow_inline_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_overflow_inline_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_overflow_inline_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_overflow_inline_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_overflow_t {
    pub type_: lxb_css_text_overflow_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_overflow_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_overflow_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_overflow_t>(),
        4usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_overflow_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_overflow_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_overflow_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_overflow_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_decoration_line_t {
    pub type_: lxb_css_text_decoration_line_type_t,
    pub underline: lxb_css_text_decoration_line_type_t,
    pub overline: lxb_css_text_decoration_line_type_t,
    pub line_through: lxb_css_text_decoration_line_type_t,
    pub blink: lxb_css_text_decoration_line_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_decoration_line_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_decoration_line_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_decoration_line_t>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_property_text_decoration_line_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_decoration_line_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_decoration_line_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_line_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).underline) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_line_t),
            "::",
            stringify!(underline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overline) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_line_t),
            "::",
            stringify!(overline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_through) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_line_t),
            "::",
            stringify!(line_through)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_line_t),
            "::",
            stringify!(blink)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_property_text_decoration_style_t {
    pub type_: lxb_css_text_decoration_style_type_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_decoration_style_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_decoration_style_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_decoration_style_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_property_text_decoration_style_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_decoration_style_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_decoration_style_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_style_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type lxb_css_property_text_decoration_color_t = lxb_css_value_color_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_property_text_decoration_t {
    pub line: lxb_css_property_text_decoration_line_t,
    pub style: lxb_css_property_text_decoration_style_t,
    pub color: lxb_css_property_text_decoration_color_t,
}
#[test]
fn bindgen_test_layout_lxb_css_property_text_decoration_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_property_text_decoration_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_property_text_decoration_t>(),
        136usize,
        concat!("Size of: ", stringify!(lxb_css_property_text_decoration_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_property_text_decoration_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_property_text_decoration_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).style) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_t),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_property_text_decoration_t),
            "::",
            stringify!(color)
        )
    );
}
impl Default for lxb_css_property_text_decoration_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_property_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_entry_data_t;
}
extern "C" {
    pub fn lxb_css_property_by_id(id: usize) -> *const lxb_css_entry_data_t;
}
extern "C" {
    pub fn lxb_css_property_initial_by_id(id: usize) -> *const cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        type_: lxb_css_property_type_t,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_serialize(
        style: *const cty::c_void,
        type_: lxb_css_property_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_serialize_str(
        style: *const cty::c_void,
        type_: lxb_css_property_type_t,
        mraw: *mut lexbor_mraw_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_serialize_name(
        style: *const cty::c_void,
        type_: lxb_css_property_type_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_serialize_name_str(
        style: *const cty::c_void,
        type_: lxb_css_property_type_t,
        mraw: *mut lexbor_mraw_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property__undef_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property__undef_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property__undef_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property__undef_serialize_name(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property__undef_serialize_value(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property__custom_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property__custom_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property__custom_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property__custom_serialize_name(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property__custom_serialize_value(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_display_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_display_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_display_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_order_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_order_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_order_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_visibility_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_visibility_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_visibility_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_width_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_width_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_width_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_height_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_height_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_height_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_box_sizing_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_box_sizing_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_box_sizing_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_min_width_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_min_width_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_min_width_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_min_height_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_min_height_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_min_height_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_max_width_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_max_width_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_max_width_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_max_height_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_max_height_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_max_height_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_margin_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_margin_top_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_top_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_top_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_margin_right_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_right_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_right_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_margin_bottom_create(memory: *mut lxb_css_memory_t)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_bottom_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_bottom_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_margin_left_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_left_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_margin_left_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_padding_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_padding_top_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_top_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_top_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_padding_right_create(memory: *mut lxb_css_memory_t)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_right_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_right_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_padding_bottom_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_bottom_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_bottom_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_padding_left_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_left_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_padding_left_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_top_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_top_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_top_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_right_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_right_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_right_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_bottom_create(memory: *mut lxb_css_memory_t)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_bottom_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_bottom_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_left_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_left_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_left_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_top_color_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_top_color_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_top_color_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_right_color_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_right_color_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_right_color_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_bottom_color_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_bottom_color_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_bottom_color_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_border_left_color_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_left_color_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_border_left_color_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_background_color_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_background_color_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_background_color_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_color_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_color_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_color_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_opacity_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_opacity_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_opacity_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_position_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_position_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_position_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_top_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_top_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_top_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_right_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_right_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_right_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_bottom_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_bottom_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_bottom_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_left_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_left_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_left_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_inset_block_start_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_block_start_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_block_start_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_inset_inline_start_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_inline_start_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_inline_start_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_inset_block_end_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_block_end_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_block_end_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_inset_inline_end_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_inline_end_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_inset_inline_end_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_transform_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_transform_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_transform_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_align_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_align_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_align_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_align_all_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_align_all_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_align_all_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_align_last_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_align_last_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_align_last_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_justify_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_justify_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_justify_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_indent_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_indent_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_indent_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_white_space_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_white_space_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_white_space_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_tab_size_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_tab_size_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_tab_size_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_word_break_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_word_break_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_word_break_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_line_break_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_line_break_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_line_break_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_hyphens_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_hyphens_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_hyphens_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_overflow_wrap_create(memory: *mut lxb_css_memory_t)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_wrap_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_wrap_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_word_wrap_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_word_wrap_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_word_wrap_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_word_spacing_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_word_spacing_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_word_spacing_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_letter_spacing_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_letter_spacing_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_letter_spacing_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_hanging_punctuation_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_hanging_punctuation_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_hanging_punctuation_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_font_family_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_family_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_family_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_font_weight_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_weight_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_weight_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_font_stretch_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_stretch_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_stretch_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_font_style_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_style_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_style_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_font_size_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_size_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_font_size_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_float_reference_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_reference_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_reference_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_float_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_clear_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_clear_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_clear_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_float_defer_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_defer_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_defer_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_float_offset_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_offset_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_float_offset_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_wrap_flow_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_wrap_flow_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_wrap_flow_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_wrap_through_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_wrap_through_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_wrap_through_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_flex_direction_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_direction_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_direction_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_flex_wrap_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_wrap_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_wrap_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_flex_flow_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_flow_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_flow_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_flex_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_flex_grow_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_grow_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_grow_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_flex_shrink_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_shrink_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_shrink_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_flex_basis_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_basis_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_flex_basis_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_justify_content_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_justify_content_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_justify_content_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_align_items_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_align_items_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_align_items_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_align_self_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_align_self_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_align_self_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_align_content_create(memory: *mut lxb_css_memory_t)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_align_content_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_align_content_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_dominant_baseline_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_dominant_baseline_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_dominant_baseline_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_vertical_align_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_vertical_align_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_vertical_align_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_baseline_source_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_baseline_source_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_baseline_source_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_alignment_baseline_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_alignment_baseline_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_alignment_baseline_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_baseline_shift_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_baseline_shift_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_baseline_shift_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_line_height_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_line_height_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_line_height_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_z_index_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_z_index_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_z_index_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_direction_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_direction_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_direction_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_unicode_bidi_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_unicode_bidi_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_unicode_bidi_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_writing_mode_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_writing_mode_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_writing_mode_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_orientation_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_orientation_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_orientation_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_combine_upright_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_combine_upright_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_combine_upright_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_overflow_x_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_x_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_x_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_overflow_y_create(memory: *mut lxb_css_memory_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_y_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_y_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_overflow_block_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_block_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_block_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_overflow_inline_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_inline_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_overflow_inline_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_overflow_create(memory: *mut lxb_css_memory_t)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_overflow_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_overflow_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_line_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_line_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_line_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_style_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_style_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_style_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_color_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_color_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_color_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_create(
        memory: *mut lxb_css_memory_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_destroy(
        memory: *mut lxb_css_memory_t,
        style: *mut cty::c_void,
        self_destroy: bool,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_property_text_decoration_serialize(
        style: *const cty::c_void,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_run(parser: *mut lxb_css_parser_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_token(
        parser: *mut lxb_css_parser_t,
    ) -> *const lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_token_wo_ws(
        parser: *mut lxb_css_parser_t,
    ) -> *const lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_consume(parser: *mut lxb_css_parser_t);
}
extern "C" {
    pub fn lxb_css_syntax_parser_list_rules_push(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        state_back: lxb_css_parser_state_f,
        list_rules: *const lxb_css_syntax_cb_list_rules_t,
        ctx: *mut cty::c_void,
        top_level: bool,
        stop: lxb_css_syntax_token_type_t,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_at_rule_push(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        state_back: lxb_css_parser_state_f,
        at_rule: *const lxb_css_syntax_cb_at_rule_t,
        ctx: *mut cty::c_void,
        stop: lxb_css_syntax_token_type_t,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_qualified_push(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        state_back: lxb_css_parser_state_f,
        qualified: *const lxb_css_syntax_cb_qualified_rule_t,
        ctx: *mut cty::c_void,
        stop: lxb_css_syntax_token_type_t,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_declarations_push(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        state_back: lxb_css_parser_state_f,
        declarations: *const lxb_css_syntax_cb_declarations_t,
        ctx: *mut cty::c_void,
        stop: lxb_css_syntax_token_type_t,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_components_push(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        state_back: lxb_css_parser_state_f,
        comp: *const lxb_css_syntax_cb_components_t,
        ctx: *mut cty::c_void,
        stop: lxb_css_syntax_token_type_t,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_function_push(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        state_back: lxb_css_parser_state_f,
        func: *const lxb_css_syntax_cb_function_t,
        ctx: *mut cty::c_void,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_block_push(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        state_back: lxb_css_parser_state_f,
        block: *const lxb_css_syntax_cb_block_t,
        ctx: *mut cty::c_void,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_pipe_push(
        parser: *mut lxb_css_parser_t,
        state_back: lxb_css_parser_state_f,
        pipe: *const lxb_css_syntax_cb_pipe_t,
        ctx: *mut cty::c_void,
        stop: lxb_css_syntax_token_type_t,
    ) -> *mut lxb_css_syntax_rule_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_tkz_cb(
        tkz: *mut lxb_css_syntax_tokenizer_t,
        data: *mut *const lxb_char_t,
        end: *mut *const lxb_char_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_start_block(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        rule: *mut lxb_css_syntax_rule_t,
    ) -> *const lxb_css_syntax_token_t;
}
extern "C" {
    pub fn lxb_css_syntax_parser_end(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        rule: *mut lxb_css_syntax_rule_t,
    ) -> *const lxb_css_syntax_token_t;
}
pub type lxb_css_selectors_t = lxb_css_selectors;
pub type lxb_css_selector_t = lxb_css_selector;
pub type lxb_css_selector_list_t = lxb_css_selector_list;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_anb_t {
    pub a: cty::c_long,
    pub b: cty::c_long,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_anb_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_anb_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_anb_t>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_anb_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_anb_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lxb_css_syntax_anb_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_anb_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_anb_t),
            "::",
            stringify!(b)
        )
    );
}
extern "C" {
    pub fn lxb_css_syntax_anb_parse(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> lxb_css_syntax_anb_t;
}
extern "C" {
    pub fn lxb_css_syntax_anb_handler(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        anb: *mut lxb_css_syntax_anb_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_anb_serialize(
        anb: *mut lxb_css_syntax_anb_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_syntax_anb_serialize_char(
        anb: *mut lxb_css_syntax_anb_t,
        out_length: *mut usize,
    ) -> *mut lxb_char_t;
}
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE__UNDEF: lxb_css_selector_type_t = 0;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_ANY: lxb_css_selector_type_t = 1;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_ELEMENT: lxb_css_selector_type_t = 2;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_ID: lxb_css_selector_type_t = 3;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_CLASS: lxb_css_selector_type_t = 4;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_ATTRIBUTE: lxb_css_selector_type_t = 5;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_PSEUDO_CLASS: lxb_css_selector_type_t = 6;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_PSEUDO_CLASS_FUNCTION:
    lxb_css_selector_type_t = 7;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_PSEUDO_ELEMENT: lxb_css_selector_type_t = 8;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE_PSEUDO_ELEMENT_FUNCTION:
    lxb_css_selector_type_t = 9;
pub const lxb_css_selector_type_t_LXB_CSS_SELECTOR_TYPE__LAST_ENTRY: lxb_css_selector_type_t = 10;
pub type lxb_css_selector_type_t = cty::c_int;
pub const lxb_css_selector_combinator_t_LXB_CSS_SELECTOR_COMBINATOR_DESCENDANT:
    lxb_css_selector_combinator_t = 0;
pub const lxb_css_selector_combinator_t_LXB_CSS_SELECTOR_COMBINATOR_CLOSE:
    lxb_css_selector_combinator_t = 1;
pub const lxb_css_selector_combinator_t_LXB_CSS_SELECTOR_COMBINATOR_CHILD:
    lxb_css_selector_combinator_t = 2;
pub const lxb_css_selector_combinator_t_LXB_CSS_SELECTOR_COMBINATOR_SIBLING:
    lxb_css_selector_combinator_t = 3;
pub const lxb_css_selector_combinator_t_LXB_CSS_SELECTOR_COMBINATOR_FOLLOWING:
    lxb_css_selector_combinator_t = 4;
pub const lxb_css_selector_combinator_t_LXB_CSS_SELECTOR_COMBINATOR_CELL:
    lxb_css_selector_combinator_t = 5;
pub const lxb_css_selector_combinator_t_LXB_CSS_SELECTOR_COMBINATOR__LAST_ENTRY:
    lxb_css_selector_combinator_t = 6;
pub type lxb_css_selector_combinator_t = cty::c_int;
pub const lxb_css_selector_match_t_LXB_CSS_SELECTOR_MATCH_EQUAL: lxb_css_selector_match_t = 0;
pub const lxb_css_selector_match_t_LXB_CSS_SELECTOR_MATCH_INCLUDE: lxb_css_selector_match_t = 1;
pub const lxb_css_selector_match_t_LXB_CSS_SELECTOR_MATCH_DASH: lxb_css_selector_match_t = 2;
pub const lxb_css_selector_match_t_LXB_CSS_SELECTOR_MATCH_PREFIX: lxb_css_selector_match_t = 3;
pub const lxb_css_selector_match_t_LXB_CSS_SELECTOR_MATCH_SUFFIX: lxb_css_selector_match_t = 4;
pub const lxb_css_selector_match_t_LXB_CSS_SELECTOR_MATCH_SUBSTRING: lxb_css_selector_match_t = 5;
pub const lxb_css_selector_match_t_LXB_CSS_SELECTOR_MATCH__LAST_ENTRY: lxb_css_selector_match_t = 6;
pub type lxb_css_selector_match_t = cty::c_int;
pub const lxb_css_selector_modifier_t_LXB_CSS_SELECTOR_MODIFIER_UNSET: lxb_css_selector_modifier_t =
    0;
pub const lxb_css_selector_modifier_t_LXB_CSS_SELECTOR_MODIFIER_I: lxb_css_selector_modifier_t = 1;
pub const lxb_css_selector_modifier_t_LXB_CSS_SELECTOR_MODIFIER_S: lxb_css_selector_modifier_t = 2;
pub const lxb_css_selector_modifier_t_LXB_CSS_SELECTOR_MODIFIER__LAST_ENTRY:
    lxb_css_selector_modifier_t = 3;
pub type lxb_css_selector_modifier_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_selector_attribute_t {
    pub match_: lxb_css_selector_match_t,
    pub modifier: lxb_css_selector_modifier_t,
    pub value: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_css_selector_attribute_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selector_attribute_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selector_attribute_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_selector_attribute_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selector_attribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_selector_attribute_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).match_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_attribute_t),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modifier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_attribute_t),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_attribute_t),
            "::",
            stringify!(value)
        )
    );
}
impl Default for lxb_css_selector_attribute_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_selector_pseudo_t {
    pub type_: cty::c_uint,
    pub data: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_css_selector_pseudo_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selector_pseudo_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selector_pseudo_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_selector_pseudo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selector_pseudo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_selector_pseudo_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_pseudo_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_pseudo_t),
            "::",
            stringify!(data)
        )
    );
}
impl Default for lxb_css_selector_pseudo_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_selector_anb_of_t {
    pub anb: lxb_css_syntax_anb_t,
    pub of: *mut lxb_css_selector_list_t,
}
#[test]
fn bindgen_test_layout_lxb_css_selector_anb_of_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selector_anb_of_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selector_anb_of_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_selector_anb_of_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selector_anb_of_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_selector_anb_of_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_anb_of_t),
            "::",
            stringify!(anb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).of) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_anb_of_t),
            "::",
            stringify!(of)
        )
    );
}
impl Default for lxb_css_selector_anb_of_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_selector {
    pub type_: lxb_css_selector_type_t,
    pub combinator: lxb_css_selector_combinator_t,
    pub name: lexbor_str_t,
    pub ns: lexbor_str_t,
    pub u: lxb_css_selector_lxb_css_selector_u,
    pub next: *mut lxb_css_selector_t,
    pub prev: *mut lxb_css_selector_t,
    pub list: *mut lxb_css_selector_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_selector_lxb_css_selector_u {
    pub attribute: lxb_css_selector_attribute_t,
    pub pseudo: lxb_css_selector_pseudo_t,
}
#[test]
fn bindgen_test_layout_lxb_css_selector_lxb_css_selector_u() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selector_lxb_css_selector_u> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selector_lxb_css_selector_u>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_selector_lxb_css_selector_u))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selector_lxb_css_selector_u>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_selector_lxb_css_selector_u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attribute) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_lxb_css_selector_u),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pseudo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_lxb_css_selector_u),
            "::",
            stringify!(pseudo)
        )
    );
}
impl Default for lxb_css_selector_lxb_css_selector_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_selector() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selector>(),
        88usize,
        concat!("Size of: ", stringify!(lxb_css_selector))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selector>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_selector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).combinator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(combinator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector),
            "::",
            stringify!(list)
        )
    );
}
impl Default for lxb_css_selector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type lxb_css_selector_specificity_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_selector_list {
    pub first: *mut lxb_css_selector_t,
    pub last: *mut lxb_css_selector_t,
    pub parent: *mut lxb_css_selector_t,
    pub next: *mut lxb_css_selector_list_t,
    pub prev: *mut lxb_css_selector_list_t,
    pub memory: *mut lxb_css_memory_t,
    pub specificity: lxb_css_selector_specificity_t,
}
#[test]
fn bindgen_test_layout_lxb_css_selector_list() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selector_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selector_list>(),
        56usize,
        concat!("Size of: ", stringify!(lxb_css_selector_list))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selector_list>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_selector_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_list),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_list),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_list),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_list),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_list),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).specificity) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selector_list),
            "::",
            stringify!(specificity)
        )
    );
}
impl Default for lxb_css_selector_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_selector_create(list: *mut lxb_css_selector_list_t) -> *mut lxb_css_selector_t;
}
extern "C" {
    pub fn lxb_css_selector_destroy(selector: *mut lxb_css_selector_t);
}
extern "C" {
    pub fn lxb_css_selector_destroy_chain(selector: *mut lxb_css_selector_t);
}
extern "C" {
    pub fn lxb_css_selector_remove(selector: *mut lxb_css_selector_t);
}
extern "C" {
    pub fn lxb_css_selector_list_create(mem: *mut lxb_css_memory_t)
        -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selector_list_remove(list: *mut lxb_css_selector_list_t);
}
extern "C" {
    pub fn lxb_css_selector_list_selectors_remove(
        selectors: *mut lxb_css_selectors_t,
        list: *mut lxb_css_selector_list_t,
    );
}
extern "C" {
    pub fn lxb_css_selector_list_destroy(list: *mut lxb_css_selector_list_t);
}
extern "C" {
    pub fn lxb_css_selector_list_destroy_chain(list: *mut lxb_css_selector_list_t);
}
extern "C" {
    pub fn lxb_css_selector_list_destroy_memory(list: *mut lxb_css_selector_list_t);
}
extern "C" {
    pub fn lxb_css_selector_serialize(
        selector: *mut lxb_css_selector_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selector_serialize_chain(
        selector: *mut lxb_css_selector_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selector_serialize_chain_char(
        selector: *mut lxb_css_selector_t,
        out_length: *mut usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_css_selector_serialize_list(
        list: *mut lxb_css_selector_list_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selector_serialize_list_chain(
        list: *mut lxb_css_selector_list_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selector_serialize_list_chain_char(
        list: *mut lxb_css_selector_list_t,
        out_length: *mut usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_css_selector_serialize_anb_of(
        anbof: *mut lxb_css_selector_anb_of_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selector_combinator(
        selector: *mut lxb_css_selector_t,
        out_length: *mut usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_css_selector_list_append(
        list: *mut lxb_css_selector_list_t,
        selector: *mut lxb_css_selector_t,
    );
}
extern "C" {
    pub fn lxb_css_selector_list_append_next(
        dist: *mut lxb_css_selector_list_t,
        src: *mut lxb_css_selector_list_t,
    );
}
extern "C" {
    pub fn lxb_css_selector_append_next(
        dist: *mut lxb_css_selector_t,
        src: *mut lxb_css_selector_t,
    );
}
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS__UNDEF:
    lxb_css_selector_pseudo_class_id_t = 0;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_ACTIVE:
    lxb_css_selector_pseudo_class_id_t = 1;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_ANY_LINK:
    lxb_css_selector_pseudo_class_id_t = 2;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_BLANK:
    lxb_css_selector_pseudo_class_id_t = 3;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_CHECKED:
    lxb_css_selector_pseudo_class_id_t = 4;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_CURRENT:
    lxb_css_selector_pseudo_class_id_t = 5;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_DEFAULT:
    lxb_css_selector_pseudo_class_id_t = 6;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_DISABLED:
    lxb_css_selector_pseudo_class_id_t = 7;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_EMPTY:
    lxb_css_selector_pseudo_class_id_t = 8;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_ENABLED:
    lxb_css_selector_pseudo_class_id_t = 9;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FIRST_CHILD:
    lxb_css_selector_pseudo_class_id_t = 10;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FIRST_OF_TYPE:
    lxb_css_selector_pseudo_class_id_t = 11;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FOCUS:
    lxb_css_selector_pseudo_class_id_t = 12;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FOCUS_VISIBLE:
    lxb_css_selector_pseudo_class_id_t = 13;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FOCUS_WITHIN:
    lxb_css_selector_pseudo_class_id_t = 14;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FULLSCREEN:
    lxb_css_selector_pseudo_class_id_t = 15;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUTURE:
    lxb_css_selector_pseudo_class_id_t = 16;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_HOVER:
    lxb_css_selector_pseudo_class_id_t = 17;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_IN_RANGE:
    lxb_css_selector_pseudo_class_id_t = 18;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_INDETERMINATE:
    lxb_css_selector_pseudo_class_id_t = 19;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_INVALID:
    lxb_css_selector_pseudo_class_id_t = 20;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_LAST_CHILD:
    lxb_css_selector_pseudo_class_id_t = 21;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_LAST_OF_TYPE:
    lxb_css_selector_pseudo_class_id_t = 22;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_LINK:
    lxb_css_selector_pseudo_class_id_t = 23;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_LOCAL_LINK:
    lxb_css_selector_pseudo_class_id_t = 24;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_ONLY_CHILD:
    lxb_css_selector_pseudo_class_id_t = 25;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_ONLY_OF_TYPE:
    lxb_css_selector_pseudo_class_id_t = 26;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_OPTIONAL:
    lxb_css_selector_pseudo_class_id_t = 27;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_OUT_OF_RANGE:
    lxb_css_selector_pseudo_class_id_t = 28;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_PAST:
    lxb_css_selector_pseudo_class_id_t = 29;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_PLACEHOLDER_SHOWN:
    lxb_css_selector_pseudo_class_id_t = 30;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_READ_ONLY:
    lxb_css_selector_pseudo_class_id_t = 31;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_READ_WRITE:
    lxb_css_selector_pseudo_class_id_t = 32;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_REQUIRED:
    lxb_css_selector_pseudo_class_id_t = 33;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_ROOT:
    lxb_css_selector_pseudo_class_id_t = 34;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_SCOPE:
    lxb_css_selector_pseudo_class_id_t = 35;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_TARGET:
    lxb_css_selector_pseudo_class_id_t = 36;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_TARGET_WITHIN:
    lxb_css_selector_pseudo_class_id_t = 37;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_USER_INVALID:
    lxb_css_selector_pseudo_class_id_t = 38;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_VALID:
    lxb_css_selector_pseudo_class_id_t = 39;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_VISITED:
    lxb_css_selector_pseudo_class_id_t = 40;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_WARNING:
    lxb_css_selector_pseudo_class_id_t = 41;
pub const lxb_css_selector_pseudo_class_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS__LAST_ENTRY:
    lxb_css_selector_pseudo_class_id_t = 42;
pub type lxb_css_selector_pseudo_class_id_t = cty::c_int;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION__UNDEF : lxb_css_selector_pseudo_class_function_id_t = 0 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_CURRENT : lxb_css_selector_pseudo_class_function_id_t = 1 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_DIR:
    lxb_css_selector_pseudo_class_function_id_t = 2;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_HAS:
    lxb_css_selector_pseudo_class_function_id_t = 3;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_IS:
    lxb_css_selector_pseudo_class_function_id_t = 4;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_LANG : lxb_css_selector_pseudo_class_function_id_t = 5 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_NOT:
    lxb_css_selector_pseudo_class_function_id_t = 6;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_NTH_CHILD : lxb_css_selector_pseudo_class_function_id_t = 7 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_NTH_COL : lxb_css_selector_pseudo_class_function_id_t = 8 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_NTH_LAST_CHILD : lxb_css_selector_pseudo_class_function_id_t = 9 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_NTH_LAST_COL : lxb_css_selector_pseudo_class_function_id_t = 10 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_NTH_LAST_OF_TYPE : lxb_css_selector_pseudo_class_function_id_t = 11 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_NTH_OF_TYPE : lxb_css_selector_pseudo_class_function_id_t = 12 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION_WHERE : lxb_css_selector_pseudo_class_function_id_t = 13 ;
pub const lxb_css_selector_pseudo_class_function_id_t_LXB_CSS_SELECTOR_PSEUDO_CLASS_FUNCTION__LAST_ENTRY : lxb_css_selector_pseudo_class_function_id_t = 14 ;
pub type lxb_css_selector_pseudo_class_function_id_t = cty::c_int;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT__UNDEF:
    lxb_css_selector_pseudo_element_id_t = 0;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_AFTER:
    lxb_css_selector_pseudo_element_id_t = 1;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_BACKDROP:
    lxb_css_selector_pseudo_element_id_t = 2;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_BEFORE:
    lxb_css_selector_pseudo_element_id_t = 3;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_FIRST_LETTER:
    lxb_css_selector_pseudo_element_id_t = 4;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_FIRST_LINE:
    lxb_css_selector_pseudo_element_id_t = 5;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_GRAMMAR_ERROR:
    lxb_css_selector_pseudo_element_id_t = 6;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_INACTIVE_SELECTION : lxb_css_selector_pseudo_element_id_t = 7 ;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_MARKER:
    lxb_css_selector_pseudo_element_id_t = 8;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_PLACEHOLDER:
    lxb_css_selector_pseudo_element_id_t = 9;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_SELECTION:
    lxb_css_selector_pseudo_element_id_t = 10;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_SPELLING_ERROR:
    lxb_css_selector_pseudo_element_id_t = 11;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_TARGET_TEXT:
    lxb_css_selector_pseudo_element_id_t = 12;
pub const lxb_css_selector_pseudo_element_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT__LAST_ENTRY:
    lxb_css_selector_pseudo_element_id_t = 13;
pub type lxb_css_selector_pseudo_element_id_t = cty::c_int;
pub const lxb_css_selector_pseudo_element_function_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_FUNCTION__UNDEF : lxb_css_selector_pseudo_element_function_id_t = 0 ;
pub const lxb_css_selector_pseudo_element_function_id_t_LXB_CSS_SELECTOR_PSEUDO_ELEMENT_FUNCTION__LAST_ENTRY : lxb_css_selector_pseudo_element_function_id_t = 1 ;
pub type lxb_css_selector_pseudo_element_function_id_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_selectors {
    pub list: *mut lxb_css_selector_list_t,
    pub list_last: *mut lxb_css_selector_list_t,
    pub parent: *mut lxb_css_selector_t,
    pub combinator: lxb_css_selector_combinator_t,
    pub comb_default: lxb_css_selector_combinator_t,
    pub error: usize,
    pub status: bool,
    pub err_in_function: bool,
    pub failed: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_selectors() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selectors> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selectors>(),
        48usize,
        concat!("Size of: ", stringify!(lxb_css_selectors))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selectors>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_selectors))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(list_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).combinator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(combinator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comb_default) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(comb_default)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err_in_function) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(err_in_function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors),
            "::",
            stringify!(failed)
        )
    );
}
impl Default for lxb_css_selectors {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_selectors_create() -> *mut lxb_css_selectors_t;
}
extern "C" {
    pub fn lxb_css_selectors_init(selectors: *mut lxb_css_selectors_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selectors_clean(selectors: *mut lxb_css_selectors_t);
}
extern "C" {
    pub fn lxb_css_selectors_destroy(
        selectors: *mut lxb_css_selectors_t,
        self_destroy: bool,
    ) -> *mut lxb_css_selectors_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_complex_list(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_compound_list(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_simple_list(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_relative_list(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_complex(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_compound(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_simple(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
extern "C" {
    pub fn lxb_css_selectors_parse_relative(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_selector_list_t;
}
pub const lxb_css_rule_type_t_LXB_CSS_RULE_UNDEF: lxb_css_rule_type_t = 0;
pub const lxb_css_rule_type_t_LXB_CSS_RULE_STYLESHEET: lxb_css_rule_type_t = 1;
pub const lxb_css_rule_type_t_LXB_CSS_RULE_LIST: lxb_css_rule_type_t = 2;
pub const lxb_css_rule_type_t_LXB_CSS_RULE_AT_RULE: lxb_css_rule_type_t = 3;
pub const lxb_css_rule_type_t_LXB_CSS_RULE_STYLE: lxb_css_rule_type_t = 4;
pub const lxb_css_rule_type_t_LXB_CSS_RULE_BAD_STYLE: lxb_css_rule_type_t = 5;
pub const lxb_css_rule_type_t_LXB_CSS_RULE_DECLARATION_LIST: lxb_css_rule_type_t = 6;
pub const lxb_css_rule_type_t_LXB_CSS_RULE_DECLARATION: lxb_css_rule_type_t = 7;
pub type lxb_css_rule_type_t = cty::c_int;
pub type lxb_css_rule_t = lxb_css_rule;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_rule {
    pub type_: lxb_css_rule_type_t,
    pub next: *mut lxb_css_rule_t,
    pub prev: *mut lxb_css_rule_t,
    pub parent: *mut lxb_css_rule_t,
    pub begin: *const lxb_char_t,
    pub end: *const lxb_char_t,
    pub memory: *mut lxb_css_memory_t,
    pub ref_count: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_rule() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_css_rule))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule),
            "::",
            stringify!(ref_count)
        )
    );
}
impl Default for lxb_css_rule {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_rule_list {
    pub rule: lxb_css_rule_t,
    pub first: *mut lxb_css_rule_t,
    pub last: *mut lxb_css_rule_t,
}
#[test]
fn bindgen_test_layout_lxb_css_rule_list() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_list> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_list>(),
        80usize,
        concat!("Size of: ", stringify!(lxb_css_rule_list))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_list>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_list),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_list),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_list),
            "::",
            stringify!(last)
        )
    );
}
impl Default for lxb_css_rule_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_rule_at {
    pub rule: lxb_css_rule_t,
    pub type_: usize,
    pub u: lxb_css_rule_at__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_rule_at__bindgen_ty_1 {
    pub undef: *mut lxb_css_at_rule__undef_t,
    pub custom: *mut lxb_css_at_rule__custom_t,
    pub media: *mut lxb_css_at_rule_media_t,
    pub ns: *mut lxb_css_at_rule_namespace_t,
    pub user: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_css_rule_at__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_at__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_at__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_css_rule_at__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_at__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule_at__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).undef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at__bindgen_ty_1),
            "::",
            stringify!(undef)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at__bindgen_ty_1),
            "::",
            stringify!(custom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).media) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at__bindgen_ty_1),
            "::",
            stringify!(media)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at__bindgen_ty_1),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at__bindgen_ty_1),
            "::",
            stringify!(user)
        )
    );
}
impl Default for lxb_css_rule_at__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_rule_at() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_at> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_at>(),
        80usize,
        concat!("Size of: ", stringify!(lxb_css_rule_at))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_at>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule_at))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_at),
            "::",
            stringify!(u)
        )
    );
}
impl Default for lxb_css_rule_at {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_rule_style {
    pub rule: lxb_css_rule_t,
    pub selector: *mut lxb_css_selector_list_t,
    pub declarations: *mut lxb_css_rule_declaration_list_t,
}
#[test]
fn bindgen_test_layout_lxb_css_rule_style() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_style> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_style>(),
        80usize,
        concat!("Size of: ", stringify!(lxb_css_rule_style))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_style>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule_style))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_style),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selector) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_style),
            "::",
            stringify!(selector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).declarations) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_style),
            "::",
            stringify!(declarations)
        )
    );
}
impl Default for lxb_css_rule_style {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_rule_bad_style {
    pub rule: lxb_css_rule_t,
    pub selectors: lexbor_str_t,
    pub declarations: *mut lxb_css_rule_declaration_list_t,
}
#[test]
fn bindgen_test_layout_lxb_css_rule_bad_style() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_bad_style> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_bad_style>(),
        88usize,
        concat!("Size of: ", stringify!(lxb_css_rule_bad_style))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_bad_style>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule_bad_style))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_bad_style),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selectors) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_bad_style),
            "::",
            stringify!(selectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).declarations) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_bad_style),
            "::",
            stringify!(declarations)
        )
    );
}
impl Default for lxb_css_rule_bad_style {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_rule_declaration_list {
    pub rule: lxb_css_rule_t,
    pub first: *mut lxb_css_rule_t,
    pub last: *mut lxb_css_rule_t,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_lxb_css_rule_declaration_list() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_declaration_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_declaration_list>(),
        88usize,
        concat!("Size of: ", stringify!(lxb_css_rule_declaration_list))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_declaration_list>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule_declaration_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration_list),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration_list),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration_list),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration_list),
            "::",
            stringify!(count)
        )
    );
}
impl Default for lxb_css_rule_declaration_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lxb_css_rule_declaration {
    pub rule: lxb_css_rule_t,
    pub type_: usize,
    pub u: lxb_css_rule_declaration__bindgen_ty_1,
    pub important: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lxb_css_rule_declaration__bindgen_ty_1 {
    pub undef: *mut lxb_css_property__undef_t,
    pub custom: *mut lxb_css_property__custom_t,
    pub display: *mut lxb_css_property_display_t,
    pub order: *mut lxb_css_property_order_t,
    pub visibility: *mut lxb_css_property_visibility_t,
    pub width: *mut lxb_css_property_width_t,
    pub height: *mut lxb_css_property_height_t,
    pub box_sizing: *mut lxb_css_property_box_sizing_t,
    pub margin: *mut lxb_css_property_margin_t,
    pub margin_top: *mut lxb_css_property_margin_top_t,
    pub margin_right: *mut lxb_css_property_margin_right_t,
    pub margin_bottom: *mut lxb_css_property_margin_bottom_t,
    pub margin_left: *mut lxb_css_property_margin_left_t,
    pub padding: *mut lxb_css_property_padding_t,
    pub padding_top: *mut lxb_css_property_padding_top_t,
    pub padding_right: *mut lxb_css_property_padding_right_t,
    pub padding_bottom: *mut lxb_css_property_padding_bottom_t,
    pub padding_left: *mut lxb_css_property_padding_left_t,
    pub border: *mut lxb_css_property_border_t,
    pub border_top: *mut lxb_css_property_border_top_t,
    pub border_right: *mut lxb_css_property_border_right_t,
    pub border_bottom: *mut lxb_css_property_border_bottom_t,
    pub border_left: *mut lxb_css_property_border_left_t,
    pub border_top_color: *mut lxb_css_property_border_top_color_t,
    pub border_right_color: *mut lxb_css_property_border_right_color_t,
    pub border_bottom_color: *mut lxb_css_property_border_bottom_color_t,
    pub border_left_color: *mut lxb_css_property_border_left_color_t,
    pub background_color: *mut lxb_css_property_background_color_t,
    pub color: *mut lxb_css_property_color_t,
    pub opacity: *mut lxb_css_property_opacity_t,
    pub position: *mut lxb_css_property_position_t,
    pub top: *mut lxb_css_property_top_t,
    pub right: *mut lxb_css_property_right_t,
    pub bottom: *mut lxb_css_property_bottom_t,
    pub left: *mut lxb_css_property_left_t,
    pub inset_block_start: *mut lxb_css_property_inset_block_start_t,
    pub inset_inline_start: *mut lxb_css_property_inset_inline_start_t,
    pub inset_block_end: *mut lxb_css_property_inset_block_end_t,
    pub inset_inline_end: *mut lxb_css_property_inset_inline_end_t,
    pub text_transform: *mut lxb_css_property_text_transform_t,
    pub text_align: *mut lxb_css_property_text_align_t,
    pub text_align_all: *mut lxb_css_property_text_align_all_t,
    pub text_align_last: *mut lxb_css_property_text_align_last_t,
    pub text_justify: *mut lxb_css_property_text_justify_t,
    pub text_indent: *mut lxb_css_property_text_indent_t,
    pub white_space: *mut lxb_css_property_white_space_t,
    pub tab_size: *mut lxb_css_property_tab_size_t,
    pub word_break: *mut lxb_css_property_word_break_t,
    pub line_break: *mut lxb_css_property_line_break_t,
    pub hyphens: *mut lxb_css_property_hyphens_t,
    pub overflow_wrap: *mut lxb_css_property_overflow_wrap_t,
    pub word_wrap: *mut lxb_css_property_word_wrap_t,
    pub word_spacing: *mut lxb_css_property_word_spacing_t,
    pub letter_spacing: *mut lxb_css_property_letter_spacing_t,
    pub hanging_punctuation: *mut lxb_css_property_hanging_punctuation_t,
    pub font_family: *mut lxb_css_property_font_family_t,
    pub font_weight: *mut lxb_css_property_font_weight_t,
    pub font_stretch: *mut lxb_css_property_font_stretch_t,
    pub font_style: *mut lxb_css_property_font_style_t,
    pub font_size: *mut lxb_css_property_font_size_t,
    pub float_reference: *mut lxb_css_property_float_reference_t,
    pub floatp: *mut lxb_css_property_float_t,
    pub clear: *mut lxb_css_property_clear_t,
    pub float_defer: *mut lxb_css_property_float_defer_t,
    pub float_offset: *mut lxb_css_property_float_offset_t,
    pub wrap_flow: *mut lxb_css_property_wrap_flow_t,
    pub wrap_through: *mut lxb_css_property_wrap_through_t,
    pub flex_direction: *mut lxb_css_property_flex_direction_t,
    pub flex_wrap: *mut lxb_css_property_flex_wrap_t,
    pub flex_flow: *mut lxb_css_property_flex_flow_t,
    pub flex: *mut lxb_css_property_flex_t,
    pub flex_grow: *mut lxb_css_property_flex_grow_t,
    pub flex_shrink: *mut lxb_css_property_flex_shrink_t,
    pub flex_basis: *mut lxb_css_property_flex_basis_t,
    pub justify_content: *mut lxb_css_property_justify_content_t,
    pub align_items: *mut lxb_css_property_align_items_t,
    pub align_self: *mut lxb_css_property_align_self_t,
    pub align_content: *mut lxb_css_property_align_content_t,
    pub dominant_baseline: *mut lxb_css_property_dominant_baseline_t,
    pub vertical_align: *mut lxb_css_property_vertical_align_t,
    pub baseline_source: *mut lxb_css_property_baseline_source_t,
    pub alignment_baseline: *mut lxb_css_property_alignment_baseline_t,
    pub baseline_shift: *mut lxb_css_property_baseline_shift_t,
    pub line_height: *mut lxb_css_property_line_height_t,
    pub z_index: *mut lxb_css_property_z_index_t,
    pub direction: *mut lxb_css_property_direction_t,
    pub unicode_bidi: *mut lxb_css_property_unicode_bidi_t,
    pub writing_mode: *mut lxb_css_property_writing_mode_t,
    pub text_orientation: *mut lxb_css_property_text_orientation_t,
    pub text_combine_upright: *mut lxb_css_property_text_combine_upright_t,
    pub overflow_x: *mut lxb_css_property_overflow_x_t,
    pub overflow_y: *mut lxb_css_property_overflow_y_t,
    pub overflow_block: *mut lxb_css_property_overflow_block_t,
    pub overflow_inline: *mut lxb_css_property_overflow_inline_t,
    pub text_overflow: *mut lxb_css_property_text_overflow_t,
    pub text_decoration_line: *mut lxb_css_property_text_decoration_line_t,
    pub text_decoration_style: *mut lxb_css_property_text_decoration_style_t,
    pub text_decoration_color: *mut lxb_css_property_text_decoration_color_t,
    pub text_decoration: *mut lxb_css_property_text_decoration_t,
    pub user: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_css_rule_declaration__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_declaration__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_declaration__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_declaration__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).undef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(undef)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(custom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visibility) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(visibility)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).box_sizing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(box_sizing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(margin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_top) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(margin_top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_right) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(margin_right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_bottom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(margin_bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(margin_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding_top) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(padding_top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding_right) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(padding_right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding_bottom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(padding_bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding_left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(padding_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_top) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_right) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_bottom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_top_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_top_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_right_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_right_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_bottom_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_bottom_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_left_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(border_left_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).background_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(background_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(opacity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inset_block_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(inset_block_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inset_inline_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(inset_inline_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inset_block_end) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(inset_block_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inset_inline_end) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(inset_inline_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_transform) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_transform)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_align)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_align_all) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_align_all)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_align_last) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_align_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_justify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_justify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_indent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_indent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).white_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(white_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tab_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(tab_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).word_break) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(word_break)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_break) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(line_break)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hyphens) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(hyphens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_wrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(overflow_wrap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).word_wrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(word_wrap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).word_spacing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(word_spacing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).letter_spacing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(letter_spacing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hanging_punctuation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(hanging_punctuation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(font_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_weight) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(font_weight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_stretch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(font_stretch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(font_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(font_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).float_reference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(float_reference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).floatp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(floatp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).float_defer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(float_defer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).float_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(float_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrap_flow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(wrap_flow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrap_through) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(wrap_through)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flex_direction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(flex_direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flex_wrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(flex_wrap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flex_flow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(flex_flow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(flex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flex_grow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(flex_grow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flex_shrink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(flex_shrink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flex_basis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(flex_basis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).justify_content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(justify_content)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).align_items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(align_items)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).align_self) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(align_self)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).align_content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(align_content)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dominant_baseline) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(dominant_baseline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vertical_align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(vertical_align)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baseline_source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(baseline_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alignment_baseline) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(alignment_baseline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baseline_shift) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(baseline_shift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(line_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(z_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unicode_bidi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(unicode_bidi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writing_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(writing_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_orientation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_orientation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_combine_upright) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_combine_upright)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(overflow_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(overflow_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(overflow_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_inline) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(overflow_inline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_overflow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_overflow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_decoration_line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_decoration_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_decoration_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_decoration_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_decoration_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_decoration_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_decoration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(text_decoration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration__bindgen_ty_1),
            "::",
            stringify!(user)
        )
    );
}
impl Default for lxb_css_rule_declaration__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_lxb_css_rule_declaration() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_rule_declaration> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_rule_declaration>(),
        88usize,
        concat!("Size of: ", stringify!(lxb_css_rule_declaration))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_rule_declaration>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_rule_declaration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).important) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_rule_declaration),
            "::",
            stringify!(important)
        )
    );
}
impl Default for lxb_css_rule_declaration {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_rule_destroy(node: *mut lxb_css_rule_t, self_destroy: bool) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_css_rule_serialize(
        rule: *const lxb_css_rule_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_serialize_chain(
        rule: *const lxb_css_rule_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_list_destroy(
        list: *mut lxb_css_rule_list_t,
        self_destroy: bool,
    ) -> *mut lxb_css_rule_list_t;
}
extern "C" {
    pub fn lxb_css_rule_list_serialize(
        list: *const lxb_css_rule_list_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_at_destroy(
        at: *mut lxb_css_rule_at_t,
        self_destroy: bool,
    ) -> *mut lxb_css_rule_at_t;
}
extern "C" {
    pub fn lxb_css_rule_at_serialize(
        at: *const lxb_css_rule_at_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_at_serialize_name(
        at: *const lxb_css_rule_at_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_style_destroy(
        style: *mut lxb_css_rule_style_t,
        self_destroy: bool,
    ) -> *mut lxb_css_rule_style_t;
}
extern "C" {
    pub fn lxb_css_rule_style_serialize(
        style: *const lxb_css_rule_style_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_bad_style_destroy(
        bad: *mut lxb_css_rule_bad_style_t,
        self_destroy: bool,
    ) -> *mut lxb_css_rule_bad_style_t;
}
extern "C" {
    pub fn lxb_css_rule_bad_style_serialize(
        bad: *const lxb_css_rule_bad_style_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_declaration_list_destroy(
        list: *mut lxb_css_rule_declaration_list_t,
        self_destroy: bool,
    ) -> *mut lxb_css_rule_declaration_list_t;
}
extern "C" {
    pub fn lxb_css_rule_declaration_list_serialize(
        list: *const lxb_css_rule_declaration_list_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_declaration_destroy(
        declr: *mut lxb_css_rule_declaration_t,
        self_destroy: bool,
    ) -> *mut lxb_css_rule_declaration_t;
}
extern "C" {
    pub fn lxb_css_rule_declaration_serialize(
        declaration: *const lxb_css_rule_declaration_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_rule_declaration_serialize_name(
        declr: *const lxb_css_rule_declaration_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_stylesheet {
    pub root: *mut lxb_css_rule_t,
    pub memory: *mut lxb_css_memory_t,
    pub element: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_lxb_css_stylesheet() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_stylesheet> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_stylesheet>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_stylesheet))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_stylesheet>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_stylesheet))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_stylesheet),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_stylesheet),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_stylesheet),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_css_stylesheet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_stylesheet_create(memory: *mut lxb_css_memory_t) -> *mut lxb_css_stylesheet_t;
}
extern "C" {
    pub fn lxb_css_stylesheet_destroy(
        sst: *mut lxb_css_stylesheet_t,
        destroy_memory: bool,
    ) -> *mut lxb_css_stylesheet_t;
}
extern "C" {
    pub fn lxb_css_stylesheet_parse(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_stylesheet_t;
}
extern "C" {
    pub fn lxb_css_stylesheet_prepare(
        parser: *mut lxb_css_parser_t,
        memory: *mut lxb_css_memory_t,
        selectors: *mut lxb_css_selectors_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_stylesheet_process(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_stylesheet_t;
}
extern "C" {
    pub fn lxb_css_stylesheet_finish(parser: *mut lxb_css_parser_t);
}
pub const LXB_CSS_SYNTAX_PARSER_ERROR_UNDEF: _bindgen_ty_97 = 0;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_EOINATRU: _bindgen_ty_97 = 1;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_EOINQURU: _bindgen_ty_97 = 2;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_EOINSIBL: _bindgen_ty_97 = 3;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_EOINFU: _bindgen_ty_97 = 4;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_EOBEPARU: _bindgen_ty_97 = 5;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_UNTOAFPARU: _bindgen_ty_97 = 6;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_EOBEPACOVA: _bindgen_ty_97 = 7;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_UNTOAFPACOVA: _bindgen_ty_97 = 8;
pub const LXB_CSS_SYNTAX_PARSER_ERROR_UNTOINDE: _bindgen_ty_97 = 9;
pub type _bindgen_ty_97 = cty::c_int;
pub const lxb_css_parser_stage_t_LXB_CSS_PARSER_CLEAN: lxb_css_parser_stage_t = 0;
pub const lxb_css_parser_stage_t_LXB_CSS_PARSER_RUN: lxb_css_parser_stage_t = 1;
pub const lxb_css_parser_stage_t_LXB_CSS_PARSER_STOP: lxb_css_parser_stage_t = 2;
pub const lxb_css_parser_stage_t_LXB_CSS_PARSER_END: lxb_css_parser_stage_t = 3;
pub type lxb_css_parser_stage_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_parser {
    pub block: lxb_css_parser_state_f,
    pub context: *mut cty::c_void,
    pub tkz: *mut lxb_css_syntax_tokenizer_t,
    pub selectors: *mut lxb_css_selectors_t,
    pub old_selectors: *mut lxb_css_selectors_t,
    pub memory: *mut lxb_css_memory_t,
    pub old_memory: *mut lxb_css_memory_t,
    pub rules_begin: *mut lxb_css_syntax_rule_t,
    pub rules_end: *mut lxb_css_syntax_rule_t,
    pub rules: *mut lxb_css_syntax_rule_t,
    pub states_begin: *mut lxb_css_parser_state_t,
    pub states_end: *mut lxb_css_parser_state_t,
    pub states: *mut lxb_css_parser_state_t,
    pub types_begin: *mut lxb_css_syntax_token_type_t,
    pub types_end: *mut lxb_css_syntax_token_type_t,
    pub types_pos: *mut lxb_css_syntax_token_type_t,
    pub chunk_cb: lxb_css_syntax_tokenizer_chunk_f,
    pub chunk_ctx: *mut cty::c_void,
    pub pos: *const lxb_char_t,
    pub offset: usize,
    pub str_: lexbor_str_t,
    pub str_size: usize,
    pub log: *mut lxb_css_log_t,
    pub stage: lxb_css_parser_stage_t,
    pub loop_: bool,
    pub fake_null: bool,
    pub my_tkz: bool,
    pub receive_endings: bool,
    pub status: lxb_status_t,
}
#[test]
fn bindgen_test_layout_lxb_css_parser() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_parser> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_parser>(),
        208usize,
        concat!("Size of: ", stringify!(lxb_css_parser))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_parser>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_parser))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tkz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(tkz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selectors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(selectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old_selectors) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(old_selectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old_memory) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(old_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rules_begin) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(rules_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rules_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(rules_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rules) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(rules)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).states_begin) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(states_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).states_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(states_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).states) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(states)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).types_begin) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(types_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).types_end) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(types_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).types_pos) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(types_pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_cb) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(chunk_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_ctx) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(chunk_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_size) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(str_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stage) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loop_) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fake_null) as usize - ptr as usize },
        197usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(fake_null)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).my_tkz) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(my_tkz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).receive_endings) as usize - ptr as usize },
        199usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(receive_endings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser),
            "::",
            stringify!(status)
        )
    );
}
impl Default for lxb_css_parser {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_parser_state {
    pub state: lxb_css_parser_state_f,
    pub context: *mut cty::c_void,
    pub root: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_parser_state() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_parser_state> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_parser_state>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_parser_state))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_parser_state>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_parser_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser_state),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser_state),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser_state),
            "::",
            stringify!(root)
        )
    );
}
impl Default for lxb_css_parser_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_parser_error {
    pub message: lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_css_parser_error() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_parser_error> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_parser_error>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_parser_error))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_parser_error>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_parser_error))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_parser_error),
            "::",
            stringify!(message)
        )
    );
}
impl Default for lxb_css_parser_error {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_parser_create() -> *mut lxb_css_parser_t;
}
extern "C" {
    pub fn lxb_css_parser_init(
        parser: *mut lxb_css_parser_t,
        tkz: *mut lxb_css_syntax_tokenizer_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_parser_clean(parser: *mut lxb_css_parser_t);
}
extern "C" {
    pub fn lxb_css_parser_erase(parser: *mut lxb_css_parser_t);
}
extern "C" {
    pub fn lxb_css_parser_destroy(
        parser: *mut lxb_css_parser_t,
        self_destroy: bool,
    ) -> *mut lxb_css_parser_t;
}
extern "C" {
    pub fn lxb_css_parser_states_push(
        parser: *mut lxb_css_parser_t,
        state: lxb_css_parser_state_f,
        context: *mut cty::c_void,
        stop: bool,
    ) -> *mut lxb_css_parser_state_t;
}
extern "C" {
    pub fn lxb_css_parser_states_next(
        parser: *mut lxb_css_parser_t,
        next: lxb_css_parser_state_f,
        back: lxb_css_parser_state_f,
        ctx: *mut cty::c_void,
        root: bool,
    ) -> *mut lxb_css_parser_state_t;
}
extern "C" {
    pub fn lxb_css_parser_types_push(
        parser: *mut lxb_css_parser_t,
        type_: lxb_css_syntax_token_type_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_parser_stop(parser: *mut lxb_css_parser_t) -> bool;
}
extern "C" {
    pub fn lxb_css_parser_fail(parser: *mut lxb_css_parser_t, status: lxb_status_t) -> bool;
}
extern "C" {
    pub fn lxb_css_parser_unexpected(parser: *mut lxb_css_parser_t) -> bool;
}
extern "C" {
    pub fn lxb_css_parser_success(parser: *mut lxb_css_parser_t) -> bool;
}
extern "C" {
    pub fn lxb_css_parser_failed(parser: *mut lxb_css_parser_t) -> bool;
}
extern "C" {
    pub fn lxb_css_parser_unexpected_status(parser: *mut lxb_css_parser_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_parser_unexpected_data(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_parser_unexpected_data_status(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_parser_memory_fail(parser: *mut lxb_css_parser_t) -> bool;
}
extern "C" {
    pub fn lxb_css_parser_memory_fail_status(parser: *mut lxb_css_parser_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_unit_absolute_relative_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_unit_absolute_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_unit_relative_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_unit_angel_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_unit_frequency_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_unit_resolution_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_unit_duration_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_unit_by_id(id: lxb_css_type_t) -> *const lxb_css_data_t;
}
extern "C" {
    pub fn lxb_css_state_success(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_state_failed(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_state_stop(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_declaration_list_prepare(
        parser: *mut lxb_css_parser_t,
        mem: *mut lxb_css_memory_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_declaration_list_process(
        parser: *mut lxb_css_parser_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_rule_declaration_list_t;
}
extern "C" {
    pub fn lxb_css_declaration_list_finish(parser: *mut lxb_css_parser_t);
}
extern "C" {
    pub fn lxb_css_declaration_list_parse(
        parser: *mut lxb_css_parser_t,
        mem: *mut lxb_css_memory_t,
        data: *const lxb_char_t,
        length: usize,
    ) -> *mut lxb_css_rule_declaration_list_t;
}
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_UNEOF:
    lxb_css_syntax_tokenizer_error_id_t = 0;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_EOINCO:
    lxb_css_syntax_tokenizer_error_id_t = 1;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_EOINST:
    lxb_css_syntax_tokenizer_error_id_t = 2;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_EOINUR:
    lxb_css_syntax_tokenizer_error_id_t = 3;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_QOINUR:
    lxb_css_syntax_tokenizer_error_id_t = 4;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_WRESINUR:
    lxb_css_syntax_tokenizer_error_id_t = 5;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_NEINST:
    lxb_css_syntax_tokenizer_error_id_t = 6;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_BACH:
    lxb_css_syntax_tokenizer_error_id_t = 7;
pub const lxb_css_syntax_tokenizer_error_id_t_LXB_CSS_SYNTAX_TOKENIZER_ERROR_BACOPO:
    lxb_css_syntax_tokenizer_error_id_t = 8;
pub type lxb_css_syntax_tokenizer_error_id_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_syntax_tokenizer_error_t {
    pub pos: *const lxb_char_t,
    pub id: lxb_css_syntax_tokenizer_error_id_t,
}
#[test]
fn bindgen_test_layout_lxb_css_syntax_tokenizer_error_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_syntax_tokenizer_error_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_syntax_tokenizer_error_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_css_syntax_tokenizer_error_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_syntax_tokenizer_error_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_syntax_tokenizer_error_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer_error_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_syntax_tokenizer_error_t),
            "::",
            stringify!(id)
        )
    );
}
impl Default for lxb_css_syntax_tokenizer_error_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_syntax_tokenizer_error_add(
        parse_errors: *mut lexbor_array_obj_t,
        pos: *const lxb_char_t,
        id: lxb_css_syntax_tokenizer_error_id_t,
    ) -> *mut lxb_css_syntax_tokenizer_error_t;
}
extern "C" {
    pub fn lxb_css_selectors_state_complex_list(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_compound_list(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_simple_list(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_relative_list(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_relative(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_complex(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_compound(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_simple(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
    ) -> bool;
}
extern "C" {
    pub fn lxb_css_selectors_state_function_end(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
        failed: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selectors_state_function_forgiving(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
        failed: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_selectors_state_function_forgiving_relative(
        parser: *mut lxb_css_parser_t,
        token: *const lxb_css_syntax_token_t,
        ctx: *mut cty::c_void,
        failed: bool,
    ) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_selectors_pseudo_data_func_t {
    pub name: *mut lxb_char_t,
    pub length: usize,
    pub id: cty::c_uint,
    pub empty: bool,
    pub combinator: lxb_css_selector_combinator_t,
    pub cb: lxb_css_syntax_cb_function_t,
    pub forgiving: bool,
    pub comma: bool,
}
#[test]
fn bindgen_test_layout_lxb_css_selectors_pseudo_data_func_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selectors_pseudo_data_func_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selectors_pseudo_data_func_t>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selectors_pseudo_data_func_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_css_selectors_pseudo_data_func_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).empty) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).combinator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(combinator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forgiving) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(forgiving)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comma) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_func_t),
            "::",
            stringify!(comma)
        )
    );
}
impl Default for lxb_css_selectors_pseudo_data_func_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_css_selectors_pseudo_data_t {
    pub name: *mut lxb_char_t,
    pub length: usize,
    pub id: cty::c_uint,
}
#[test]
fn bindgen_test_layout_lxb_css_selectors_pseudo_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_css_selectors_pseudo_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_css_selectors_pseudo_data_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_css_selectors_pseudo_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_css_selectors_pseudo_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_css_selectors_pseudo_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_css_selectors_pseudo_data_t),
            "::",
            stringify!(id)
        )
    );
}
impl Default for lxb_css_selectors_pseudo_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_css_selector_pseudo_class_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_selectors_pseudo_data_t;
}
extern "C" {
    pub fn lxb_css_selector_pseudo_class_function_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_selectors_pseudo_data_func_t;
}
extern "C" {
    pub fn lxb_css_selector_pseudo_class_function_by_id(
        id: cty::c_uint,
    ) -> *const lxb_css_selectors_pseudo_data_func_t;
}
extern "C" {
    pub fn lxb_css_selector_pseudo_element_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_selectors_pseudo_data_t;
}
extern "C" {
    pub fn lxb_css_selector_pseudo_element_function_by_name(
        name: *const lxb_char_t,
        length: usize,
    ) -> *const lxb_css_selectors_pseudo_data_func_t;
}
extern "C" {
    pub fn lxb_css_selector_pseudo_element_function_by_id(
        id: cty::c_uint,
    ) -> *const lxb_css_selectors_pseudo_data_func_t;
}
extern "C" {
    pub fn lxb_css_selector_pseudo_function_by_id(
        id: cty::c_uint,
        is_class: bool,
    ) -> *const lxb_css_selectors_pseudo_data_func_t;
}
extern "C" {
    pub fn lxb_css_selector_pseudo_function_can_empty(id: cty::c_uint, is_class: bool) -> bool;
}
extern "C" {
    pub fn lxb_css_make_data(
        parser: *mut lxb_css_parser_t,
        str_: *mut lexbor_str_t,
        begin: usize,
        end: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_css_serialize_char_handler(
        style: *const cty::c_void,
        cb: lxb_css_style_serialize_f,
        out_length: *mut usize,
    ) -> *mut lxb_char_t;
}
extern "C" {
    pub fn lxb_css_serialize_str_handler(
        style: *const cty::c_void,
        str_: *mut lexbor_str_t,
        mraw: *mut lexbor_mraw_t,
        cb: lxb_css_style_serialize_f,
    ) -> lxb_status_t;
}
pub type lxb_selectors_cb_f = ::core::option::Option<
    unsafe extern "C" fn(
        node: *mut lxb_dom_node_t,
        spec: lxb_css_selector_specificity_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
pub type lxb_selectors_entry_t = lxb_selectors_entry;
pub type lxb_selectors_entry_child_t = lxb_selectors_entry_child;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_selectors_t {
    pub objs: *mut lexbor_dobject_t,
    pub chld: *mut lexbor_dobject_t,
    pub status: lxb_status_t,
}
#[test]
fn bindgen_test_layout_lxb_selectors_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_selectors_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_selectors_t>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_selectors_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_selectors_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_selectors_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).objs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_t),
            "::",
            stringify!(objs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chld) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_t),
            "::",
            stringify!(chld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_t),
            "::",
            stringify!(status)
        )
    );
}
impl Default for lxb_selectors_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_selectors_entry {
    pub id: usize,
    pub selector: *mut lxb_css_selector_t,
    pub node: *mut lxb_dom_node_t,
    pub next: *mut lxb_selectors_entry_t,
    pub prev: *mut lxb_selectors_entry_t,
    pub child: *mut lxb_selectors_entry_child_t,
}
#[test]
fn bindgen_test_layout_lxb_selectors_entry() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_selectors_entry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_selectors_entry>(),
        48usize,
        concat!("Size of: ", stringify!(lxb_selectors_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_selectors_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_selectors_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selector) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry),
            "::",
            stringify!(selector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry),
            "::",
            stringify!(child)
        )
    );
}
impl Default for lxb_selectors_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_selectors_entry_child {
    pub entry: *mut lxb_selectors_entry_t,
    pub next: *mut lxb_selectors_entry_child_t,
}
#[test]
fn bindgen_test_layout_lxb_selectors_entry_child() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_selectors_entry_child> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_selectors_entry_child>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_selectors_entry_child))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_selectors_entry_child>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_selectors_entry_child))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry_child),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_selectors_entry_child),
            "::",
            stringify!(next)
        )
    );
}
impl Default for lxb_selectors_entry_child {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_selectors_create() -> *mut lxb_selectors_t;
}
extern "C" {
    pub fn lxb_selectors_init(selectors: *mut lxb_selectors_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_selectors_clean(selectors: *mut lxb_selectors_t);
}
extern "C" {
    pub fn lxb_selectors_destroy(
        selectors: *mut lxb_selectors_t,
        self_destroy: bool,
    ) -> *mut lxb_selectors_t;
}
extern "C" {
    pub fn lxb_selectors_find(
        selectors: *mut lxb_selectors_t,
        root: *mut lxb_dom_node_t,
        list: *mut lxb_css_selector_list_t,
        cb: lxb_selectors_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_selectors_find_reverse(
        selectors: *mut lxb_selectors_t,
        root: *mut lxb_dom_node_t,
        list: *mut lxb_css_selector_list_t,
        cb: lxb_selectors_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
pub type lxb_html_document_done_cb_f = ::core::option::Option<
    unsafe extern "C" fn(document: *mut lxb_html_document_t) -> lxb_status_t,
>;
pub type lxb_html_document_opt_t = cty::c_uint;
pub const lxb_html_document_ready_state_t_LXB_HTML_DOCUMENT_READY_STATE_UNDEF:
    lxb_html_document_ready_state_t = 0;
pub const lxb_html_document_ready_state_t_LXB_HTML_DOCUMENT_READY_STATE_LOADING:
    lxb_html_document_ready_state_t = 1;
pub const lxb_html_document_ready_state_t_LXB_HTML_DOCUMENT_READY_STATE_INTERACTIVE:
    lxb_html_document_ready_state_t = 2;
pub const lxb_html_document_ready_state_t_LXB_HTML_DOCUMENT_READY_STATE_COMPLETE:
    lxb_html_document_ready_state_t = 3;
pub type lxb_html_document_ready_state_t = cty::c_int;
pub const lxb_html_document_opt_LXB_HTML_DOCUMENT_OPT_UNDEF: lxb_html_document_opt = 0;
pub const lxb_html_document_opt_LXB_HTML_DOCUMENT_PARSE_WO_COPY: lxb_html_document_opt = 1;
pub type lxb_html_document_opt = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_document_css_t {
    pub memory: *mut lxb_css_memory_t,
    pub css_selectors: *mut lxb_css_selectors_t,
    pub parser: *mut lxb_css_parser_t,
    pub selectors: *mut lxb_selectors_t,
    pub styles: *mut lexbor_avl_t,
    pub stylesheets: *mut lexbor_array_t,
    pub weak: *mut lexbor_dobject_t,
    pub customs: *mut lexbor_hash_t,
    pub customs_id: usize,
}
#[test]
fn bindgen_test_layout_lxb_html_document_css_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_document_css_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_document_css_t>(),
        72usize,
        concat!("Size of: ", stringify!(lxb_html_document_css_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_document_css_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_document_css_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).css_selectors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(css_selectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parser) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selectors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(selectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).styles) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(styles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stylesheets) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(stylesheets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).weak) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(weak)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).customs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(customs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).customs_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document_css_t),
            "::",
            stringify!(customs_id)
        )
    );
}
impl Default for lxb_html_document_css_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_document {
    pub dom_document: lxb_dom_document_t,
    pub iframe_srcdoc: *mut cty::c_void,
    pub head: *mut lxb_html_head_element_t,
    pub body: *mut lxb_html_body_element_t,
    pub css: lxb_html_document_css_t,
    pub css_init: bool,
    pub done: lxb_html_document_done_cb_f,
    pub ready_state: lxb_html_document_ready_state_t,
    pub opt: lxb_html_document_opt_t,
}
#[test]
fn bindgen_test_layout_lxb_html_document() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_document> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_document>(),
        368usize,
        concat!("Size of: ", stringify!(lxb_html_document))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_document>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_document))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dom_document) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(dom_document)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iframe_srcdoc) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(iframe_srcdoc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).css) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(css)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).css_init) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(css_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).done) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ready_state) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(ready_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_document),
            "::",
            stringify!(opt)
        )
    );
}
impl Default for lxb_html_document {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_document_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_document_t;
}
extern "C" {
    pub fn lxb_html_document_interface_destroy(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_document_t;
}
extern "C" {
    pub fn lxb_html_document_create() -> *mut lxb_html_document_t;
}
extern "C" {
    pub fn lxb_html_document_clean(document: *mut lxb_html_document_t);
}
extern "C" {
    pub fn lxb_html_document_destroy(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_document_t;
}
extern "C" {
    pub fn lxb_html_document_css_init(document: *mut lxb_html_document_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_css_destroy(document: *mut lxb_html_document_t);
}
extern "C" {
    pub fn lxb_html_document_css_clean(document: *mut lxb_html_document_t);
}
extern "C" {
    pub fn lxb_html_document_css_parser_attach(
        document: *mut lxb_html_document_t,
        parser: *mut lxb_css_parser_t,
    );
}
extern "C" {
    pub fn lxb_html_document_css_memory_attach(
        document: *mut lxb_html_document_t,
        memory: *mut lxb_css_memory_t,
    );
}
extern "C" {
    pub fn lxb_html_document_css_customs_find_id(
        document: *mut lxb_html_document_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> usize;
}
extern "C" {
    pub fn lxb_html_document_css_customs_id(
        document: *mut lxb_html_document_t,
        key: *const lxb_char_t,
        length: usize,
    ) -> usize;
}
extern "C" {
    pub fn lxb_html_document_stylesheet_attach(
        document: *mut lxb_html_document_t,
        sst: *mut lxb_css_stylesheet_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_stylesheet_apply(
        document: *mut lxb_html_document_t,
        sst: *mut lxb_css_stylesheet_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_stylesheet_add(
        document: *mut lxb_html_document_t,
        sst: *mut lxb_css_stylesheet_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_stylesheet_remove(
        document: *mut lxb_html_document_t,
        sst: *mut lxb_css_stylesheet_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_element_styles_attach(
        element: *mut lxb_html_element_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_stylesheet_destroy_all(
        document: *mut lxb_html_document_t,
        destroy_memory: bool,
    );
}
extern "C" {
    pub fn lxb_html_document_style_attach(
        document: *mut lxb_html_document_t,
        style: *mut lxb_css_rule_style_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_style_remove(
        document: *mut lxb_html_document_t,
        style: *mut lxb_css_rule_style_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_style_attach_by_element(
        document: *mut lxb_html_document_t,
        element: *mut lxb_html_element_t,
        style: *mut lxb_css_rule_style_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_css_customs_init(document: *mut lxb_html_document_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_css_customs_destroy(document: *mut lxb_html_document_t);
}
extern "C" {
    pub fn lxb_html_document_parse(
        document: *mut lxb_html_document_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_parse_chunk_begin(document: *mut lxb_html_document_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_parse_chunk(
        document: *mut lxb_html_document_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_parse_chunk_end(document: *mut lxb_html_document_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_parse_fragment(
        document: *mut lxb_html_document_t,
        element: *mut lxb_dom_element_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_document_parse_fragment_chunk_begin(
        document: *mut lxb_html_document_t,
        element: *mut lxb_dom_element_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_parse_fragment_chunk(
        document: *mut lxb_html_document_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_parse_fragment_chunk_end(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_document_title(
        document: *mut lxb_html_document_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_document_title_set(
        document: *mut lxb_html_document_t,
        title: *const lxb_char_t,
        len: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_document_title_raw(
        document: *mut lxb_html_document_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_document_import_node(
        doc: *mut lxb_html_document_t,
        node: *mut lxb_dom_node_t,
        deep: bool,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_document_head_element_noi(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_head_element_t;
}
extern "C" {
    pub fn lxb_html_document_body_element_noi(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_body_element_t;
}
extern "C" {
    pub fn lxb_html_document_original_ref_noi(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_dom_document_t;
}
extern "C" {
    pub fn lxb_html_document_is_original_noi(document: *mut lxb_html_document_t) -> bool;
}
extern "C" {
    pub fn lxb_html_document_mraw_noi(document: *mut lxb_html_document_t) -> *mut lexbor_mraw_t;
}
extern "C" {
    pub fn lxb_html_document_mraw_text_noi(
        document: *mut lxb_html_document_t,
    ) -> *mut lexbor_mraw_t;
}
extern "C" {
    pub fn lxb_html_document_opt_set_noi(
        document: *mut lxb_html_document_t,
        opt: lxb_html_document_opt_t,
    );
}
extern "C" {
    pub fn lxb_html_document_opt_noi(document: *mut lxb_html_document_t)
        -> lxb_html_document_opt_t;
}
extern "C" {
    pub fn lxb_html_document_create_struct_noi(
        document: *mut lxb_html_document_t,
        struct_size: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_html_document_destroy_struct_noi(
        document: *mut lxb_html_document_t,
        data: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn lxb_html_document_create_element_noi(
        document: *mut lxb_html_document_t,
        local_name: *const lxb_char_t,
        lname_len: usize,
        reserved_for_opt: *mut cty::c_void,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_document_destroy_element_noi(
        element: *mut lxb_dom_element_t,
    ) -> *mut lxb_dom_element_t;
}
pub type lxb_html_tag_category_t = cty::c_int;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY__UNDEF: lxb_html_tag_category = 0;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_ORDINARY: lxb_html_tag_category = 1;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_SPECIAL: lxb_html_tag_category = 2;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_FORMATTING: lxb_html_tag_category = 4;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_SCOPE: lxb_html_tag_category = 8;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_SCOPE_LIST_ITEM: lxb_html_tag_category = 16;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_SCOPE_BUTTON: lxb_html_tag_category = 32;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_SCOPE_TABLE: lxb_html_tag_category = 64;
pub const lxb_html_tag_category_LXB_HTML_TAG_CATEGORY_SCOPE_SELECT: lxb_html_tag_category = 128;
pub type lxb_html_tag_category = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_tag_fixname_t {
    pub name: *const lxb_char_t,
    pub len: cty::c_uint,
}
#[test]
fn bindgen_test_layout_lxb_html_tag_fixname_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_tag_fixname_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_tag_fixname_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_html_tag_fixname_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_tag_fixname_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_tag_fixname_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tag_fixname_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tag_fixname_t),
            "::",
            stringify!(len)
        )
    );
}
impl Default for lxb_html_tag_fixname_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut lxb_html_tag_res_cats: [[lxb_html_tag_category_t; 8usize]; 196usize];
}
extern "C" {
    pub static mut lxb_html_tag_res_fixname_svg: [lxb_html_tag_fixname_t; 196usize];
}
pub type lxb_html_tree_insertion_mode_f = ::core::option::Option<
    unsafe extern "C" fn(tree: *mut lxb_html_tree_t, token: *mut lxb_html_token_t) -> bool,
>;
pub type lxb_html_tree_append_attr_f = ::core::option::Option<
    unsafe extern "C" fn(
        tree: *mut lxb_html_tree_t,
        attr: *mut lxb_dom_attr_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_tree_pending_table_t {
    pub text_list: *mut lexbor_array_obj_t,
    pub have_non_ws: bool,
}
#[test]
fn bindgen_test_layout_lxb_html_tree_pending_table_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_tree_pending_table_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_tree_pending_table_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_html_tree_pending_table_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_tree_pending_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_tree_pending_table_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree_pending_table_t),
            "::",
            stringify!(text_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).have_non_ws) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree_pending_table_t),
            "::",
            stringify!(have_non_ws)
        )
    );
}
impl Default for lxb_html_tree_pending_table_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_tree {
    pub tkz_ref: *mut lxb_html_tokenizer_t,
    pub document: *mut lxb_html_document_t,
    pub fragment: *mut lxb_dom_node_t,
    pub form: *mut lxb_html_form_element_t,
    pub open_elements: *mut lexbor_array_t,
    pub active_formatting: *mut lexbor_array_t,
    pub template_insertion_modes: *mut lexbor_array_obj_t,
    pub pending_table: lxb_html_tree_pending_table_t,
    pub parse_errors: *mut lexbor_array_obj_t,
    pub foster_parenting: bool,
    pub frameset_ok: bool,
    pub scripting: bool,
    pub mode: lxb_html_tree_insertion_mode_f,
    pub original_mode: lxb_html_tree_insertion_mode_f,
    pub before_append_attr: lxb_html_tree_append_attr_f,
    pub status: lxb_status_t,
    pub ref_count: usize,
}
#[test]
fn bindgen_test_layout_lxb_html_tree() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_tree> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_tree>(),
        128usize,
        concat!("Size of: ", stringify!(lxb_html_tree))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_tree>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_tree))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tkz_ref) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(tkz_ref)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).document) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(document)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fragment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(fragment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).form) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(form)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open_elements) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(open_elements)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).active_formatting) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(active_formatting)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).template_insertion_modes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(template_insertion_modes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending_table) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(pending_table)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).foster_parenting) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(foster_parenting)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameset_ok) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(frameset_ok)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scripting) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(scripting)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).original_mode) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(original_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).before_append_attr) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(before_append_attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree),
            "::",
            stringify!(ref_count)
        )
    );
}
impl Default for lxb_html_tree {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const lxb_html_tree_insertion_position_t_LXB_HTML_TREE_INSERTION_POSITION_CHILD:
    lxb_html_tree_insertion_position_t = 0;
pub const lxb_html_tree_insertion_position_t_LXB_HTML_TREE_INSERTION_POSITION_BEFORE:
    lxb_html_tree_insertion_position_t = 1;
pub type lxb_html_tree_insertion_position_t = cty::c_int;
extern "C" {
    pub fn lxb_html_tree_create() -> *mut lxb_html_tree_t;
}
extern "C" {
    pub fn lxb_html_tree_init(
        tree: *mut lxb_html_tree_t,
        tkz: *mut lxb_html_tokenizer_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_ref(tree: *mut lxb_html_tree_t) -> *mut lxb_html_tree_t;
}
extern "C" {
    pub fn lxb_html_tree_unref(tree: *mut lxb_html_tree_t) -> *mut lxb_html_tree_t;
}
extern "C" {
    pub fn lxb_html_tree_clean(tree: *mut lxb_html_tree_t);
}
extern "C" {
    pub fn lxb_html_tree_destroy(tree: *mut lxb_html_tree_t) -> *mut lxb_html_tree_t;
}
extern "C" {
    pub fn lxb_html_tree_stop_parsing(tree: *mut lxb_html_tree_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_process_abort(tree: *mut lxb_html_tree_t) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_parse_error(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
        id: lxb_html_tree_error_id_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_construction_dispatcher(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_appropriate_place_inserting_node(
        tree: *mut lxb_html_tree_t,
        override_target: *mut lxb_dom_node_t,
        ipos: *mut lxb_html_tree_insertion_position_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_insert_foreign_element(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
        ns: lxb_ns_id_t,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_tree_create_element_for_token(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
        ns: lxb_ns_id_t,
        parent: *mut lxb_dom_node_t,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_tree_append_attributes(
        tree: *mut lxb_html_tree_t,
        element: *mut lxb_dom_element_t,
        token: *mut lxb_html_token_t,
        ns: lxb_ns_id_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_append_attributes_from_element(
        tree: *mut lxb_html_tree_t,
        element: *mut lxb_dom_element_t,
        from: *mut lxb_dom_element_t,
        ns: lxb_ns_id_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_adjust_mathml_attributes(
        tree: *mut lxb_html_tree_t,
        attr: *mut lxb_dom_attr_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_adjust_svg_attributes(
        tree: *mut lxb_html_tree_t,
        attr: *mut lxb_dom_attr_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_adjust_foreign_attributes(
        tree: *mut lxb_html_tree_t,
        attr: *mut lxb_dom_attr_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_insert_character(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
        ret_node: *mut *mut lxb_dom_node_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_insert_character_for_data(
        tree: *mut lxb_html_tree_t,
        str_: *mut lexbor_str_t,
        ret_node: *mut *mut lxb_dom_node_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_insert_comment(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
        pos: *mut lxb_dom_node_t,
    ) -> *mut lxb_dom_comment_t;
}
extern "C" {
    pub fn lxb_html_tree_create_document_type_from_token(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> *mut lxb_dom_document_type_t;
}
extern "C" {
    pub fn lxb_html_tree_node_delete_deep(tree: *mut lxb_html_tree_t, node: *mut lxb_dom_node_t);
}
extern "C" {
    pub fn lxb_html_tree_generic_rawtext_parsing(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_tree_generic_rcdata_parsing(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_tree_generate_implied_end_tags(
        tree: *mut lxb_html_tree_t,
        ex_tag: lxb_tag_id_t,
        ex_ns: lxb_ns_id_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_generate_all_implied_end_tags_thoroughly(
        tree: *mut lxb_html_tree_t,
        ex_tag: lxb_tag_id_t,
        ex_ns: lxb_ns_id_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_reset_insertion_mode_appropriately(tree: *mut lxb_html_tree_t);
}
extern "C" {
    pub fn lxb_html_tree_element_in_scope(
        tree: *mut lxb_html_tree_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
        ct: lxb_html_tag_category_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_element_in_scope_by_node(
        tree: *mut lxb_html_tree_t,
        by_node: *mut lxb_dom_node_t,
        ct: lxb_html_tag_category_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_element_in_scope_h123456(
        tree: *mut lxb_html_tree_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_element_in_scope_tbody_thead_tfoot(
        tree: *mut lxb_html_tree_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_element_in_scope_td_th(tree: *mut lxb_html_tree_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_check_scope_element(tree: *mut lxb_html_tree_t) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_close_p_element(tree: *mut lxb_html_tree_t, token: *mut lxb_html_token_t);
}
extern "C" {
    pub fn lxb_html_tree_adoption_agency_algorithm(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
        status: *mut lxb_status_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_html_integration_point(node: *mut lxb_dom_node_t) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_adjust_attributes_mathml(
        tree: *mut lxb_html_tree_t,
        attr: *mut lxb_dom_attr_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_adjust_attributes_svg(
        tree: *mut lxb_html_tree_t,
        attr: *mut lxb_dom_attr_t,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_begin_noi(
        tree: *mut lxb_html_tree_t,
        document: *mut lxb_html_document_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_chunk_noi(
        tree: *mut lxb_html_tree_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_end_noi(tree: *mut lxb_html_tree_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_build_noi(
        tree: *mut lxb_html_tree_t,
        document: *mut lxb_html_document_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_create_node_noi(
        tree: *mut lxb_html_tree_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_node_is_noi(node: *mut lxb_dom_node_t, tag_id: lxb_tag_id_t) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_current_node_noi(tree: *mut lxb_html_tree_t) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_adjusted_current_node_noi(
        tree: *mut lxb_html_tree_t,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_insert_html_element_noi(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_tree_insert_node_noi(
        to: *mut lxb_dom_node_t,
        node: *mut lxb_dom_node_t,
        ipos: lxb_html_tree_insertion_position_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_acknowledge_token_self_closing_noi(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_mathml_text_integration_point_noi(node: *mut lxb_dom_node_t) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_scripting_noi(tree: *mut lxb_html_tree_t) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_scripting_set_noi(tree: *mut lxb_html_tree_t, scripting: bool);
}
extern "C" {
    pub fn lxb_html_tree_attach_document_noi(
        tree: *mut lxb_html_tree_t,
        doc: *mut lxb_html_document_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_initial(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_before_html(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_before_head(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_head(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_head_noscript(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_after_head(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_body(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_body_skip_new_line(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_body_skip_new_line_textarea(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_body_text_append(
        tree: *mut lxb_html_tree_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_text(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_table(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_table_anything_else(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_table_text(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_caption(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_column_group(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_table_body(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_row(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_cell(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_select(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_select_in_table(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_template(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_after_body(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_in_frameset(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_after_frameset(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_after_after_body(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_after_after_frameset(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_insertion_mode_foreign_content(
        tree: *mut lxb_html_tree_t,
        token: *mut lxb_html_token_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lxb_html_tree_template_insertion_t {
    pub mode: lxb_html_tree_insertion_mode_f,
}
#[test]
fn bindgen_test_layout_lxb_html_tree_template_insertion_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_tree_template_insertion_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_tree_template_insertion_t>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_html_tree_template_insertion_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_tree_template_insertion_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lxb_html_tree_template_insertion_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_tree_template_insertion_t),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_marker() -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_up_to_last_marker(tree: *mut lxb_html_tree_t);
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_remove_by_node(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_find_by_node(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
        return_pos: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_find_by_node_reverse(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
        return_pos: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_reconstruct_elements(
        tree: *mut lxb_html_tree_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_between_last_marker(
        tree: *mut lxb_html_tree_t,
        tag_idx: lxb_tag_id_t,
        return_idx: *mut usize,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_active_formatting_push_with_check_dupl(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_open_elements_remove_by_node(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
    );
}
extern "C" {
    pub fn lxb_html_tree_open_elements_pop_until_tag_id(
        tree: *mut lxb_html_tree_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
        exclude: bool,
    );
}
extern "C" {
    pub fn lxb_html_tree_open_elements_pop_until_h123456(tree: *mut lxb_html_tree_t);
}
extern "C" {
    pub fn lxb_html_tree_open_elements_pop_until_td_th(tree: *mut lxb_html_tree_t);
}
extern "C" {
    pub fn lxb_html_tree_open_elements_pop_until_node(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
        exclude: bool,
    );
}
extern "C" {
    pub fn lxb_html_tree_open_elements_pop_until(
        tree: *mut lxb_html_tree_t,
        idx: usize,
        exclude: bool,
    );
}
extern "C" {
    pub fn lxb_html_tree_open_elements_find_by_node(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
        return_pos: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_open_elements_find_by_node_reverse(
        tree: *mut lxb_html_tree_t,
        node: *mut lxb_dom_node_t,
        return_pos: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn lxb_html_tree_open_elements_find(
        tree: *mut lxb_html_tree_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
        return_index: *mut usize,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_tree_open_elements_find_reverse(
        tree: *mut lxb_html_tree_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
        return_index: *mut usize,
    ) -> *mut lxb_dom_node_t;
}
pub const lxb_html_parser_state_t_LXB_HTML_PARSER_STATE_BEGIN: lxb_html_parser_state_t = 0;
pub const lxb_html_parser_state_t_LXB_HTML_PARSER_STATE_PROCESS: lxb_html_parser_state_t = 1;
pub const lxb_html_parser_state_t_LXB_HTML_PARSER_STATE_END: lxb_html_parser_state_t = 2;
pub const lxb_html_parser_state_t_LXB_HTML_PARSER_STATE_FRAGMENT_PROCESS: lxb_html_parser_state_t =
    3;
pub const lxb_html_parser_state_t_LXB_HTML_PARSER_STATE_ERROR: lxb_html_parser_state_t = 4;
pub type lxb_html_parser_state_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_parser_t {
    pub tkz: *mut lxb_html_tokenizer_t,
    pub tree: *mut lxb_html_tree_t,
    pub original_tree: *mut lxb_html_tree_t,
    pub root: *mut lxb_dom_node_t,
    pub form: *mut lxb_dom_node_t,
    pub state: lxb_html_parser_state_t,
    pub status: lxb_status_t,
    pub ref_count: usize,
}
#[test]
fn bindgen_test_layout_lxb_html_parser_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_parser_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_parser_t>(),
        56usize,
        concat!("Size of: ", stringify!(lxb_html_parser_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_parser_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_parser_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tkz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(tkz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tree) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).original_tree) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(original_tree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).form) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(form)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_parser_t),
            "::",
            stringify!(ref_count)
        )
    );
}
impl Default for lxb_html_parser_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_parser_create() -> *mut lxb_html_parser_t;
}
extern "C" {
    pub fn lxb_html_parser_init(parser: *mut lxb_html_parser_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_parser_clean(parser: *mut lxb_html_parser_t);
}
extern "C" {
    pub fn lxb_html_parser_destroy(parser: *mut lxb_html_parser_t) -> *mut lxb_html_parser_t;
}
extern "C" {
    pub fn lxb_html_parser_ref(parser: *mut lxb_html_parser_t) -> *mut lxb_html_parser_t;
}
extern "C" {
    pub fn lxb_html_parser_unref(parser: *mut lxb_html_parser_t) -> *mut lxb_html_parser_t;
}
extern "C" {
    pub fn lxb_html_parse(
        parser: *mut lxb_html_parser_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> *mut lxb_html_document_t;
}
extern "C" {
    pub fn lxb_html_parse_fragment(
        parser: *mut lxb_html_parser_t,
        element: *mut lxb_html_element_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_parse_fragment_by_tag_id(
        parser: *mut lxb_html_parser_t,
        document: *mut lxb_html_document_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_parse_chunk_begin(parser: *mut lxb_html_parser_t) -> *mut lxb_html_document_t;
}
extern "C" {
    pub fn lxb_html_parse_chunk_process(
        parser: *mut lxb_html_parser_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_parse_chunk_end(parser: *mut lxb_html_parser_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_parse_fragment_chunk_begin(
        parser: *mut lxb_html_parser_t,
        document: *mut lxb_html_document_t,
        tag_id: lxb_tag_id_t,
        ns: lxb_ns_id_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_parse_fragment_chunk_process(
        parser: *mut lxb_html_parser_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_parse_fragment_chunk_end(parser: *mut lxb_html_parser_t)
        -> *mut lxb_dom_node_t;
}
extern "C" {
    pub fn lxb_html_parser_tokenizer_noi(
        parser: *mut lxb_html_parser_t,
    ) -> *mut lxb_html_tokenizer_t;
}
extern "C" {
    pub fn lxb_html_parser_tree_noi(parser: *mut lxb_html_parser_t) -> *mut lxb_html_tree_t;
}
extern "C" {
    pub fn lxb_html_parser_status_noi(parser: *mut lxb_html_parser_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_parser_state_noi(parser: *mut lxb_html_parser_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_parser_scripting_noi(parser: *mut lxb_html_parser_t) -> bool;
}
extern "C" {
    pub fn lxb_html_parser_scripting_set_noi(parser: *mut lxb_html_parser_t, scripting: bool);
}
extern "C" {
    pub fn lxb_html_tokenizer_state_rawtext_before(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_script_data_before(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_comment_before_start(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_doctype_before(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_data_before(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_plaintext_before(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_before_attribute_name(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_self_closing_start_tag(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_cr(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_char_ref(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_tokenizer_state_rcdata_before(
        tkz: *mut lxb_html_tokenizer_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> *const lxb_char_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_encoding_entry_t {
    pub name: *const lxb_char_t,
    pub end: *const lxb_char_t,
}
#[test]
fn bindgen_test_layout_lxb_html_encoding_entry_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_encoding_entry_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_encoding_entry_t>(),
        16usize,
        concat!("Size of: ", stringify!(lxb_html_encoding_entry_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_encoding_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_encoding_entry_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_encoding_entry_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_encoding_entry_t),
            "::",
            stringify!(end)
        )
    );
}
impl Default for lxb_html_encoding_entry_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_encoding_t {
    pub cache: lexbor_array_obj_t,
    pub result: lexbor_array_obj_t,
}
#[test]
fn bindgen_test_layout_lxb_html_encoding_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_encoding_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_encoding_t>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_html_encoding_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_encoding_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_encoding_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_encoding_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_encoding_t),
            "::",
            stringify!(result)
        )
    );
}
impl Default for lxb_html_encoding_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_encoding_init(em: *mut lxb_html_encoding_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_encoding_destroy(
        em: *mut lxb_html_encoding_t,
        self_destroy: bool,
    ) -> *mut lxb_html_encoding_t;
}
extern "C" {
    pub fn lxb_html_encoding_determine(
        em: *mut lxb_html_encoding_t,
        data: *const lxb_char_t,
        end: *const lxb_char_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_encoding_content(
        data: *const lxb_char_t,
        end: *const lxb_char_t,
        name_end: *mut *const lxb_char_t,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_encoding_create_noi() -> *mut lxb_html_encoding_t;
}
extern "C" {
    pub fn lxb_html_encoding_clean_noi(em: *mut lxb_html_encoding_t);
}
extern "C" {
    pub fn lxb_html_encoding_meta_entry_noi(
        em: *mut lxb_html_encoding_t,
        idx: usize,
    ) -> *mut lxb_html_encoding_entry_t;
}
extern "C" {
    pub fn lxb_html_encoding_meta_length_noi(em: *mut lxb_html_encoding_t) -> usize;
}
extern "C" {
    pub fn lxb_html_encoding_meta_result_noi(
        em: *mut lxb_html_encoding_t,
    ) -> *mut lexbor_array_obj_t;
}
pub type lxb_html_serialize_opt_t = cty::c_int;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_UNDEF: lxb_html_serialize_opt = 0;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_SKIP_WS_NODES: lxb_html_serialize_opt = 1;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_SKIP_COMMENT: lxb_html_serialize_opt = 2;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_RAW: lxb_html_serialize_opt = 4;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_WITHOUT_CLOSING: lxb_html_serialize_opt = 8;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_TAG_WITH_NS: lxb_html_serialize_opt = 16;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_WITHOUT_TEXT_INDENT:
    lxb_html_serialize_opt = 32;
pub const lxb_html_serialize_opt_LXB_HTML_SERIALIZE_OPT_FULL_DOCTYPE: lxb_html_serialize_opt = 64;
pub type lxb_html_serialize_opt = cty::c_int;
pub type lxb_html_serialize_cb_f = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const lxb_char_t,
        len: usize,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t,
>;
extern "C" {
    pub fn lxb_html_serialize_cb(
        node: *mut lxb_dom_node_t,
        cb: lxb_html_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_str(
        node: *mut lxb_dom_node_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_tree_cb(
        node: *mut lxb_dom_node_t,
        cb: lxb_html_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_tree_str(
        node: *mut lxb_dom_node_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_deep_cb(
        node: *mut lxb_dom_node_t,
        cb: lxb_html_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_deep_str(
        node: *mut lxb_dom_node_t,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_pretty_cb(
        node: *mut lxb_dom_node_t,
        opt: lxb_html_serialize_opt_t,
        indent: usize,
        cb: lxb_html_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_pretty_str(
        node: *mut lxb_dom_node_t,
        opt: lxb_html_serialize_opt_t,
        indent: usize,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_pretty_tree_cb(
        node: *mut lxb_dom_node_t,
        opt: lxb_html_serialize_opt_t,
        indent: usize,
        cb: lxb_html_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_pretty_tree_str(
        node: *mut lxb_dom_node_t,
        opt: lxb_html_serialize_opt_t,
        indent: usize,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_pretty_deep_cb(
        node: *mut lxb_dom_node_t,
        opt: lxb_html_serialize_opt_t,
        indent: usize,
        cb: lxb_html_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_serialize_pretty_deep_str(
        node: *mut lxb_dom_node_t,
        opt: lxb_html_serialize_opt_t,
        indent: usize,
        str_: *mut lexbor_str_t,
    ) -> lxb_status_t;
}
pub type lxb_html_style_weak_t = lxb_html_style_weak;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_style_weak {
    pub value: *mut cty::c_void,
    pub sp: lxb_css_selector_specificity_t,
    pub next: *mut lxb_html_style_weak_t,
}
#[test]
fn bindgen_test_layout_lxb_html_style_weak() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_style_weak> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_style_weak>(),
        24usize,
        concat!("Size of: ", stringify!(lxb_html_style_weak))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_style_weak>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_style_weak))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_weak),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_weak),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_weak),
            "::",
            stringify!(next)
        )
    );
}
impl Default for lxb_html_style_weak {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_style_node_t {
    pub entry: lexbor_avl_node_t,
    pub weak: *mut lxb_html_style_weak_t,
    pub sp: lxb_css_selector_specificity_t,
}
#[test]
fn bindgen_test_layout_lxb_html_style_node_t() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_style_node_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_style_node_t>(),
        64usize,
        concat!("Size of: ", stringify!(lxb_html_style_node_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_style_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_style_node_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_node_t),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).weak) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_node_t),
            "::",
            stringify!(weak)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_node_t),
            "::",
            stringify!(sp)
        )
    );
}
impl Default for lxb_html_style_node_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_style_id_by_name(
        doc: *mut lxb_html_document_t,
        name: *const lxb_char_t,
        size: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_element {
    pub element: lxb_dom_element_t,
    pub style: *mut lexbor_avl_node_t,
    pub list: *mut lxb_css_rule_declaration_list_t,
}
#[test]
fn bindgen_test_layout_lxb_html_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_element> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_element),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).style) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_element),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_element),
            "::",
            stringify!(list)
        )
    );
}
impl Default for lxb_html_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const lxb_html_element_style_opt_t_LXB_HTML_ELEMENT_OPT_UNDEF: lxb_html_element_style_opt_t = 0;
pub type lxb_html_element_style_opt_t = cty::c_int;
pub type lxb_html_element_style_cb_f = ::core::option::Option<
    unsafe extern "C" fn(
        element: *mut lxb_html_element_t,
        declr: *const lxb_css_rule_declaration_t,
        ctx: *mut cty::c_void,
        spec: lxb_css_selector_specificity_t,
        is_weak: bool,
    ) -> lxb_status_t,
>;
extern "C" {
    pub fn lxb_html_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_element_interface_destroy(
        element: *mut lxb_html_element_t,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_element_inner_html_set(
        element: *mut lxb_html_element_t,
        html: *const lxb_char_t,
        size: usize,
    ) -> *mut lxb_html_element_t;
}
extern "C" {
    pub fn lxb_html_element_style_by_name(
        element: *mut lxb_html_element_t,
        name: *const lxb_char_t,
        size: usize,
    ) -> *const lxb_css_rule_declaration_t;
}
extern "C" {
    pub fn lxb_html_element_style_by_id(
        element: *mut lxb_html_element_t,
        id: usize,
    ) -> *const lxb_css_rule_declaration_t;
}
extern "C" {
    pub fn lxb_html_element_style_node_by_id(
        element: *mut lxb_html_element_t,
        id: usize,
    ) -> *const lxb_html_style_node_t;
}
extern "C" {
    pub fn lxb_html_element_style_node_by_name(
        element: *mut lxb_html_element_t,
        name: *const lxb_char_t,
        size: usize,
    ) -> *const lxb_html_style_node_t;
}
extern "C" {
    pub fn lxb_html_element_css_property_by_id(
        element: *mut lxb_html_element_t,
        id: usize,
    ) -> *const cty::c_void;
}
extern "C" {
    pub fn lxb_html_element_style_walk(
        element: *mut lxb_html_element_t,
        cb: lxb_html_element_style_cb_f,
        ctx: *mut cty::c_void,
        with_weak: bool,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_element_style_parse(
        element: *mut lxb_html_element_t,
        style: *const lxb_char_t,
        size: usize,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_element_style_append(
        element: *mut lxb_html_element_t,
        declr: *mut lxb_css_rule_declaration_t,
        spec: lxb_css_selector_specificity_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_element_style_list_append(
        element: *mut lxb_html_element_t,
        list: *mut lxb_css_rule_declaration_list_t,
        spec: lxb_css_selector_specificity_t,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_element_style_remove_by_id(element: *mut lxb_html_element_t, id: usize);
}
extern "C" {
    pub fn lxb_html_element_style_remove_by_name(
        element: *mut lxb_html_element_t,
        name: *const lxb_char_t,
        size: usize,
    );
}
extern "C" {
    pub fn lxb_html_element_style_remove_all_not(
        doc: *mut lxb_html_document_t,
        root: *mut *mut lexbor_avl_node_t,
        style: *mut lxb_html_style_node_t,
        bs: bool,
    ) -> *mut lxb_html_style_node_t;
}
extern "C" {
    pub fn lxb_html_element_style_remove_all(
        doc: *mut lxb_html_document_t,
        root: *mut *mut lexbor_avl_node_t,
        style: *mut lxb_html_style_node_t,
    ) -> *mut lxb_html_style_node_t;
}
extern "C" {
    pub fn lxb_html_element_style_remove_by_list(
        doc: *mut lxb_html_document_t,
        root: *mut *mut lexbor_avl_node_t,
        style: *mut lxb_html_style_node_t,
        list: *mut lxb_css_rule_declaration_list_t,
    ) -> *mut lxb_html_style_node_t;
}
extern "C" {
    pub fn lxb_html_element_style_serialize(
        element: *mut lxb_html_element_t,
        opt: lxb_html_element_style_opt_t,
        cb: lexbor_serialize_cb_f,
        ctx: *mut cty::c_void,
    ) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_element_style_serialize_str(
        element: *mut lxb_html_element_t,
        str_: *mut lexbor_str_t,
        opt: lxb_html_element_style_opt_t,
    ) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_media_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_media_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_media_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_media_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_media_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_media_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_media_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_media_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_media_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_media_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_media_element_t;
}
extern "C" {
    pub fn lxb_html_media_element_interface_destroy(
        media_element: *mut lxb_html_media_element_t,
    ) -> *mut lxb_html_media_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_video_element {
    pub media_element: lxb_html_media_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_video_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_video_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_video_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_video_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_video_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_video_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).media_element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_video_element),
            "::",
            stringify!(media_element)
        )
    );
}
impl Default for lxb_html_video_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_video_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_video_element_t;
}
extern "C" {
    pub fn lxb_html_video_element_interface_destroy(
        video_element: *mut lxb_html_video_element_t,
    ) -> *mut lxb_html_video_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_data_list_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_data_list_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_data_list_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_data_list_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_data_list_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_data_list_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_data_list_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_data_list_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_data_list_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_data_list_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_data_list_element_t;
}
extern "C" {
    pub fn lxb_html_data_list_element_interface_destroy(
        data_list_element: *mut lxb_html_data_list_element_t,
    ) -> *mut lxb_html_data_list_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_picture_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_picture_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_picture_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_picture_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_picture_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_picture_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_picture_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_picture_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_picture_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_picture_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_picture_element_t;
}
extern "C" {
    pub fn lxb_html_picture_element_interface_destroy(
        picture_element: *mut lxb_html_picture_element_t,
    ) -> *mut lxb_html_picture_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_field_set_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_field_set_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_field_set_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_field_set_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_field_set_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_field_set_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_field_set_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_field_set_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_field_set_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_field_set_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_field_set_element_t;
}
extern "C" {
    pub fn lxb_html_field_set_element_interface_destroy(
        field_set_element: *mut lxb_html_field_set_element_t,
    ) -> *mut lxb_html_field_set_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_quote_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_quote_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_quote_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_quote_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_quote_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_quote_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_quote_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_quote_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_quote_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_quote_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_quote_element_t;
}
extern "C" {
    pub fn lxb_html_quote_element_interface_destroy(
        quote_element: *mut lxb_html_quote_element_t,
    ) -> *mut lxb_html_quote_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_li_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_li_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_li_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_li_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_li_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_li_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_li_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_li_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_li_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_li_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_li_element_t;
}
extern "C" {
    pub fn lxb_html_li_element_interface_destroy(
        li_element: *mut lxb_html_li_element_t,
    ) -> *mut lxb_html_li_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_progress_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_progress_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_progress_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_progress_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_progress_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_progress_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_progress_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_progress_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_progress_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_progress_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_progress_element_t;
}
extern "C" {
    pub fn lxb_html_progress_element_interface_destroy(
        progress_element: *mut lxb_html_progress_element_t,
    ) -> *mut lxb_html_progress_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_iframe_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_iframe_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_iframe_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_iframe_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_iframe_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_iframe_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_iframe_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_iframe_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_iframe_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_iframe_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_iframe_element_t;
}
extern "C" {
    pub fn lxb_html_iframe_element_interface_destroy(
        iframe_element: *mut lxb_html_iframe_element_t,
    ) -> *mut lxb_html_iframe_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_style_element {
    pub element: lxb_html_element_t,
    pub stylesheet: *mut lxb_css_stylesheet_t,
}
#[test]
fn bindgen_test_layout_lxb_html_style_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_style_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_style_element>(),
        184usize,
        concat!("Size of: ", stringify!(lxb_html_style_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_style_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_style_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_element),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stylesheet) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_style_element),
            "::",
            stringify!(stylesheet)
        )
    );
}
impl Default for lxb_html_style_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_style_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_style_element_t;
}
extern "C" {
    pub fn lxb_html_style_element_interface_destroy(
        style_element: *mut lxb_html_style_element_t,
    ) -> *mut lxb_html_style_element_t;
}
extern "C" {
    pub fn lxb_html_style_element_parse(element: *mut lxb_html_style_element_t) -> lxb_status_t;
}
extern "C" {
    pub fn lxb_html_element_style_remove(style: *mut lxb_html_style_element_t) -> lxb_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_select_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_select_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_select_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_select_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_select_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_select_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_select_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_select_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_select_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_select_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_select_element_t;
}
extern "C" {
    pub fn lxb_html_select_element_interface_destroy(
        select_element: *mut lxb_html_select_element_t,
    ) -> *mut lxb_html_select_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_details_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_details_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_details_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_details_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_details_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_details_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_details_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_details_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_details_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_details_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_details_element_t;
}
extern "C" {
    pub fn lxb_html_details_element_interface_destroy(
        details_element: *mut lxb_html_details_element_t,
    ) -> *mut lxb_html_details_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_div_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_div_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_div_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_div_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_div_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_div_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_div_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_div_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_div_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_div_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_div_element_t;
}
extern "C" {
    pub fn lxb_html_div_element_interface_destroy(
        div_element: *mut lxb_html_div_element_t,
    ) -> *mut lxb_html_div_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_d_list_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_d_list_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_d_list_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_d_list_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_d_list_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_d_list_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_d_list_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_d_list_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_d_list_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_d_list_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_d_list_element_t;
}
extern "C" {
    pub fn lxb_html_d_list_element_interface_destroy(
        d_list_element: *mut lxb_html_d_list_element_t,
    ) -> *mut lxb_html_d_list_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_html_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_html_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_html_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_html_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_html_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_html_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_html_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_html_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_html_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_html_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_html_element_t;
}
extern "C" {
    pub fn lxb_html_html_element_interface_destroy(
        html_element: *mut lxb_html_html_element_t,
    ) -> *mut lxb_html_html_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_map_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_map_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_map_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_map_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_map_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_map_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_map_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_map_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_map_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_map_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_map_element_t;
}
extern "C" {
    pub fn lxb_html_map_element_interface_destroy(
        map_element: *mut lxb_html_map_element_t,
    ) -> *mut lxb_html_map_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_br_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_br_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_br_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_br_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_br_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_br_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_br_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_br_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_br_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_br_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_br_element_t;
}
extern "C" {
    pub fn lxb_html_br_element_interface_destroy(
        br_element: *mut lxb_html_br_element_t,
    ) -> *mut lxb_html_br_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_text_area_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_text_area_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_text_area_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_text_area_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_text_area_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_text_area_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_text_area_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_text_area_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_text_area_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_text_area_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_text_area_element_t;
}
extern "C" {
    pub fn lxb_html_text_area_element_interface_destroy(
        text_area_element: *mut lxb_html_text_area_element_t,
    ) -> *mut lxb_html_text_area_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_legend_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_legend_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_legend_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_legend_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_legend_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_legend_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_legend_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_legend_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_legend_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_legend_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_legend_element_t;
}
extern "C" {
    pub fn lxb_html_legend_element_interface_destroy(
        legend_element: *mut lxb_html_legend_element_t,
    ) -> *mut lxb_html_legend_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_slot_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_slot_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_slot_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_slot_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_slot_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_slot_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_slot_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_slot_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_slot_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_slot_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_slot_element_t;
}
extern "C" {
    pub fn lxb_html_slot_element_interface_destroy(
        slot_element: *mut lxb_html_slot_element_t,
    ) -> *mut lxb_html_slot_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_body_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_body_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_body_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_body_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_body_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_body_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_body_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_body_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_body_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_body_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_body_element_t;
}
extern "C" {
    pub fn lxb_html_body_element_interface_destroy(
        body_element: *mut lxb_html_body_element_t,
    ) -> *mut lxb_html_body_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_param_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_param_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_param_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_param_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_param_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_param_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_param_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_param_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_param_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_param_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_param_element_t;
}
extern "C" {
    pub fn lxb_html_param_element_interface_destroy(
        param_element: *mut lxb_html_param_element_t,
    ) -> *mut lxb_html_param_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_track_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_track_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_track_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_track_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_track_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_track_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_track_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_track_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_track_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_track_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_track_element_t;
}
extern "C" {
    pub fn lxb_html_track_element_interface_destroy(
        track_element: *mut lxb_html_track_element_t,
    ) -> *mut lxb_html_track_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_frame_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_frame_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_frame_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_frame_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_frame_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_frame_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_frame_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_frame_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_frame_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_frame_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_frame_element_t;
}
extern "C" {
    pub fn lxb_html_frame_element_interface_destroy(
        frame_element: *mut lxb_html_frame_element_t,
    ) -> *mut lxb_html_frame_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_span_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_span_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_span_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_span_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_span_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_span_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_span_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_span_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_span_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_span_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_span_element_t;
}
extern "C" {
    pub fn lxb_html_span_element_interface_destroy(
        span_element: *mut lxb_html_span_element_t,
    ) -> *mut lxb_html_span_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_meta_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_meta_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_meta_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_meta_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_meta_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_meta_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_meta_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_meta_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_meta_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_meta_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_meta_element_t;
}
extern "C" {
    pub fn lxb_html_meta_element_interface_destroy(
        meta_element: *mut lxb_html_meta_element_t,
    ) -> *mut lxb_html_meta_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_hr_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_hr_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_hr_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_hr_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_hr_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_hr_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_hr_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_hr_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_hr_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_hr_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_hr_element_t;
}
extern "C" {
    pub fn lxb_html_hr_element_interface_destroy(
        hr_element: *mut lxb_html_hr_element_t,
    ) -> *mut lxb_html_hr_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_marquee_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_marquee_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_marquee_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_marquee_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_marquee_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_marquee_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_marquee_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_marquee_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_marquee_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_marquee_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_marquee_element_t;
}
extern "C" {
    pub fn lxb_html_marquee_element_interface_destroy(
        marquee_element: *mut lxb_html_marquee_element_t,
    ) -> *mut lxb_html_marquee_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_data_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_data_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_data_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_data_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_data_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_data_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_data_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_data_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_data_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_data_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_data_element_t;
}
extern "C" {
    pub fn lxb_html_data_element_interface_destroy(
        data_element: *mut lxb_html_data_element_t,
    ) -> *mut lxb_html_data_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_window {
    pub event_target: lxb_dom_event_target_t,
}
#[test]
fn bindgen_test_layout_lxb_html_window() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_window> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_window>(),
        8usize,
        concat!("Size of: ", stringify!(lxb_html_window))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_window>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_window))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_window),
            "::",
            stringify!(event_target)
        )
    );
}
impl Default for lxb_html_window {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_window_create(document: *mut lxb_html_document_t) -> *mut lxb_html_window_t;
}
extern "C" {
    pub fn lxb_html_window_destroy(window: *mut lxb_html_window_t) -> *mut lxb_html_window_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_heading_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_heading_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_heading_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_heading_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_heading_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_heading_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_heading_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_heading_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_heading_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_heading_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_heading_element_t;
}
extern "C" {
    pub fn lxb_html_heading_element_interface_destroy(
        heading_element: *mut lxb_html_heading_element_t,
    ) -> *mut lxb_html_heading_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_template_element {
    pub element: lxb_html_element_t,
    pub content: *mut lxb_dom_document_fragment_t,
}
#[test]
fn bindgen_test_layout_lxb_html_template_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_template_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_template_element>(),
        184usize,
        concat!("Size of: ", stringify!(lxb_html_template_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_template_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_template_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_template_element),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_template_element),
            "::",
            stringify!(content)
        )
    );
}
impl Default for lxb_html_template_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_template_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_template_element_t;
}
extern "C" {
    pub fn lxb_html_template_element_interface_destroy(
        template_element: *mut lxb_html_template_element_t,
    ) -> *mut lxb_html_template_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_source_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_source_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_source_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_source_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_source_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_source_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_source_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_source_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_source_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_source_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_source_element_t;
}
extern "C" {
    pub fn lxb_html_source_element_interface_destroy(
        source_element: *mut lxb_html_source_element_t,
    ) -> *mut lxb_html_source_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_canvas_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_canvas_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_canvas_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_canvas_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_canvas_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_canvas_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_canvas_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_canvas_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_canvas_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_canvas_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_canvas_element_t;
}
extern "C" {
    pub fn lxb_html_canvas_element_interface_destroy(
        canvas_element: *mut lxb_html_canvas_element_t,
    ) -> *mut lxb_html_canvas_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_embed_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_embed_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_embed_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_embed_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_embed_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_embed_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_embed_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_embed_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_embed_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_embed_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_embed_element_t;
}
extern "C" {
    pub fn lxb_html_embed_element_interface_destroy(
        embed_element: *mut lxb_html_embed_element_t,
    ) -> *mut lxb_html_embed_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_title_element {
    pub element: lxb_html_element_t,
    pub strict_text: *mut lexbor_str_t,
}
#[test]
fn bindgen_test_layout_lxb_html_title_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_title_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_title_element>(),
        184usize,
        concat!("Size of: ", stringify!(lxb_html_title_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_title_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_title_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_title_element),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strict_text) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_title_element),
            "::",
            stringify!(strict_text)
        )
    );
}
impl Default for lxb_html_title_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_title_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_title_element_t;
}
extern "C" {
    pub fn lxb_html_title_element_interface_destroy(
        title_element: *mut lxb_html_title_element_t,
    ) -> *mut lxb_html_title_element_t;
}
extern "C" {
    pub fn lxb_html_title_element_text(
        title: *mut lxb_html_title_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
extern "C" {
    pub fn lxb_html_title_element_strict_text(
        title: *mut lxb_html_title_element_t,
        len: *mut usize,
    ) -> *const lxb_char_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_o_list_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_o_list_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_o_list_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_o_list_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_o_list_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_o_list_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_o_list_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_o_list_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_o_list_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_o_list_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_o_list_element_t;
}
extern "C" {
    pub fn lxb_html_o_list_element_interface_destroy(
        o_list_element: *mut lxb_html_o_list_element_t,
    ) -> *mut lxb_html_o_list_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_output_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_output_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_output_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_output_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_output_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_output_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_output_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_output_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_output_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_output_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_output_element_t;
}
extern "C" {
    pub fn lxb_html_output_element_interface_destroy(
        output_element: *mut lxb_html_output_element_t,
    ) -> *mut lxb_html_output_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_frame_set_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_frame_set_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_frame_set_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_frame_set_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_frame_set_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_frame_set_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_frame_set_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_frame_set_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_frame_set_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_frame_set_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_frame_set_element_t;
}
extern "C" {
    pub fn lxb_html_frame_set_element_interface_destroy(
        frame_set_element: *mut lxb_html_frame_set_element_t,
    ) -> *mut lxb_html_frame_set_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_directory_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_directory_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_directory_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_directory_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_directory_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_directory_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_directory_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_directory_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_directory_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_directory_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_directory_element_t;
}
extern "C" {
    pub fn lxb_html_directory_element_interface_destroy(
        directory_element: *mut lxb_html_directory_element_t,
    ) -> *mut lxb_html_directory_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_mod_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_mod_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_mod_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_mod_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_mod_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_mod_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_mod_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_mod_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_mod_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_mod_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_mod_element_t;
}
extern "C" {
    pub fn lxb_html_mod_element_interface_destroy(
        mod_element: *mut lxb_html_mod_element_t,
    ) -> *mut lxb_html_mod_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_unknown_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_unknown_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_unknown_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_unknown_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_unknown_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_unknown_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_unknown_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_unknown_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_unknown_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_unknown_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_unknown_element_t;
}
extern "C" {
    pub fn lxb_html_unknown_element_interface_destroy(
        unknown_element: *mut lxb_html_unknown_element_t,
    ) -> *mut lxb_html_unknown_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_menu_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_menu_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_menu_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_menu_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_menu_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_menu_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_menu_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_menu_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_menu_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_menu_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_menu_element_t;
}
extern "C" {
    pub fn lxb_html_menu_element_interface_destroy(
        menu_element: *mut lxb_html_menu_element_t,
    ) -> *mut lxb_html_menu_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_button_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_button_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_button_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_button_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_button_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_button_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_button_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_button_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_button_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_button_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_button_element_t;
}
extern "C" {
    pub fn lxb_html_button_element_interface_destroy(
        button_element: *mut lxb_html_button_element_t,
    ) -> *mut lxb_html_button_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_time_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_time_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_time_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_time_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_time_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_time_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_time_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_time_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_time_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_time_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_time_element_t;
}
extern "C" {
    pub fn lxb_html_time_element_interface_destroy(
        time_element: *mut lxb_html_time_element_t,
    ) -> *mut lxb_html_time_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_base_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_base_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_base_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_base_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_base_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_base_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_base_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_base_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_base_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_base_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_base_element_t;
}
extern "C" {
    pub fn lxb_html_base_element_interface_destroy(
        base_element: *mut lxb_html_base_element_t,
    ) -> *mut lxb_html_base_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_meter_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_meter_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_meter_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_meter_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_meter_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_meter_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_meter_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_meter_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_meter_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_meter_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_meter_element_t;
}
extern "C" {
    pub fn lxb_html_meter_element_interface_destroy(
        meter_element: *mut lxb_html_meter_element_t,
    ) -> *mut lxb_html_meter_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_table_section_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_table_section_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_table_section_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_table_section_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_table_section_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_table_section_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_table_section_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_table_section_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_table_section_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_table_section_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_table_section_element_t;
}
extern "C" {
    pub fn lxb_html_table_section_element_interface_destroy(
        table_section_element: *mut lxb_html_table_section_element_t,
    ) -> *mut lxb_html_table_section_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_head_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_head_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_head_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_head_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_head_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_head_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_head_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_head_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_head_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_head_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_head_element_t;
}
extern "C" {
    pub fn lxb_html_head_element_interface_destroy(
        head_element: *mut lxb_html_head_element_t,
    ) -> *mut lxb_html_head_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_input_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_input_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_input_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_input_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_input_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_input_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_input_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_input_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_input_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_input_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_input_element_t;
}
extern "C" {
    pub fn lxb_html_input_element_interface_destroy(
        input_element: *mut lxb_html_input_element_t,
    ) -> *mut lxb_html_input_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_label_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_label_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_label_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_label_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_label_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_label_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_label_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_label_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_label_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_label_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_label_element_t;
}
extern "C" {
    pub fn lxb_html_label_element_interface_destroy(
        label_element: *mut lxb_html_label_element_t,
    ) -> *mut lxb_html_label_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_u_list_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_u_list_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_u_list_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_u_list_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_u_list_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_u_list_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_u_list_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_u_list_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_u_list_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_u_list_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_u_list_element_t;
}
extern "C" {
    pub fn lxb_html_u_list_element_interface_destroy(
        u_list_element: *mut lxb_html_u_list_element_t,
    ) -> *mut lxb_html_u_list_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_paragraph_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_paragraph_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_paragraph_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_paragraph_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_paragraph_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_paragraph_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_paragraph_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_paragraph_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_paragraph_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_paragraph_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_paragraph_element_t;
}
extern "C" {
    pub fn lxb_html_paragraph_element_interface_destroy(
        paragraph_element: *mut lxb_html_paragraph_element_t,
    ) -> *mut lxb_html_paragraph_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_audio_element {
    pub media_element: lxb_html_media_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_audio_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_audio_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_audio_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_audio_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_audio_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_audio_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).media_element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_audio_element),
            "::",
            stringify!(media_element)
        )
    );
}
impl Default for lxb_html_audio_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_audio_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_audio_element_t;
}
extern "C" {
    pub fn lxb_html_audio_element_interface_destroy(
        audio_element: *mut lxb_html_audio_element_t,
    ) -> *mut lxb_html_audio_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_image_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_image_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_image_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_image_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_image_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_image_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_image_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_image_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_image_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_image_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_image_element_t;
}
extern "C" {
    pub fn lxb_html_image_element_interface_destroy(
        image_element: *mut lxb_html_image_element_t,
    ) -> *mut lxb_html_image_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_link_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_link_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_link_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_link_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_link_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_link_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_link_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_link_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_link_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_link_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_link_element_t;
}
extern "C" {
    pub fn lxb_html_link_element_interface_destroy(
        link_element: *mut lxb_html_link_element_t,
    ) -> *mut lxb_html_link_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_opt_group_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_opt_group_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_opt_group_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_opt_group_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_opt_group_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_opt_group_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_opt_group_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_opt_group_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_opt_group_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_opt_group_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_opt_group_element_t;
}
extern "C" {
    pub fn lxb_html_opt_group_element_interface_destroy(
        opt_group_element: *mut lxb_html_opt_group_element_t,
    ) -> *mut lxb_html_opt_group_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_table_col_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_table_col_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_table_col_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_table_col_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_table_col_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_table_col_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_table_col_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_table_col_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_table_col_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_table_col_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_table_col_element_t;
}
extern "C" {
    pub fn lxb_html_table_col_element_interface_destroy(
        table_col_element: *mut lxb_html_table_col_element_t,
    ) -> *mut lxb_html_table_col_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_object_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_object_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_object_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_object_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_object_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_object_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_object_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_object_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_object_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_object_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_object_element_t;
}
extern "C" {
    pub fn lxb_html_object_element_interface_destroy(
        object_element: *mut lxb_html_object_element_t,
    ) -> *mut lxb_html_object_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_dialog_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_dialog_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_dialog_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_dialog_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_dialog_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_dialog_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_dialog_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_dialog_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_dialog_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_dialog_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_dialog_element_t;
}
extern "C" {
    pub fn lxb_html_dialog_element_interface_destroy(
        dialog_element: *mut lxb_html_dialog_element_t,
    ) -> *mut lxb_html_dialog_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_option_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_option_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_option_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_option_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_option_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_option_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_option_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_option_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_option_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_option_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_option_element_t;
}
extern "C" {
    pub fn lxb_html_option_element_interface_destroy(
        option_element: *mut lxb_html_option_element_t,
    ) -> *mut lxb_html_option_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_pre_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_pre_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_pre_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_pre_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_pre_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_pre_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_pre_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_pre_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_pre_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_pre_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_pre_element_t;
}
extern "C" {
    pub fn lxb_html_pre_element_interface_destroy(
        pre_element: *mut lxb_html_pre_element_t,
    ) -> *mut lxb_html_pre_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_form_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_form_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_form_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_form_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_form_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_form_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_form_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_form_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_form_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_form_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_form_element_t;
}
extern "C" {
    pub fn lxb_html_form_element_interface_destroy(
        form_element: *mut lxb_html_form_element_t,
    ) -> *mut lxb_html_form_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_table_caption_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_table_caption_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_table_caption_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_table_caption_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_table_caption_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_table_caption_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_table_caption_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_table_caption_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_table_caption_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_table_caption_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_table_caption_element_t;
}
extern "C" {
    pub fn lxb_html_table_caption_element_interface_destroy(
        table_caption_element: *mut lxb_html_table_caption_element_t,
    ) -> *mut lxb_html_table_caption_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_anchor_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_anchor_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_anchor_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_anchor_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_anchor_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_anchor_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_anchor_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_anchor_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_anchor_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_anchor_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_anchor_element_t;
}
extern "C" {
    pub fn lxb_html_anchor_element_interface_destroy(
        anchor_element: *mut lxb_html_anchor_element_t,
    ) -> *mut lxb_html_anchor_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_script_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_script_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_script_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_script_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_script_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_script_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_script_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_script_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_script_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_script_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_script_element_t;
}
extern "C" {
    pub fn lxb_html_script_element_interface_destroy(
        script_element: *mut lxb_html_script_element_t,
    ) -> *mut lxb_html_script_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_font_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_font_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_font_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_font_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_font_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_font_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_font_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_font_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_font_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_font_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_font_element_t;
}
extern "C" {
    pub fn lxb_html_font_element_interface_destroy(
        font_element: *mut lxb_html_font_element_t,
    ) -> *mut lxb_html_font_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_table_cell_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_table_cell_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_table_cell_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_table_cell_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_table_cell_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_table_cell_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_table_cell_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_table_cell_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_table_cell_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_table_cell_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_table_cell_element_t;
}
extern "C" {
    pub fn lxb_html_table_cell_element_interface_destroy(
        table_cell_element: *mut lxb_html_table_cell_element_t,
    ) -> *mut lxb_html_table_cell_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_table_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_table_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_table_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_table_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_table_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_table_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_table_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_table_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_table_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_table_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_table_element_t;
}
extern "C" {
    pub fn lxb_html_table_element_interface_destroy(
        table_element: *mut lxb_html_table_element_t,
    ) -> *mut lxb_html_table_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_table_row_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_table_row_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_table_row_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_table_row_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_table_row_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_table_row_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_table_row_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_table_row_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_table_row_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_table_row_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_table_row_element_t;
}
extern "C" {
    pub fn lxb_html_table_row_element_interface_destroy(
        table_row_element: *mut lxb_html_table_row_element_t,
    ) -> *mut lxb_html_table_row_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lxb_html_area_element {
    pub element: lxb_html_element_t,
}
#[test]
fn bindgen_test_layout_lxb_html_area_element() {
    const UNINIT: ::core::mem::MaybeUninit<lxb_html_area_element> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lxb_html_area_element>(),
        176usize,
        concat!("Size of: ", stringify!(lxb_html_area_element))
    );
    assert_eq!(
        ::core::mem::align_of::<lxb_html_area_element>(),
        8usize,
        concat!("Alignment of ", stringify!(lxb_html_area_element))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lxb_html_area_element),
            "::",
            stringify!(element)
        )
    );
}
impl Default for lxb_html_area_element {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lxb_html_area_element_interface_create(
        document: *mut lxb_html_document_t,
    ) -> *mut lxb_html_area_element_t;
}
extern "C" {
    pub fn lxb_html_area_element_interface_destroy(
        area_element: *mut lxb_html_area_element_t,
    ) -> *mut lxb_html_area_element_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut cty::c_char;
